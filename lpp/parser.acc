%prelude {

#include <stdio.h>
#include "TYPE.h"
#include "tree.h"
#include "hash.h"
#include "proc.h"

extern char yytext[] ;
extern int column ;

typedef char* charP ;
typedef ExpTreeNode* ExpTreeNodeP ;
typedef ExpTreeList* ExpTreeListP ;
typedef FuncListNode* FuncListNodeP ;
typedef FuncListHead* FuncListHeadP ;
typedef FileListNode* FileListNodeP ;
typedef FileListHead* FileListHeadP ;
typedef id_list* id_listP ;
typedef type_list* type_listP ;
typedef type_info* type_infoP ;
typedef table_entry* table_entryP ;

static FuncListNode* cur_statement ;
static FileListNode* cur_filenode ;

extern struct hashtable* global_def ;

}

%token IDENTIFIER, CONSTANT, STRING_LITERAL, SIZEOF, PTR_OP, INC_OP, DEC_OP, LEFT_OP, RIGHT_OP, LE_OP, GE_OP, EQ_OP, NE_OP, AND_OP, OR_OP, MUL_ASSIGN, DIV_ASSIGN, MOD_ASSIGN, ADD_ASSIGN, SUB_ASSIGN, LEFT_ASSIGN, RIGHT_ASSIGN, AND_ASSIGN, XOR_ASSIGN, OR_ASSIGN, TYPE_NAME, TYPEDEF, EXTERN, STATIC, AUTO, REGISTER, CHAR, SHORT, INT, LONG, SIGNED, UNSIGNED, FLOAT, DOUBLE, BOOL, CONST, VOLATILE, VOID, STRUCT, UNION, ENUM, ELIPSIS, RANGE, CASE, DEFAULT, IF, ELSE, SWITCH, WHILE, DO, FOR, GOTO, CONTINUE, BREAK, RETURN, DATATYPES, POINTWISE_RULE, UNIT_RULE, APPLY_RULE, SINGLETON_RULE, ITER_VAR_OP, JOIN, CONDITIONAL;
/**/
Start
	: file<file_node>
	{{
		FileListHead* file ;
		printf("#include <Loci.h>\n") ;
		file = (FileListHead *)
		  malloc(sizeof(FileListHead)) ;
		file->def = global_def ;
		file->list = file_node ;
		process_file(file) ;
	}}
	| declaration file<file_node>
	{{
		FileListHead* file ;
		printf("#include <Loci.h>\n") ;
		file = (FileListHead *)
		  malloc(sizeof(FileListHead)) ;
		file->def = global_def ;
		file->list = file_node ;
		process_file(file) ;
	}}
        | declaration
        {{
		printf("Correct!\n") ;
        }}
	;

argument_expr_list
<%out ExpTreeListP elist>
	: assignment_expr<assign_node>
	{{
		*elist = (ExpTreeList *)
		  malloc(sizeof(ExpTreeList)) ;
		(*elist)->node = assign_node ;
		(*elist)->next = NULL ;
	}}
	| argument_expr_list<arg_list> ',' assignment_expr<assign_node>
	{{
		ExpTreeList* tmp = (ExpTreeList *)
		  malloc(sizeof(ExpTreeList)) ;
		ExpTreeList* cur = arg_list ;
		tmp->node = assign_node ;
		tmp->next = NULL ;
		while(cur->next != NULL)
			cur = cur->next ;
		cur->next = tmp ;
		*elist = arg_list ;
	}}
	;

assignment_expr
<%out ExpTreeNodeP enode>
	: conditional_expr<cond_node>
	{{
		*enode = cond_node ;
	}}
	| unary_expr<unary_node> assignment_operator<op> assignment_expr<assign_node>
	{{
		createExpNode_BinaryOp(&(*enode), op, unary_node, assign_node) ;
	}}		
	;

assignment_operator
<%out op_id op>
	: '='
	{{
		*op = OP_EQU ;
	}}
	| MUL_ASSIGN
	{{
		*op = OP_MUL_EQU ;
	}}
	| DIV_ASSIGN
	{{
		*op = OP_DIV_EQU ;
	}}
	| MOD_ASSIGN
	{{
		*op = OP_MOD_EQU ;
	}}
	| ADD_ASSIGN
	{{
		*op = OP_PLUS_EQU ;
	}}
	| SUB_ASSIGN
	{{
		*op = OP_MINUS_EQU ;
	}}
	| LEFT_ASSIGN
	{{
		*op = OP_LEFT_SHIFT_EQU ;
	}}
	| RIGHT_ASSIGN
	{{
		*op = OP_RIGHT_SHIFT_EQU ;
	}}
	| AND_ASSIGN
	{{
		*op = OP_AND_EQU ;
	}}
	| XOR_ASSIGN
	{{
		*op = OP_XOR_EQU ;
	}}
	| OR_ASSIGN
	{{
		*op = OP_OR_EQU ;
	}}
	| JOIN
	{{
		*op = OP_JOIN ;
	}}
	;

expr
<%out ExpTreeNodeP enode>
	: assignment_expr<assign_node>
	{{
		*enode = assign_node ;
	}}
	| expr<expr_node> ',' assignment_expr<assign_node>
	;

init_declarator_list
<%out id_listP idlist>
	: init_declarator<i_d_list>
	{{
		*idlist = i_d_list ;
	}}
	| init_declarator_list<i_d_l_list> ',' init_declarator<i_d_list>
	{{
		id_listP tmp = i_d_l_list ;
		while(tmp->next != NULL)
			tmp = tmp->next ;
		tmp->next = i_d_list ;
		*idlist = i_d_l_list ;
	}}
	;

init_declarator
<%out id_listP idlist>
	: declarator<d_list>
	{{
		*idlist = d_list ;
	}}
	| declarator<d_list> '=' initializer
	;
/**/
storage_class_specifier
	: TYPEDEF
	| EXTERN
	| STATIC
	| AUTO
	| REGISTER
	;
/**/
type_specifier
<%out type_listP tlist>
        : simple_type_specifier<simple_list>
	{{
		*tlist = simple_list ;
	}}
	| class_specifier<clist>
	{{
		*tlist = clist ;
	}}
       	| elaborated_type_specifier<elist>
	{{
		*tlist = elist ;
	}}
	| cv_qualifier
	| struct_or_union_specifier
	| enum_specifier
	;

class_specifier
<%out type_listP tlist>
	: IDENTIFIER<id>
	{{
		type_info* tmp ;
		tmp = (type_info *)
		  malloc(sizeof(type_info)) ;
		tmp->user_tname = id.stringval ;
		tmp->type = Set_dp_id(tmp->user_tname) ;
		tmp->is_elabt = false ;
		tmp->begin_temp = false ;
		tmp->close_temp = false ;
		(*tlist) = (type_list *)
		  malloc(sizeof(type_list)) ;
		(*tlist)->info = tmp ;
		(*tlist)->next = NULL ;
	}}
	| IDENTIFIER<id> template_stuff<temp_type_info>
	{{
		type_info* tmp ;
		tmp = (type_info *)
		  malloc(sizeof(type_info)) ;
		tmp->user_tname = id.stringval ;
		tmp->type = Set_dp_id(tmp->user_tname) ;
		tmp->is_elabt = false ;
		tmp->begin_temp = true ;
		tmp->close_temp = false ;
		(*tlist) = (type_list *)
		  malloc(sizeof(type_list)) ;
		(*tlist)->info = tmp ;
		(*tlist)->next = temp_type_info ;
	}}
	;
/**/
elaborated_type_specifier
<%out type_listP tlist>
	: IDENTIFIER<id> ':' ':' class_specifier<clist>
	{{
		type_info* tmp ;
		tmp = (type_info *)
		  malloc(sizeof(type_info)) ;
		tmp->user_tname = id.stringval ;
		tmp->type = Set_dp_id(tmp->user_tname) ;
		tmp->is_elabt = true ;
		tmp->begin_temp = false ;
		tmp->close_temp = false ;
		(*tlist) = (type_list *)
		  malloc(sizeof(type_list)) ;
		(*tlist)->info = tmp ;
		(*tlist)->next = clist ;
	}}
	;
/**/
cv_qualifier
	: CONST
	| VOLATILE
	;
/**/
simple_type_specifier
<%out type_listP tlist> 
	: CHAR
	{{
		create_tlist(&(*tlist), DP_CHAR, NULL, false, false, false, NULL) ;
	}}
	| SHORT
	{{
		create_tlist(&(*tlist), DP_SHORT, NULL, false, false, false, NULL) ;
	}}
	| INT
	{{
		create_tlist(&(*tlist), DP_INT, NULL, false, false, false, NULL) ;
	}}
	| LONG
	{{
		create_tlist(&(*tlist), DP_LONG, NULL, false, false, false, NULL) ;
	}}
	| SIGNED
	{{
		create_tlist(&(*tlist), DP_SIGNED, NULL, false, false, false, NULL) ;
	}}
	| UNSIGNED
	{{
		create_tlist(&(*tlist), DP_UNSIGNED, NULL, false, false, false, NULL) ;
	}}
	| FLOAT
	{{
		create_tlist(&(*tlist), DP_FLOAT, NULL, false, false, false, NULL) ;
	}}
	| DOUBLE
	{{
		create_tlist(&(*tlist), DP_DOUBLE, NULL, false, false, false, NULL) ;
	}}
	| BOOL
	{{
		create_tlist(&(*tlist), DP_BOOL, NULL, false, false, false, NULL) ;
	}}
	| VOID
	{{
		create_tlist(&(*tlist), DP_VOID, NULL, false, false, false, NULL) ;
	}}
	| TYPE_NAME
	;

/**/
template_stuff
<%out type_listP tlist>
	: '<' template_argument_list<temp_arg_list> '>'
	{{
		type_list* tmp = temp_arg_list;
		while (tmp->next != NULL)
			tmp = tmp->next ;
		tmp->info->close_temp = true ;
		*tlist = temp_arg_list ;
	}}
	;
/**/
template_argument_list
<%out type_listP tlist>
	: template_argument<temp_arg>
	{{
		*tlist = temp_arg ;
	}}
	| template_argument_list<t_a_list> ',' template_argument<temp_arg>
	{{
		type_listP tmp = t_a_list;
		while(tmp->next != NULL)
			tmp = tmp->next ;
		tmp->next = temp_arg ;
		*tlist = t_a_list ;
	}}
	;
/**/
template_argument
<%out type_listP tlist>
	: type_specifier_list<t_l_info>
	{{
		*tlist = t_l_info ;
	}}
	| type_specifier_list<t_l_info> abstract_declarator
	| CONSTANT<c>
	{{
		create_tlist(&(*tlist), DP_USER, c.stringval, false, false, false, NULL) ;
	}}
	;

struct_or_union_specifier
	: struct_or_union identifier<id> '{' struct_declaration_list '}'
	| struct_or_union '{' struct_declaration_list '}'
	| struct_or_union identifier<id>
	;

struct_or_union
	: STRUCT
	| UNION
	;

struct_declaration_list
	: struct_declaration
	| struct_declaration_list struct_declaration
	;

struct_declaration
	: type_specifier_list<t_l_info> struct_declarator_list ';'
	;

struct_declarator_list
	: struct_declarator
	| struct_declarator_list ',' struct_declarator
	;

struct_declarator
	: declarator<d_list>
	| ':' constant_expr<enode>
	| declarator<d_list> ':' constant_expr<enode>
	;

enum_specifier
	: ENUM '{' enumerator_list '}'
	| ENUM identifier<id> '{' enumerator_list '}'
	| ENUM identifier<id>
	;

enumerator_list
	: enumerator
	| enumerator_list ',' enumerator
	;

enumerator
	: identifier<id>
	| identifier<id> '=' constant_expr<enode>
	;

type_specifier_list
<%out type_listP tinfo>
	: type_specifier<type_info>
	{{
		*tinfo = type_info ;
	}}
	| type_specifier_list<t_l_info> type_specifier<type_info>
	{{
		*tinfo = t_l_info ;
		t_l_info->next = type_info ;
	}}
	;

parameter_identifier_list
	: identifier_list
	| identifier_list ',' ELIPSIS
	;

identifier_list
	: identifier<id>
	| identifier_list ',' identifier<id>
	;

parameter_type_list
	: parameter_list
	| parameter_list ',' ELIPSIS
	;

parameter_list
	: parameter_declaration
	| parameter_list ',' parameter_declaration
	;

parameter_declaration
	: type_specifier_list<t_l_info> declarator<d_list>
	{{
		filltable(global_def, t_l_info, d_list) ;
	}}
	| type_name
	;

abstract_declarator
	: pointer
	| abstract_declarator2
	| pointer abstract_declarator2
	;

abstract_declarator2
	: '(' abstract_declarator ')'
	| '[' ']'
	| '[' constant_expr<enode> ']'
	| abstract_declarator2 '[' ']'
	| abstract_declarator2 '[' constant_expr<enode> ']'
	| '(' ')'
	| '(' parameter_type_list ')'
	| abstract_declarator2 '(' ')'
	| abstract_declarator2 '(' parameter_type_list ')'
	;

initializer
	: assignment_expr<assign_node>
	| '{' initializer_list '}'
	| '{' initializer_list ',' '}'
	;

initializer_list
	: initializer
	| initializer_list ',' initializer
	;

statement
<%out FuncListNodeP funcnode>
	: labeled_statement
	| compound_statement<compound_node>
	| expression_statement<enode>
	{{
		*funcnode = (FuncListNode *)
		  malloc(sizeof(FuncListNode)) ;
		(*funcnode)->exp = enode ;
		(*funcnode)->prev = NULL ;
		(*funcnode)->next = NULL ;
	}}
	| selection_statement
	| iteration_statement
	| jump_statement
	;

labeled_statement
	: identifier<id> ':' statement<s_node>
	| CASE constant_expr<enode> ':' statement<s_node>
	| DEFAULT ':' statement<s_node>
	;

compound_statement
<%out FuncListNodeP funcnode>
	: '{' '}'
	| '{' statement_list<sl_node> '}'
	{{
		*funcnode = sl_node ;
	}}	
	| '{' declaration_list '}'
	| '{' declaration_list statement_list<sl_node> '}'
	;

declaration_list
	: declaration
	| declaration_list declaration
	;

statement_list
<%out FuncListNodeP funcnode>
	: statement<s_node>
	{{
		/*global static variable*/
		cur_statement = s_node ;
		*funcnode = s_node ;
	}}
	| statement_list<sl_node> statement<s_node>
	{{
		cur_statement->next = s_node ;
		s_node->prev = cur_statement ;
		cur_statement = s_node ;
		*funcnode = sl_node ;
	}}
	;

expression_statement
<%out ExpTreeNodeP enode>
	: ';'
	| expr<expr_node> ';'
	{{
		*enode = expr_node ;
	}}
	;

selection_statement
	: IF '(' expr<expr_node> ')' statement<s_node>
	| IF '(' expr<expr_node> ')' statement<s_node> ELSE statement<s_node>
	| SWITCH '(' expr<expr_node> ')' statement<s_node>
	;

iteration_statement
	: WHILE '(' expr<expr_node> ')' statement<s_node>
	| DO statement<s_node> WHILE '(' expr<expr_node> ')' ';'
	| FOR '(' ';' ';' ')' statement<s_node>
	| FOR '(' ';' ';' expr<expr_node> ')' statement<s_node>
	| FOR '(' ';' expr<expr_node> ';' ')' statement<s_node>
	| FOR '(' ';' expr<expr_node> ';' expr<expr_node> ')' statement<s_node>
	| FOR '(' expr<expr_node> ';' ';' ')' statement<s_node>
	| FOR '(' expr<expr_node> ';' ';' expr<expr_node> ')' statement<s_node>
	| FOR '(' expr<expr_node> ';' expr<expr_node> ';' ')' statement<s_node>
	| FOR '(' expr<expr_node> ';' expr<expr_node> ';' expr<expr_node> ')' statement<s_node>
	;

jump_statement
	: GOTO identifier<id> ';'
	| CONTINUE ';'
	| BREAK ';'
	| RETURN ';'
	| RETURN expr<expr_node> ';'
	;

/*************************/
file
<%out FileListNodeP filenode>
	: external_definition<external_node>
	{{
		/*global static variable*/
		cur_filenode = external_node ;
		*filenode = external_node ;
	}}
	| file<file_node> external_definition<external_node>
	{{
		cur_filenode->next = external_node ;
		external_node->prev = cur_filenode ;
		/*global static variable*/
		cur_filenode = external_node ;
		*filenode = file_node ;
	}}
	;

external_definition
<%out FileListNodeP filenode>
	: function_definition
/**/
	| loci_rule_definition<loci_rule>
	{{
		*filenode = (FileListNode *)
		  malloc(sizeof(FileListNode)) ;
		(*filenode)->func = loci_rule ;
		(*filenode)->prev = NULL ;
		(*filenode)->next = NULL ;
	}}
/*	| declaration*/
	;


/*=======================*/
function_definition
	: declarator<d_list> function_body<fb_node>
	| declaration_specifiers<t_list> declarator<d_list> function_body<fb_node>
	;
/**/
loci_rule_definition
<%out FuncListHeadP funcnode>
	: loci_rule<rule_head> function_body<fb_node>
	{{
		rule_head->list = fb_node ;
		*funcnode = rule_head ;
	}}
	;
/**/
loci_rule
<%out FuncListHeadP rhead>
	: POINTWISE_RULE
	{{
		*rhead = (FuncListHead *)
		  malloc(sizeof(FuncListHead)) ;
		(*rhead)->rule_type = POINTWISE_T ;
		(*rhead)->is_rule = true ;
		(*rhead)->is_cond = false ;
		(*rhead)->unit_arg = NULL ;
		(*rhead)->apply_arg = NULL ;
		(*rhead)->cond_arg = NULL ;
	}}
	| SINGLETON_RULE
	{{
		*rhead = (FuncListHead *)
		  malloc(sizeof(FuncListHead)) ;
		(*rhead)->rule_type = SINGLETON_T ;
		(*rhead)->is_rule = true ;
		(*rhead)->is_cond = false ;
		(*rhead)->unit_arg = NULL ;
		(*rhead)->apply_arg = NULL ;
		(*rhead)->cond_arg = NULL ;
	}}
	| POINTWISE_RULE '(' CONDITIONAL identifier<id>/*04/24*/ ')'
	{{
		*rhead = (FuncListHead *)
		  malloc(sizeof(FuncListHead)) ;
		(*rhead)->rule_type = POINTWISE_T ;
		(*rhead)->is_rule = true ;
		(*rhead)->is_cond = true ;
		(*rhead)->unit_arg = NULL ;
		(*rhead)->apply_arg = NULL ;
		(*rhead)->cond_arg = (ExpTreeList *)
		  malloc(sizeof(ExpTreeList)) ;
		(*rhead)->cond_arg->node = id ;
		(*rhead)->cond_arg->next = NULL ;
	}}
	| SINGLETON_RULE '(' CONDITIONAL identifier<id>/*04/24*/ ')'
	{{
		*rhead = (FuncListHead *)
		  malloc(sizeof(FuncListHead)) ;
		(*rhead)->rule_type = SINGLETON_T ;
		(*rhead)->is_rule = true ;
		(*rhead)->is_cond = true ;
		(*rhead)->unit_arg = NULL ;
		(*rhead)->apply_arg = NULL ;
		(*rhead)->cond_arg = (ExpTreeList *)
		  malloc(sizeof(ExpTreeList)) ;
		(*rhead)->cond_arg->node = id ;
		(*rhead)->cond_arg->next = NULL ;
	}}
	| UNIT_RULE IDENTIFIER/*CONSTRAINT*/ '(' identifier<id> ')'
	{{
		*rhead = (FuncListHead *)
		  malloc(sizeof(FuncListHead)) ;
		(*rhead)->rule_type = UNIT_T ;
		(*rhead)->is_rule = true ;
		(*rhead)->is_cond = false ;
		(*rhead)->unit_arg = (ExpTreeList *)
		  malloc(sizeof(ExpTreeList)) ;
		(*rhead)->unit_arg->node = id ;
		(*rhead)->unit_arg->next = NULL ;
		(*rhead)->apply_arg = NULL ;
		(*rhead)->cond_arg = NULL ;
	}}
	| APPLY_RULE '(' template_argument_list<t_a_list> ')'
	{{
		*rhead = (FuncListHead *)
		  malloc(sizeof(FuncListHead)) ;
		(*rhead)->rule_type = APPLY_T ;
		(*rhead)->is_rule = true ;
		(*rhead)->is_cond = false ;
		(*rhead)->unit_arg = NULL ;
		(*rhead)->apply_arg = t_a_list ;
		(*rhead)->cond_arg = NULL ;
	}}
	;

/*-----------------------*/
declarator
<%out id_listP idlist>
	: declarator2<d2_list>
	{{
		*idlist = d2_list ;
	}}
	| pointer declarator2<d2_list>
	;

declarator2
<%out id_listP idlist>
	: identifier<id>
	{{
		(*idlist) = (id_list *)
		  malloc(sizeof(id_list)) ;
		(*idlist)->name = id->name ;
		(*idlist)->init = NULL ;
		(*idlist)->next = NULL ;
	}}
	| '(' declarator<d_list> ')'
	| declarator2<d2_list> '[' ']'
	| declarator2<d2_list> '[' constant_expr<enode> ']'
	| declarator2<d2_list> '(' ')'
	| declarator2<d2_list> '(' parameter_type_list ')' 
	{{
		*idlist = d2_list ;
	}} 
	| declarator2<d2_list> '(' parameter_identifier_list ')' 
	;

identifier
<%out ExpTreeNodeP enode>
	: IDENTIFIER<id>
	{{
		createExpNode(&(*enode), OP_ID, id.stringval) ;
	}}
	;

constant_expr
<%out ExpTreeNodeP enode>
	: conditional_expr<cond_node>
	{{
		*enode = cond_node ;
	}}
	;

conditional_expr
<%out ExpTreeNodeP enode>
	: logical_or_expr<logor_node>
	{{
		*enode = logor_node ;
	}}
	| logical_or_expr<logor_node> '?' logical_or_expr<logor_node> ':' conditional_expr<cond_node>
	;

logical_or_expr
<%out ExpTreeNodeP enode>
	: logical_and_expr<logand_node>
	{{
		*enode = logand_node ;
	}}
	| logical_or_expr<logor_node> OR_OP logical_and_expr<logand_node>
	{{
		createExpNode_BinaryOp(&(*enode), OP_LOGICAL_OR, logor_node, logand_node) ;
	}}
	;

logical_and_expr
<%out ExpTreeNodeP enode>
	: inclusive_or_expr<inclusive_node>
	{{
		*enode = inclusive_node ;
	}}
	| logical_and_expr<logand_node> AND_OP inclusive_or_expr<inclusive_node>
	{{
		createExpNode_BinaryOp(&(*enode), OP_LOGICAL_AND, logand_node, inclusive_node) ;
	}}
	;

inclusive_or_expr
<%out ExpTreeNodeP enode>
	: exclusive_or_expr<exclusive_node>
	{{
		*enode = exclusive_node ;
	}}
	| inclusive_or_expr<inclusive_node> '|' exclusive_or_expr<exclusive_node>
	{{
		createExpNode_BinaryOp(&(*enode), OP_OR, inclusive_node, exclusive_node) ;
	}}
	;

exclusive_or_expr
<%out ExpTreeNodeP enode>
	: and_expr<and_node>
	{{
		*enode = and_node ;
	}}
	| exclusive_or_expr<exclusive_node> '^' and_expr<and_node>
	{{
		createExpNode_BinaryOp(&(*enode), OP_XOR, exclusive_node, and_node) ;
	}}
	;

and_expr
<%out ExpTreeNodeP enode>
	: equality_expr<equ_node>
	{{
		*enode = equ_node ;
	}}
	| and_expr<and_node> '&' equality_expr<equ_node>
	{{
		createExpNode_BinaryOp(&(*enode), OP_AND, and_node, equ_node) ;
	}}
	;

equality_expr
<%out ExpTreeNodeP enode>
	: relational_expr<rel_node>
	{{
		*enode = rel_node ;
	}}
	| equality_expr<equ_node> EQ_OP relational_expr<rel_node>
	{{
		createExpNode_BinaryOp(&(*enode), OP_EQU_EQU, equ_node, rel_node) ;
	}}
	| equality_expr<equ_node> NE_OP relational_expr<rel_node>
	{{
		createExpNode_BinaryOp(&(*enode), OP_NOT_EQU, equ_node, rel_node) ;
	}}
	;

relational_expr
<%out ExpTreeNodeP enode>
	: shift_expr<shift_node>
	{{
		*enode = shift_node ;
	}}
	| relational_expr<rel_node> '<' shift_expr<shift_node>
	{{
		createExpNode_BinaryOp(&(*enode), OP_LESS, rel_node, shift_node) ;
	}}
	| relational_expr<rel_node> '>' shift_expr<shift_node>
	{{
		createExpNode_BinaryOp(&(*enode), OP_GREATER, rel_node, shift_node) ;
	}}
	| relational_expr<rel_node> LE_OP shift_expr<shift_node>
	{{
		createExpNode_BinaryOp(&(*enode), OP_LESS_EQU, rel_node, shift_node) ;
	}}
	| relational_expr<rel_node> GE_OP shift_expr<shift_node>
	{{
		createExpNode_BinaryOp(&(*enode), OP_GREATER_EQU, rel_node, shift_node) ;
	}}
	;

shift_expr
<%out ExpTreeNodeP enode>
	: additive_expr<add_node>
	{{
		*enode = add_node ;
	}}
	| shift_expr<shift_node> LEFT_OP additive_expr<add_node>
	{{
		createExpNode_BinaryOp(&(*enode), OP_LEFT_SHIFT, shift_node, add_node) ;
	}}
	| shift_expr<shift_node> RIGHT_OP additive_expr<add_node>
	{{
		createExpNode_BinaryOp(&(*enode), OP_RIGHT_SHIFT, shift_node, add_node) ;
	}}
	;

additive_expr
<%out ExpTreeNodeP enode>
	: multiplicative_expr<mul_node>
	{{
		*enode = mul_node ;
	}}
	| additive_expr<add_node> '+' multiplicative_expr<mul_node>
	{{
		createExpNode_BinaryOp(&(*enode), OP_ADD, add_node, mul_node) ;
	}}
	| additive_expr<add_node> '-' multiplicative_expr<mul_node>
	{{
		createExpNode_BinaryOp(&(*enode), OP_SUB, add_node, mul_node) ;
	}}
	;

multiplicative_expr
<%out ExpTreeNodeP enode>
	: cast_expr<cast_node>
	{{
		*enode = cast_node ;
	}}
	| multiplicative_expr<mul_node> '*' cast_expr<cast_node>
	{{
		createExpNode_BinaryOp(&(*enode), OP_MUL, mul_node, cast_node) ;
	}}
	| multiplicative_expr<mul_node> '/' cast_expr<cast_node>
	{{
		createExpNode_BinaryOp(&(*enode), OP_DIV, mul_node, cast_node) ;
	}}
	| multiplicative_expr<mul_node> '%' cast_expr<cast_node>
	{{
		createExpNode_BinaryOp(&(*enode), OP_MOD, mul_node, cast_node) ;
	}}
	;

cast_expr
<%out ExpTreeNodeP enode>
	: unary_expr<unary_node>
	{{
		*enode = unary_node ;
	}}
	| '(' type_name ')' cast_expr<cast_node>
	;

unary_expr
<%out ExpTreeNodeP enode>
	: postfix_expr<post_node>
	{{
		*enode = post_node ;
	}}
	| INC_OP unary_expr<unary_node>
	{{
		createExpNode_UnaryOp(&(*enode), OP_PLUS_PLUS, unary_node) ;
	}}
	| DEC_OP unary_expr<unary_node>
	{{
		createExpNode_UnaryOp(&(*enode), OP_MINUS_MINUS, unary_node) ;
	}}
	| unary_operator<u_op> cast_expr<cast_node>
	{{
		createExpNode_UnaryOp(&(*enode), u_op, cast_node) ;
	}}
	| ITER_VAR_OP unary_expr<unary_node>
	{{
		createExpNode_UnaryOp(&(*enode), OP_DOLLAR, unary_node) ;
	}}
	| SIZEOF unary_expr<unary_node>
	| SIZEOF '(' type_name ')'
	;

postfix_expr
<%out ExpTreeNodeP enode>
	: primary_expr<pri_node>
	{{
		*enode = pri_node;
	}}
	| postfix_expr<post_node> '[' expr<expr_node> ']'
	| postfix_expr<post_node> '(' ')'
	| postfix_expr<post_node> '(' argument_expr_list<arg_list> ')'
	{{
		if(Is_Loci_var(post_node->name,global_def)
		   == true)
		{ 
			post_node->op = OP_PARAMETRIC_ID ;
			Set_Par_Arg(arg_list) ;
		}
		else
		{
			post_node->op = OP_FUNC ;
		}
		post_node->list1 = arg_list ;
		*enode = post_node ;
	}}
	| postfix_expr<post_node> '{' argument_expr_list<arg_list> '}'
	{{
		if(Is_Loci_var(post_node->name,global_def)
		   == true)
		{ 
			/*post_node->op = OP_ITERWARG_ID ;*/
			Set_Iter_Arg(arg_list) ;
		}
		else
		{
			post_node->op = OP_FUNC ;
		}
		post_node->list1 = arg_list ;
		*enode = post_node ;
	}}
	| postfix_expr<post_node> '.' identifier<id>
	| postfix_expr<post_node> PTR_OP identifier<id>
	{{
		if((post_node->name) != NULL)
		{
      			if(Is_Loci_var(post_node->name, global_def)
			   == true)
			{
				createExpNode_BinaryOp(&(*enode), OP_MAP, post_node, id);
      			}
    		}
		else
			createExpNode_BinaryOp(&(*enode), OP_ARROW, post_node, id);
	}}
	| postfix_expr<post_node> INC_OP
	| postfix_expr<post_node> DEC_OP
	;

primary_expr
<%out ExpTreeNodeP enode>
	: identifier<id>
	{{
		*enode = id ;
	}}
	| CONSTANT<num>
	{{
		createExpNode(&(*enode), OP_NUM, num.stringval) ;
	}}
	| STRING_LITERAL<s>
	{{
		createExpNode(&(*enode), OP_STRING, s.stringval) ;
	}}
	| '(' expr<expr_node> ')'
	{{
		*enode = expr_node ;
	}}
	;

unary_operator
<%out op_id u_op>
	: '&'
	| '*'
	| '+'
	| '-'
	{{
		*u_op = OP_USUB ;
	}}
	| '~'
	| '!'
	;

type_name
	: type_specifier_list<t_l_name>
	| type_specifier_list<t_l_name> abstract_declarator
	;

pointer
	: '*'
	| '*' type_specifier_list<t_l_name>
	| '*' pointer
	| '*' type_specifier_list<t_l_name> pointer
	;

/*-----------------------*/
function_body
<%out FuncListNodeP funcnode>
	: compound_statement<compound_node>
	{{
		*funcnode = compound_node ;
	}}
	| declaration_list compound_statement<compound_node>
	;

/*=======================*/
declaration
	: declaration_specifiers<tlist> ';'
/**/
	| DATATYPES '{' loci_declaration_list '}'
	;

loci_declaration_list:
	 loci_declaration
	| loci_declaration_list loci_declaration
	;

loci_declaration:
 declaration_specifiers<tlist> init_declarator_list<i_d_l_list> ';'
	{{
		filltable(global_def, tlist, i_d_l_list) ;
	}}
;

declaration_specifiers
<%out type_listP tlist>
	: storage_class_specifier
	| storage_class_specifier declaration_specifiers<type_list>
	| type_specifier<type_info_list>
	{{
		*tlist = type_info_list ;
	}}
	| type_specifier<type_info_list> declaration_specifiers<type_list>
	;



/* end-of-file */
