//#############################################################################
//#
//# Copyright 2008, Mississippi State University
//#
//# This file is part of the Loci Framework.
//#
//# The Loci Framework is free software: you can redistribute it and/or modify
//# it under the terms of the Lesser GNU General Public License as published by
//# the Free Software Foundation, either version 3 of the License, or
//# (at your option) any later version.
//#
//# The Loci Framework is distributed in the hope that it will be useful,
//# but WITHOUT ANY WARRANTY; without even the implied warranty of
//# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//# Lesser GNU General Public License for more details.
//#
//# You should have received a copy of the Lesser GNU General Public License
//# along with the Loci Framework.  If not, see <http://www.gnu.org/licenses>
//#
//#############################################################################
#include <Loci.h>
#include <string>
#include <iostream>
#include <sstream>
#include <sys/stat.h>
#include <unistd.h>
$include "FVM.lh"

using std::string ;
using std::endl ;
using std::cerr ;
using std::cout ;
using std::ostringstream ;


int main(int ac, char *av[]) {
  Loci::Init(&ac, &av) ;
  // default query 
  string query = "report" ;
  // if output directory doesn't exist, create one
  struct stat statbuf ;
  if(Loci::MPI_rank == 0) {
    if(stat("output",&statbuf))
      mkdir("output",0755) ;
    else
      if(!S_ISDIR(statbuf.st_mode)) {
        cerr << "file 'output' should be a directory!, rename 'output' and start again."
             << endl ;
        Loci::Abort() ;
      }

    cout << "Loci version: " << Loci::version() << endl ;
  }

  rule_db rdb ;
  rdb.add_rules(global_rule_list) ;

  fact_db facts ;
  Loci::load_module("fvm",rdb) ;

  bool use_exact = false ;

  while(ac>=2 && av[1][0] == '-') {
    // If user specifies an alternate query, extract it from the
    // command line.
    if(ac >= 3 && !strcmp(av[1],"-q")) {
      query = av[2] ;
      ac -= 2 ;
      av += 2 ;
    } else if(ac >= 2 && !strcmp(av[1],"-exact")) {
      use_exact = true ;
      ac -= 1 ;
      av += 1 ;
    } else if(ac >= 2 && !strcmp(av[1],"-v")) {
      cout << "Loci version: " << Loci::version() << endl ;
      if(ac == 2) {
        Loci::Finalize() ;
        exit(0) ;
      }
      ac-- ;
      av++ ;
    } else {
      cerr << "argument " << av[1] << " is not understood." << endl ;
      ac-- ;
      av++ ;
    }
  }


  if(ac > 1) {
    string tmp = av[1] ;
    
    string basename;
    bool has_dot = false ;
    for(size_t i=0;i<tmp.size();++i) 
      if(tmp[i] == '.') {
        has_dot = true ;
        break ;
      } else
        basename += tmp[i] ;

    string filename = string(av[1]) ;
    if(!has_dot)
      filename += ".vog" ;
    param<std::string> modelName ;
    
    *modelName = basename ;
    facts.create_fact("modelName",modelName) ;
    if(Loci::MPI_rank == 0)
      cout << "Reading: '" << filename <<"' ..." <<  endl  ;
    if(!Loci::setupFVMGrid(facts,filename)) {
      if(Loci::MPI_rank == 0) {
        cerr << "Reading grid file '" << filename <<"' failed in grid reader!"
             << endl ;
      }
      Loci::Abort() ;
    }

    if(Loci::MPI_rank == 0) {
      cout << "finished reading grid." << endl ;
    }

    Loci::createLowerUpper(facts) ;

    if(use_exact)  {
      param<std::string> centroid ;
      *centroid = "exact" ;
      facts.create_fact("centroid",centroid) ;
    }

    if(!Loci::makeQuery(rdb,facts,query)) {
      cerr << "query for '" << query << "' failed. " << endl ;
      Loci::Abort() ;
    }
    
  }
}
$type topo param<int> ;

$rule unit(topo),constraint(UNIVERSE) {
  $topo = 0 ;
}

class output_grid_topology : public apply_rule<param<int>, Loci::Maximum<int> > {
  param<int> topo ;
  const_multiMap upper,lower,boundary_map,face2node ;
  const_store<vector3d<double> > pos ;
  const_Map ref ;
  const_store<string> boundary_names ;
  const_param<string> modelName ;
public:
  output_grid_topology() {
    name_store("topo",topo) ;
    name_store("upper",upper) ;
    name_store("lower",lower) ;
    name_store("boundary_map",boundary_map) ;
    name_store("face2node",face2node) ;
    name_store("ref",ref) ;
    name_store("boundary_names",boundary_names) ;
    name_store("modelName",modelName) ;
    name_store("pos",pos) ;
    input("modelName") ;
    input("(upper,lower,boundary_map)->face2node->pos") ;
    input("boundary_map->ref->boundary_names") ;
    output("topo") ;
    disable_threading() ;
  }
    
  void compute(const sequence &seq) ;
} ;



void output_grid_topology::compute(const sequence &seq) {
  if(Loci::MPI_rank == 0)
    Loci::debugout<< "calling write grid topology" << endl ;
  string filename = "output/"+*modelName+".topo" ;
  Loci::parallelWriteGridTopology(filename.c_str(),
                                  upper.Rep(),lower.Rep(),boundary_map.Rep(),
                                  face2node.Rep(),
                                  ref.Rep(),
                                  boundary_names.Rep(),
                                  pos.Rep(),
                                  entitySet(seq)) ;
}


register_rule<output_grid_topology> register_output_grid_topology ;

void dump_pos(const sequence &seq,const_store<vector3d<double> > &pos,
              const_param<string> &modelName) {
  ostringstream oss ;
  int cycle = 0 ;
    
  oss << "output/grid_pos." << cycle << "_" << *modelName ;
  string filename = oss.str() ;

  if(Loci::MPI_rank == 0)
    Loci::debugout << "writing file " << filename << endl ;


  hid_t file_id = Loci::hdf5CreateFile(filename.c_str(),H5F_ACC_TRUNC,
                                        H5P_DEFAULT, H5P_DEFAULT) ;

  Loci::writeContainer(file_id,"pos",pos.Rep()) ;

  Loci::hdf5CloseFile(file_id) ;
}

class output_grid_positions: public apply_rule<param<int>, Loci::Maximum<int> > {
  const_store<vector3d<double> > pos ;
  const_param<string> modelName ;
  param<int> topo ;
public:
  output_grid_positions() {
    name_store("pos",pos) ;
    name_store("modelName",modelName) ;
    name_store("topo",topo) ;
      
    constraint("pos") ;
    input("pos") ;
    input("modelName") ;
    output("topo") ;
  }
  void compute(const sequence &seq) {
    dump_pos(seq,pos,modelName) ;
  }
} ;
register_rule<output_grid_positions> register_output_grid_positions ;

$type volume store<double> ;

$rule pointwise(volume<-cellcenter,(upper,lower,boundary_map)->(area,facecenter)) {
  double sum = 0.0 ;
  vector3d<double> dv ;
  for(const Entity* nf=$upper.begin();nf!=$upper.end();++nf) {
    dv = nf->$facecenter - $cellcenter ;
    sum = sum + nf->$area.sada*(dot(dv,nf->$area.n)) ;
  }
  for(const Entity* nf=$lower.begin();nf!=$lower.end();++nf) {
    dv = nf->$facecenter - $cellcenter ;
    sum = sum - nf->$area.sada*(dot(dv,nf->$area.n)) ;
  }
  for(const Entity* nf=$boundary_map.begin();nf!=$boundary_map.end();++nf) {
    dv = nf->$facecenter - $cellcenter ;
    sum = sum + nf->$area.sada*(dot(dv,nf->$area.n)) ;
  }
  $volume = sum/3.0 ;
}

$type cellVolRatio store<double> ;

$rule unit(cellVolRatio),constraint(volume) {
  $cellVolRatio = 1 ;
}

$type ratio store<double> ;
$rule pointwise(ratio<-(cl,cr)->volume) {
  const double mxvol = max($cl->$volume,$cr->$volume) ;
  const double mnvol = max(min($cl->$volume,$cr->$volume),1e-30) ;
  $ratio = mxvol/mnvol ;
}

$rule apply(cl->cellVolRatio<-ratio)[Loci::Maximum] {
  join($cl->$cellVolRatio,$ratio) ;
}
$rule apply(cr->cellVolRatio<-ratio) [Loci::Maximum] {
  join($cr->$cellVolRatio,$ratio) ;
}


$type volRatio param<double> ;

$rule unit(volRatio),constraint(volume) {
  $volRatio = 0 ;
}

$rule apply(volRatio<-cellVolRatio)[Loci::Maximum] {
  join($volRatio,$cellVolRatio) ;
}


$type faceAngle store<double> ;

$rule pointwise(faceAngle<-cl->cellcenter,cr->cellcenter,facecenter) {
  // maximum angle between line segment connecting cellcenters and line
  // segments that connect cell centers to face centers.
  vector3d<double> v1 = $cr->$cellcenter-$cl->$cellcenter ;
  vector3d<double> v2 = $facecenter-$cl->$cellcenter ;
  vector3d<double> v3 = $cr->$cellcenter-$facecenter ;
  double nv1 = norm(v1) ;
  double nv2 = norm(v2) ;
  double nv3 = norm(v3) ;
  double rad2deg = 360./(2.*3.1415927) ;
  $faceAngle = rad2deg*acos(min(dot(v1,v2)/(nv1*nv2),dot(v1,v3)/(nv1*nv3))) ;
}

$rule pointwise(faceAngle<-ci->cellcenter,facecenter,area) {
  vector3d<double> v1 = $ci->$cellcenter-$facecenter ;
  vector3d<double> v2 = $area.n*dot(v1,$area.n) ;
  double rad2deg = 360./(2.*3.1415927) ;
  $faceAngle = rad2deg*acos(fabs(dot(v1,v2))/(norm(v1)*norm(v2))) ;
}

$type cellFaceAngle store<double> ;

$rule unit(cellFaceAngle),constraint(volume) {
  $cellFaceAngle = 0 ;
}
$rule apply(cl->cellFaceAngle<-faceAngle)[Loci::Maximum] {
  join($cl->$cellFaceAngle,$faceAngle) ;
}
$rule apply(cr->cellFaceAngle<-faceAngle)[Loci::Maximum] {
  join($cr->$cellFaceAngle,$faceAngle) ;
}

$type maxCellAngle param<double> ;
$rule unit(maxCellAngle), constraint(volume) {
  $maxCellAngle = 0 ;
}
$rule apply(maxCellAngle<-cellFaceAngle)[Loci::Maximum] {
  join($maxCellAngle,$cellFaceAngle) ;
}


$type faceTwisted store<double> ;
$rule pointwise(faceTwisted<-facecenter,face2node->pos,area) {
  int sz = $face2node.size() ;
  double maxlen = 0 ;
  double maxdel = 0 ;
  const vector3d<double> n = $area.n ;
  for(int i=0;i<sz;++i) {
    const vector3d<double> dv = $facecenter-$face2node[i]->$pos ;
    maxlen = max(dot(dv,dv),maxlen) ;
    maxdel = max(dot(dv,n),maxdel) ;
    
  }
  $faceTwisted = maxdel/sqrt(maxlen) ;
}

$type cellTwist store<double> ;

$rule unit(cellTwist),constraint(volume) {
  $cellTwist = 0 ;
}
$rule apply(cl->cellTwist<-faceTwisted)[Loci::Maximum] {
  join($cl->$cellTwist,$faceTwisted) ;
}
$rule apply(cr->cellTwist<-faceTwisted)[Loci::Maximum] {
  join($cr->$cellTwist,$faceTwisted) ;
}

$type faceShearTwist store<double> ;
$rule pointwise(faceShearTwist<-cl->(cellcenter,volume),cr->(cellcenter,volume),facecenter,face2node->pos,area) {
  int sz = $face2node.size() ;
  double maxdel = 0 ;
  const vector3d<double> n = $area.n ;
  for(int i=0;i<sz;++i) {
    const vector3d<double> dv = $facecenter-$face2node[i]->$pos ;
    maxdel = max(dot(dv,n),maxdel) ;
  }
  vector3d<double> vl = $facecenter-$cl->$cellcenter ;
  vector3d<double> vr = $cr->$cellcenter-$facecenter ;
  double dl = dot(vl,n) ;
  double dr = dot(vr,n) ;
  //  double tl = norm(vl-dl*n) ;
  //  double tr = norm(vr-dr*n) ;

  // Twist factor ratio of out of plane delta to cell thickness
  double thickness = ($cl->$volume+$cr->$volume)/$area.sada ;
  double twist_factor = maxdel/thickness ;
  // shear factor measures how much displacement from a normal projection
  // of the surface to the surface charactersitic distance
  double shear_factor = sqrt((dot(vl-dl*n,vl-dl*n)+dot(vr-dr*n,vr-dr*n))/
                             $area.sada) ;
  // anisotropy factor, ratio of thickness to unit sphere radius
  double aniso_factor = thickness/pow($cl->$volume+$cr->$volume,1./3.);
  $faceShearTwist = twist_factor*shear_factor*aniso_factor ;
    
}


$type cellShearTwist store<double> ;

$rule unit(cellShearTwist),constraint(volume) {
  $cellShearTwist = 0 ;
}
$rule apply(cl->cellShearTwist<-faceShearTwist)[Loci::Maximum] {
  join($cl->$cellShearTwist,$faceShearTwist) ;
}
$rule apply(cr->cellShearTwist<-faceShearTwist)[Loci::Maximum] {
  join($cr->$cellShearTwist,$faceShearTwist) ;
}

  

$type report param<bool> ;
$type minVol param<double> ;
$type maxTwist param<double> ;
$type maxShearTwist param<double> ;
$type modelName param<string> ;
$type convexCell param<int> ;

$rule singleton(report<-volRatio,maxCellAngle,minVol,maxTwist,maxShearTwist,topo,modelName,convexCell) {
  if(Loci::MPI_rank == 0) {
    if($minVol <= 0) {
      cerr << "Negative or zero volume cell!  The grid quality is too poor to use." << endl ;
    }
    cout << "A volume ratio less than 10 is ideal:" << endl;
    cout << "======Maximum cell volume ratio = " << $volRatio << endl ;
    cout << "======Minimum cell volume " << $minVol << endl ;
    cout << endl ;
    cout << "The angle between the face normal and cell centroids provides an indication "
         << endl
         << "of mesh isotropy.  The lower this number the better the mesh quality.  Values"
         << endl
         << "below 100 are desirable.  Values above 150 indicate very poor mesh quality."
         << endl ;

    cout << "======Maximum cell to face angle = " << $maxCellAngle << endl ;
    cout << endl ;

    cout << "For non-triangular faces it is possible for the face to be non-planar, "
         << endl
         << "i.e. twisted.  The twist metric measure the  non-planar component of the face"
         << endl 
         << "geometry.  In other words a value of 0.1 indicates that the face geometry"
         << endl
         << "deviates from the planar description by 10 percent.  "
         << endl
         << "A value below 0.1 is desirable:" << endl ;
    cout << "======Maximum Twist = " << $maxTwist << endl ;
    cout << "======Maximum ShearTwist = " << $maxShearTwist << endl ;
    cout << endl ;

    int quality = 3 ;
    if($volRatio > 10 || $maxCellAngle > 90 ||
       $maxTwist > 0.1 || $maxShearTwist > 0.1) 
      quality = 2 ;
    if($volRatio > 50 || $maxCellAngle > 150 ||
       $maxTwist > 0.2 || $maxShearTwist > 0.2)
      quality = 1 ;
    if($volRatio > 100 || $maxCellAngle > 170 ||
       $maxTwist > 0.45 || $maxShearTwist > 0.45)
      quality = 0 ;
    if($volRatio > 1000 || $maxCellAngle > 179 ||
       $maxTwist > 0.8 || $maxShearTwist > 0.8 || $minVol < 0 || $convexCell > 0 )
      quality = -1 ;
    
    string quality_report = "undetermined" ;
    switch(quality) {
    case 3:
      quality_report = "excellent" ;
      break ;
    case 2:
      quality_report = "good" ;
      break ;
    case 1:
      quality_report = "poor" ;
      break ;
    case 0:
      quality_report = "marginal" ;
      break ;
    case -1:
      quality_report = "UNUSABLE" ;
    }
    
    cout << "Overall Grid Quality Assesment: " << quality_report << endl ;
      
    string report_file = $modelName + ".quality" ;
    std::ofstream file(report_file.c_str(),std::ios::out) ;
    file << "minVol: "  << $minVol << endl ;
    file << "volRatio: " << $volRatio << endl ;
    file << "maxCellAngle: " << $maxCellAngle << endl ;
    file << "maxTwist: " << $maxTwist << endl ;
    file << "maxShearTwist: " << $maxShearTwist << endl ;
    file << "quality: " << quality << endl ;
    file << "quality_report: " << quality_report << endl ;
  }
  $report = true ;
}


class scalar_node_output : public apply_rule<param<int>, Loci::Maximum<int> > {
  std::string var_name ;
  std::string value_name ;
  Loci::const_store<float> c2n ;
  Loci::const_param<std::string> modelName ;
  Loci::param<int> topo ;
public:
  scalar_node_output(const char *vname, const char *valname) ;
  virtual void compute(const Loci::sequence &seq) ;
} ;

void dump_scalar(const sequence &seq,const_store<float> &c2n,
                 const_param<string> &modelName,
                 string type,
                 string sname) {
    
  ostringstream oss ;
  int cycle = 0;
    
  oss << "output/" << sname << "_" << type << "." << cycle
      << "_" << *modelName ;
  string filename = oss.str() ;

  if(Loci::MPI_rank == 0)
    Loci::debugout << "writing file " << filename << endl ;


  hid_t file_id = Loci::hdf5CreateFile(filename.c_str(),H5F_ACC_TRUNC,
                                       H5P_DEFAULT, H5P_DEFAULT) ;

  Loci::writeContainer(file_id,sname,c2n.Rep()) ;

  Loci::hdf5CloseFile(file_id) ;
}
  
scalar_node_output::scalar_node_output(const char *vname,
                                       const char *valname) {
  var_name = string(vname) ;
  value_name = string(valname) ;
  string var_name_time = var_name; 
  name_store(var_name_time, c2n) ;
  name_store("modelName",modelName) ;
  name_store("topo",topo) ;
    
  constraint("pos") ;
  input("modelName") ;
  input(var_name_time);
  output("topo") ;
}
void scalar_node_output::compute(const sequence &seq) {
  dump_scalar(seq,c2n, modelName,"sca",value_name) ;
}	



#define OUTPUT_SCALAR(X,Y) class OUT_##Y : public scalar_node_output {\
                           public:\
                           OUT_##Y() : scalar_node_output(X,#Y){}\
                           }; register_rule<OUT_##Y> register_OUT_##Y 

OUTPUT_SCALAR("cell2nodeMax(cellVolRatio)",volumeRatio) ;
OUTPUT_SCALAR("cell2nodeMax(cellFaceAngle)",cellFaceAngle) ;
OUTPUT_SCALAR("cell2nodeMax(cellTwist)",cellTwist) ;
OUTPUT_SCALAR("cell2nodeMax(cellShearTwist)",cellShearTwist) ;
OUTPUT_SCALAR("cell2nodeMin(volume)",cellVol) ;


$rule unit(minVol),constraint(geom_cells) {
  $minVol = 1e33 ;
}
$rule apply(minVol<-volume)[Loci::Minimum] {
  join($minVol,$volume) ;
}

$rule unit(maxTwist),constraint(geom_cells) {
  $maxTwist = 0 ;
}
$rule apply(maxTwist<-cellTwist)[Loci::Maximum] {
  join($maxTwist,$cellTwist) ;
}

$rule unit(maxShearTwist),constraint(geom_cells) {
  $maxShearTwist = 0 ;
}
$rule apply(maxShearTwist<-cellShearTwist)[Loci::Maximum] {
  join($maxShearTwist,$cellShearTwist) ;
}

// Test of new type of parametric rules
$type volTag_X store<double> ;
$type  volumeTag(X) param<string> ;

$type volumeComponent_X param<double> ;
$rule unit(volumeComponent_X),constraint(volumeTag(X)),
  parametric(volumeTag(X)) {
  $volumeComponent_X = 0 ;
}
$rule apply(volumeComponent_X<-volume)[Loci::Summation],constraint(volumeTag(X)),
  parametric(volumeTag(X)) {
  join($volumeComponent_X,$volume) ;
}

$type topo param<int> ;

$rule apply(topo<-volumeTag(X),volumeComponent_X)[Loci::Maximum],
  parametric(volumeTag(X)),option(disable_threading), prelude {

  if(Loci::MPI_rank == 0)
    cout << "Volume of component " << *$volumeTag(X) << " is " << *$volumeComponent_X << endl ;
} ;



$rule unit(convexCell),constraint(UNIVERSE) {
  $convexCell = 0 ;
}

$rule apply(convexCell<-cellcenter,(upper,lower,boundary_map)->(area,facecenter))[Loci::Summation] {
  bool convex = false ;
  vector3d<double> dv ;
  for(const Entity* nf=$upper.begin();nf!=$upper.end();++nf) {
    dv = nf->$facecenter - $cellcenter ;
    if(dot(dv,nf->$area.n) < 0)
      convex = true ;
  }
  for(const Entity* nf=$lower.begin();nf!=$lower.end();++nf) {
    dv = nf->$facecenter - $cellcenter ;
    if(dot(dv,nf->$area.n) > 0)
      convex = true ;
  }
  for(const Entity* nf=$boundary_map.begin();nf!=$boundary_map.end();++nf) {
    dv = nf->$facecenter - $cellcenter ;
    if(dot(dv,nf->$area.n) < 0)
      convex = true ;
  }
  if(convex)
    $convexCell++ ;
}

$rule apply(topo<-convexCell)[Loci::Maximum],
  option(disable_threading), prelude {

  if(Loci::MPI_rank == 0)
    if(*$convexCell > 0) {
      cerr << "WARNING: there are " << *$convexCell << " non-convex cells in the mesh." << endl ;
    } else {
      cout << "All cells in this mesh pass the convexity check!" << endl ;
    }
} ;

$type nonconvex store<double>  ;

$rule pointwise(nonconvex<-cellcenter,(upper,lower,boundary_map)->(area,facecenter)) {
  bool convex = true ;
  vector3d<double> dv ;
  for(const Entity* nf=$upper.begin();nf!=$upper.end();++nf) {
    dv = nf->$facecenter - $cellcenter ;
    if(dot(dv,nf->$area.n) < 0)
      convex = false ;
  }
  for(const Entity* nf=$lower.begin();nf!=$lower.end();++nf) {
    dv = nf->$facecenter - $cellcenter ;
    if(dot(dv,nf->$area.n) > 0)
      convex = false;
  }
  for(const Entity* nf=$boundary_map.begin();nf!=$boundary_map.end();++nf) {
    dv = nf->$facecenter - $cellcenter ;
    if(dot(dv,nf->$area.n) < 0)
      convex = false ;
  }
  $nonconvex = 0 ;
  if(!convex)
    $nonconvex = 1 ;
}

OUTPUT_SCALAR("cell2nodeMax(nonconvex)",nonconvex) ;

$type faceGeometryInconsistent param<int> ;

$rule unit(faceGeometryInconsistent),constraint(UNIVERSE) {
  $faceGeometryInconsistent = 0 ;
}

$rule apply(faceGeometryInconsistent<-(cl,cr)->cellcenter,area)[Loci::Summation]{
  if(dot($cr->$cellcenter-$cl->$cellcenter,$area.n)<0)
    $faceGeometryInconsistent++ ;
}

$rule apply(faceGeometryInconsistent<-ci->cellcenter,facecenter,area)[Loci::Summation] {
  if(dot($facecenter-$ci->$cellcenter,$area.n) < 0)
    $faceGeometryInconsistent++ ;
}

$rule apply(topo<-faceGeometryInconsistent)[Loci::Maximum],
  option(disable_threading), prelude {

  if(Loci::MPI_rank == 0)
    if(*$faceGeometryInconsistent > 0) {
      cerr << "WARNING: there are " << *$faceGeometryInconsistent << " faces with inconsistent geometry!" << endl ;
    }
} ;

