#include <Loci.h>
#include <iostream>
#include <map>
#include <string>
$include "FVM.lh"
using namespace Loci::kdTree;
using std::vector ;
using std::ifstream ;

using std::ios ;
using std::cerr ;
using std::endl ;
using std::cout ;
using std::pair;
using std::map;

typedef  Loci::vector3d<double> vect3d;
$type surfaceDeltas store<vect3d> ;
$type geomfile_par param<std::string>;


struct cubicBezierTriangle {
  vector3d<double> b300,b030,b003 ;
  vector3d<double> b210,b120,b021 ;
  vector3d<double> b012,b102,b201 ;
  vector3d<double> b111 ;
  vector3d<double> centroid() { return (1./3.)*(b300+b030+b003) ; }
  double radius() { 
    vector3d<double> c = centroid() ; 
    return max(max(norm(c-b300),norm(c-b030)),norm(c-b003)) ;
  } 
  void projectLinearUV(double &u, double &v, vector3d<double> P) const {
    // triangle normal vector
    vect3d n = cross(b030-b300,b003-b300) ;
    n *= 1./(norm(n)+1e-30) ;
    
    double a0 = dot(cross(b030-P,b003-P),n) ; // Compute projected areas
    double a1 = dot(cross(b003-P,b300-P),n) ;
    double a2 = dot(cross(b300-P,b030-P),n) ;
    if(a0 < 0) {
      // between b030 and b003 so u=0
      v = min(max(dot(P-b003,b030-b003)/
		  (dot(b030-b003,b030-b003)+1e-30),0.0),1.0) ;
      u = 0 ;
    } else if(a1 < 0) {
      // between b003 and b300 so v=0 
      u = min(max(dot(P-b003,b300-b003)/
		  (dot(b300-b003,b300-b003)+1e-30),0.0),1.0) ;
      v = 0 ;
    } else if(a2 < 0) {
      // between b300 and b030 so w=0
      u = min(max(dot(P-b030,b300-b030)/
		  (dot(b300-b030,b300-b030)+1e-30),0.0),1.0) ;
      v = 1.0-u ;
    } else {
      a0 = max(a0,0.0) ;
      a1 = max(a1,0.0) ;
      a2 = max(a2,0.0) ;
      double s = a0+a1+a2 ; // Scale barycentric coordinates to [0,1]
      u = a0/s ;
      v = a1/s ;
    }
  }
  vector3d<double> evaluateLinear(double u, double v) const {
    return u*b300+v*b030+(1.0-u-v)*b003 ;
  }
  vector3d<double> evaluateBezier(double u, double v) const {
    const double w = 1.0-u-v ;
    return (u*u*u*b300 + v*v*v*b030 + w*w*w*b003+ 
	    3.*(u*u*v*b210 + u*v*v*b120 + u*u*w*b201 +
		v*v*w*b021 + u*w*w*b102 + v*w*w*b012) +
	    6.*w*u*v*b111);
  }

} ;    
    
inline std::istream &operator>>(std::istream &s, cubicBezierTriangle &t) {
  s >> t.b300 >> t.b030 >> t.b003 >> t.b210 >> t.b120 >> t.b021 >> t.b012 >> t.b102 >> t.b201 >> t.b111 ;
  return s ;
}

inline std::ostream &operator<<(std::ostream &s, const cubicBezierTriangle &t) {
  s << t.b300 << t.b030 << t.b003 << t.b210 << t.b120 << t.b021 << t.b012 << t.b102 << t.b201 << t.b111 ;
  return s ;
}
class surfaceGeometry {
  int npnts ;
  vector<vector3d<double> > pos ;
  int nfaces ;
  vector<Array<int,3> > triNodes ;
  vector<cubicBezierTriangle> triGeom ;
  Loci::kdTree::kd_tree  *kdp ;
  vector<int> searchMap ;
  vector<int> offsetMap ;
public:
  surfaceGeometry() {
    kdp=0 ;
    npnts= -1 ;
    nfaces= -1 ;
  }
  ~surfaceGeometry() {
    if(kdp)
      delete kdp ;
  }
  bool readASCIIFile(string filename) ;
  void setupSearchMap() ;
  void broadcastGeometry(int root, MPI_Comm comm) ;
  vector3d<double> projectGeometryLinear(vector3d<double> pt, vector3d<double> &normal) const ;
  int getNumNodes() { return npnts ; }
  int getNumFaces() { return nfaces ; }

} ;
  

bool surfaceGeometry::readASCIIFile(string filename) {
  npnts = -1 ;
  nfaces = -1 ;
  ifstream infile(filename.c_str(),ios::in) ;
  if(infile.fail()) 
    return false ;
  infile >> npnts ;
  {  vector<vector3d<double> > lpos(npnts) ;
    for(int i=0;i<npnts;++i) {
      double x, y, z ;
      infile >> x >> y >> z ;
      if(infile.fail()) 
	return false ;
      lpos[i] = vector3d<double>(x,y,z) ;
    }
    pos.swap(lpos) ;
  }
  
  infile >> nfaces ;
  if(infile.fail()) {
    npnts = -1 ;
    nfaces = -1 ;
    return false ;
  }
  { vector<Array<int,3> > ltriNodes(nfaces) ;
    for(int i=0;i<nfaces;++i) {
      infile >> ltriNodes[i][0] >> ltriNodes[i][1] >> ltriNodes[i][2] ;
      if(infile.fail()) {
	npnts = -1 ;
	nfaces = -1 ;
	return false ;
      }
    }
    triNodes.swap(ltriNodes) ;
  }
  { vector<cubicBezierTriangle> ltriGeom(nfaces) ;
    for(int i=0;i<nfaces;++i) {
      infile >> ltriGeom[i] ;
      if(infile.fail()) {
	npnts = -1 ;
	nfaces = -1 ;
	return false ;
      }
    }
    triGeom.swap(ltriGeom) ;
  } 
  if(infile.fail())
    return false ;
  setupSearchMap() ;
  return true ;
}

void surfaceGeometry::setupSearchMap() {
  if(kdp)
    delete kdp ;
  vector<Loci::kdTree::coord3d> fpos(nfaces) ;
  vector<int> fid(nfaces) ;
  for(int i=0;i<nfaces;++i) {
    fpos[i] = triGeom[i].centroid() ;
    fid[i] = i ; ;
  }
  kdp = new Loci::kdTree::kd_tree(fpos,fid) ;
  vector<pair<int,int> > searchPairs ;
  for(int i=0;i<nfaces;++i) {
    Loci::kdTree::coord3d c = triGeom[i].centroid() ;
    double r = triGeom[i].radius() ;
    Loci::kdTree::kd_tree::bounds box ;
    double r2 = 2.05*r ;
    box.maxc[0] = c.x + r2 ;
    box.maxc[1] = c.y + r2 ;
    box.maxc[2] = c.z + r2 ;
    box.minc[0] = c.x - r2 ;
    box.minc[1] = c.y - r2 ;
    box.minc[2] = c.z - r2 ;
    // Find all of the points within a given bounding box
    std::vector< Loci::kdTree::kd_tree::coord_info> found_pts;
    kdp->find_box(found_pts,  box);
    
    for(unsigned int pi = 0; pi < found_pts.size(); pi++){
      vect3d p = vect3d(found_pts[pi].coords[0], found_pts[pi].coords[1], found_pts[pi].coords[2]);
      if(norm(p - c) <= r2){
	pair<int,int> e1(found_pts[pi].id,i) ;
	pair<int,int> e2(i,found_pts[pi].id) ;
	searchPairs.push_back(e1) ;
	searchPairs.push_back(e2) ;
      }
    }
    sort(searchPairs.begin(),searchPairs.end()) ;
    vector<pair<int,int> >::iterator ue = 
      unique(searchPairs.begin(),searchPairs.end()) ;
    int sz = ue-searchPairs.begin() ;

    vector<int> lsearchMap(sz) ;
    vector<int> sizes(nfaces,0) ;
    for(int i=0;i<sz;++i) {
      lsearchMap[i] = searchPairs[i].second ;
      sizes[searchPairs[i].first]++ ;
    }
    vector<int> loffsets(nfaces+1,0) ;
    for(int i=0;i<nfaces;++i)
      loffsets[i+1] = loffsets[i]+sizes[i] ;
    searchMap.swap(lsearchMap) ;
    offsetMap.swap(loffsets) ;
  }

}

void surfaceGeometry:: broadcastGeometry(int root, MPI_Comm comm) {
  MPI_Bcast(&npnts,1,MPI_INT,root,comm) ;
  MPI_Bcast(&nfaces,1,MPI_INT,root,comm) ;

  int r ;
  MPI_Comm_rank(comm,&r) ;
  if(r != root) {
    vector<vector3d<double> > lpos(npnts) ;
    pos.swap(lpos) ;
    vector<Array<int,3> > ltriNodes(nfaces) ;    
    triNodes.swap(ltriNodes) ;
    vector<cubicBezierTriangle> ltriGeom(nfaces) ;
    triGeom.swap(ltriGeom) ;
  }
  MPI_Bcast(&pos[0],npnts*3,MPI_DOUBLE,root,comm) ;
  MPI_Bcast(&triNodes[0],nfaces*3,MPI_INT,root,comm) ;
  MPI_Bcast(&triGeom[0],nfaces*30,MPI_DOUBLE,root,comm) ;
  if(r != root) {
    setupSearchMap() ;
  }
}

vector3d<double> surfaceGeometry::projectGeometryLinear(vector3d<double> pt, vector3d<double> &normal) const {
  Loci::kdTree::coord3d thePoint ;
  thePoint[0] = pt.x ;
  thePoint[1] = pt.y ;
  thePoint[2] = pt.z ;
  double rmin = std::numeric_limits<float>::max() ;
  int id = kdp->find_closest(thePoint,rmin) ;
  double dmin = 1e30 ;
  vect3d surface_pt(0,0,0) ;
  double surface_u=0,surface_v=0 ;
  int surface_t = -1 ;
  
  for(int i=offsetMap[id];i<offsetMap[id+1];++i) {
    int f = searchMap[i] ;
    double u,v ;
    triGeom[f].projectLinearUV(u,v,pt) ;
    vect3d sp = triGeom[f].evaluateLinear(u,v) ;
    double d = norm(sp-pt) ;
    if(d< dmin) {
      dmin = d ;
      surface_pt = triGeom[f].evaluateBezier(u,v) ;
      surface_t = f ;
      surface_u = u ;
      surface_v = v ;
    }
  }
  //  if(surface_t < 0) {
  //    cerr << "unable to find matching point!" << endl ;
  //  }
  return surface_pt ;
}


//this rule read in the geometry file, and compute the surfaceDelta of boundary nodes 
$rule pointwise(surfaceDeltas<-pos,geomfile_par ),constraint(boundary_nodes),
  option(disable_threading),
  prelude {

  surfaceGeometry geom ;
  if(Loci::MPI_rank==0) {
    if(!geom.readASCIIFile(*$geomfile_par)) {
      cerr << "problem reading " <<*$geomfile_par << endl ;
      Loci::Abort() ;
    }
    cout << "read in " << geom.getNumFaces() << " facets from geometry file '" << *$geomfile_par << "'" << endl ;
  }
  geom.broadcastGeometry(0,MPI_COMM_WORLD) ;
  entitySet dom = entitySet(seq) ;
  FORALL(dom,ii) {
    //find the closest point
    vect3d P = $pos[ii];
    vect3d n ;
    vect3d newP = geom.projectGeometryLinear(P, n) ;
    $surfaceDeltas[ii] = newP - P ;
  } ENDFORALL ;
} ;

