#include <Loci.h>
#include <iostream>
#include <map>
#include <string>
$include "FVM.lh"
using namespace Loci::kdTree;
using std::vector ;
using std::ifstream ;

using std::ios ;
using std::cerr ;
using std::endl ;
using std::cout ;
using std::pair;
using std::map;

typedef  Loci::vector3d<double> vect3d;
$type surfaceDeltas store<vect3d> ;
$type geomfile_par param<std::string>;



void get_uvw(const vect3d &T0, const vect3d &T1, const vect3d &T2,
             const vect3d &P,double &u, double &v, double &w) {
  // triangle normal vector
  vect3d n = cross(T1-T0,T2-T0) ;
  n *= 1./norm(n) ;
  double a0 = dot(cross(T1-P,T2-P),n) ; // Compute projected areas
  double a1 = dot(cross(T2-P,T0-P),n) ;
  double a2 = dot(cross(T0-P,T1-P),n) ;
  // bound areas to be positive (we are not allowed to go outside of triangle)
  a0 = max(a0,0.0) ;
  a1 = max(a1,0.0) ;
  a2 = max(a2,0.0) ;
  double s = a0+a1+a2 ; // Scale barycentric coordinates to [0,1]
  u = a0/s ;
  v = a1/s ;
  w = a2/s ;
}

vect3d project_pt(const vect3d &T0, const vect3d &T1, const vect3d &T2,
                  const vect3d &P) {
  double u,v,w ;
  get_uvw(T0,T1,T2,P,u,v,w) ;
  return T0*u+T1*v+T2*w ;
  
  //  double a2 = norm(cross(T0-P,T1-P)) ;
  //  double a1 = norm(cross(T0-P,T2-P)) ;
  //  double a0 = norm(cross(T1-P,T2-P)) ;
  //  return (1./(a0+a1+a2))*(a0*T0+a1*T1+a2*T2) ;
}

//this rule read in the geometry file, and compute the surfaceDelta of boundary nodes 
$rule pointwise(surfaceDeltas<-pos,geomfile_par ),constraint(boundary_nodes),
  option(disable_threading),
  prelude {
  vector<Loci::kdTree::coord3d> pntpos ;
  std::string fname = *($geomfile_par);
  ifstream infile;
 
  if(Loci::MPI_rank == 0) {
    infile.open(fname.c_str(),ios::in) ;
    if(infile.fail()) {
      cerr << "unable to open geom file " <<fname << endl ;
      Loci::Abort() ;
    }
    int num_pnts;
    infile >> num_pnts;
    { 
      vector<Loci::kdTree::coord3d> tmppos(num_pnts) ;
      pntpos.swap(tmppos) ;
    }
    for(int i= 0; i < num_pnts; i++){
      Loci::kdTree::coord3d coord ;
      infile >> coord[0] >> coord[1] >> coord[2]  ;
      pntpos[i] =coord ;
    }
    cout << "read " << pntpos.size() << " points from file "<< fname << endl ;
    
  }
  int sz = pntpos.size() ;
  MPI_Bcast(&sz,1,MPI_INT,0,MPI_COMM_WORLD) ;
  
  if(Loci::MPI_rank != 0) {
    vector<Loci::kdTree::coord3d> tmppos(sz) ;
    pntpos.swap(tmppos) ;
  }
  MPI_Bcast(&pntpos[0][0],sz*3,MPI_DOUBLE,0,MPI_COMM_WORLD) ;

  vector<int> pntid(sz) ;
  for(int i=0;i<sz;++i)
    pntid[i] = i ;

  Loci::kdTree::kd_tree search_tree(pntpos,pntid) ;

  //read in face2node
  int num_faces;
  if(Loci::MPI_rank == 0) {
    infile >> num_faces;
    cout << "num_faces: " << num_faces<< endl;
  }
  MPI_Bcast(&num_faces,1,MPI_INT,0,MPI_COMM_WORLD) ;
 
  int f2n_size = num_faces*3;
  vector<int> f2n(f2n_size) ;

  int coeff_size = num_faces*30;
  vector<double> coeff(coeff_size) ;

 
  if(Loci::MPI_rank == 0) {	
    for(int i = 0; i < f2n_size; i++) infile >> f2n[i];
    for(int i = 0; i < coeff_size; i++)  infile >> coeff[i];
  }
  
  MPI_Bcast(&f2n[0],f2n_size,MPI_INT,0,MPI_COMM_WORLD) ;
  MPI_Bcast(&coeff[0],coeff_size,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
  //finish reading from the file
  
  

 //for each triangle, search for all nodes that are in the containing sphere of  a triangle, using kd-tree

  entitySet faces = interval(sz, sz+num_faces-1);
  store<int> count;
  count.allocate(faces);
  multiMap tri2node;

  vector<int> vcount(num_faces) ;
  vector<vector<int> > nodeID(num_faces) ;
  
  for(int i = 0; i < num_faces; i++){
    vect3d P[3];
    Loci::kdTree::coord3d coord ;
    coord[0] =  pntpos[f2n[3*i]][0];
    coord[1] =  pntpos[f2n[3*i]][1];
    coord[2] =  pntpos[f2n[3*i]][2];
    P[0] = vect3d(coord[0], coord[1], coord[2]);

    coord[0] =  pntpos[f2n[3*i+1]][0];
    coord[1] =  pntpos[f2n[3*i+1]][1];
    coord[2] =  pntpos[f2n[3*i+1]][2];
    P[1] = vect3d(coord[0], coord[1], coord[2]);

    coord[0] =  pntpos[f2n[3*i+2]][0];
    coord[1] =  pntpos[f2n[3*i+2]][1];
    coord[2] =  pntpos[f2n[3*i+2]][2];
    P[2] = vect3d(coord[0], coord[1], coord[2]);

    double el[3]; //edge length
    el[0] =norm(P[0] - P[1]);
    el[1] = norm(P[1] - P[2]);
    el[2] = norm(P[2] - P[0]);

    double maxEl = el[0];
    int edgeId = 0;
    for (int e = 1; e < 3; e++){
      if(el[e] > maxEl){
        maxEl = el[e];
        edgeId = e;
      }
    }

    maxEl *= 1.05; // allow computational error
    //    maxEl *= 1.5; // allow computational error
    //    maxEl += 1000 ;
    //    maxEl += 2 ;
    
    vect3d center = P[edgeId];
    kd_tree::bounds box;
    box.maxc[0] = center.x + maxEl;
    box.maxc[1] = center.y + maxEl;
    box.maxc[2] = center.z + maxEl;
    
    box.minc[0] = center.x - maxEl;
    box.minc[1] = center.y - maxEl;
    box.minc[2] = center.z - maxEl;
    
    
    // Find all of the points within a given bounding box
    std::vector< kd_tree::coord_info> found_pts;
    search_tree.find_box(found_pts,  box);
    
    vcount[i] = 0;
    
    for(unsigned int pi = 0; pi < found_pts.size(); pi++){
      vect3d p = vect3d(found_pts[pi].coords[0], found_pts[pi].coords[1], found_pts[pi].coords[2]);
      if(norm(p - center) <= maxEl){
        vcount[i]++;
        nodeID[i].push_back(found_pts[pi].id);
      }
    }
  }//finish processing triangles

  //create maps
  int index = 0;
  for(entitySet::const_iterator ei = faces.begin(); ei != faces.end(); ei++){
    count[*ei] = vcount[index++];
  }

  tri2node.allocate(count);
  int index1=0;
  for(entitySet::const_iterator ei = faces.begin(); ei != faces.end(); ei++){
    int index2 = 0;
    for(int i = 0; i < count[*ei]; i++){
      tri2node[*ei][i] = nodeID[index1][index2++];
    }
    index1++;
  }

  //inverseMap
  entitySet nodes = interval(0, sz-1);
  multiMap node2tri;
  inverseMap(node2tri, tri2node, nodes, faces);
  
  entitySet dom = entitySet(seq) ;
  FORALL(dom,ii) {
    //find the closest point
    vect3d P = $pos[ii];
    Loci::kdTree::coord3d thePoint ;
    thePoint[0] = P.x ;
    thePoint[1] = P.y ;
    thePoint[2] = P.z ;
    double rmin = std::numeric_limits<float>::max() ;
    int id = search_tree.find_closest(thePoint,rmin) ;

    //if it's one of the baseline boundary, don't move it 
   //  if(rmin < 1e-10) {
//       $surfaceDeltas[ii] = vect3d(0.0, 0.0, 0.0);
//       continue;
//     }

    
//    find which triangle the point is in;

    double dist_min = 1e30 ;
    int face_min = -1 ;


    //    cout << "num_search = " << node2tri.num_elems(Entity(id)) << endl ;
    for( int i = 0; i <node2tri.num_elems(Entity(id)); i++){
      //for each face, find P1, P2, P3
      vect3d T0, T1, T2 ; 
      int index =(node2tri[Entity(id)][i]-sz)*30;
      T0.x = coeff[index++];
      T0.y = coeff[index++];
      T0.z = coeff[index++];
      
      T1.x = coeff[index++];
      T1.y = coeff[index++];
      T1.z = coeff[index++];
      
      T2.x = coeff[index++];
      T2.y = coeff[index++];
      T2.z = coeff[index++];


      vect3d PP = project_pt(T0,T1,T2,P) ;
      
      vect3d dv = PP-P ;
      double dist = dot(dv,dv) ;
      if(dist < dist_min) {
        dist_min = dist ;
        face_min = node2tri[Entity(id)][i] - sz;
      }
    }
    //    cout << "dist_min = " << sqrt(dist_min) << "rmin = " << sqrt(rmin) << endl << endl ;

    if(face_min == -1) {
      cerr << "matching face not found in geometry look-up" << endl ;
      Loci::Abort() ;
    }

    
    //compute new pos
    int index = face_min*30 ;
    vect3d b;
    b.x =  coeff[index++];
    b.y =  coeff[index++];
    b.z =  coeff[index++];
    vect3d b300 = b;
    
    b.x =  coeff[index++];
    b.y =  coeff[index++];
    b.z =  coeff[index++];
    vect3d b030 = b;
    
    b.x =  coeff[index++];
    b.y =  coeff[index++];
    b.z =  coeff[index++];
    vect3d b003 = b;

    double u,v,w ;
    get_uvw(b300,b030,b003,P,w,u,v) ;


    b.x =  coeff[index++];
    b.y =  coeff[index++];
    b.z =  coeff[index++];
    vect3d b210 = b;
    
    b.x =  coeff[index++];
    b.y =  coeff[index++];
    b.z =  coeff[index++];
    vect3d b120 = b;
    
    b.x =  coeff[index++];
    b.y =  coeff[index++];
    b.z =  coeff[index++];
    vect3d b021 = b;
    
    
    b.x =  coeff[index++];
    b.y =  coeff[index++];
    b.z =  coeff[index++];
    vect3d b012 = b;
    
    b.x =  coeff[index++];
    b.y =  coeff[index++];
    b.z =  coeff[index++];
    vect3d b102 = b;
    
    b.x =  coeff[index++];
    b.y =  coeff[index++];
    b.z =  coeff[index++];
    vect3d b201 = b;
    
    b.x =  coeff[index++];
    b.y =  coeff[index++];
    b.z =  coeff[index++];
    vect3d b111 = b;

   
    vect3d new_pos = (w*w*w)*b300 + (u*u*u)*b030 + (v*v*v)*b003+ 
          (3.0*w*w*u)*b210 + (3.0*w*u*u)*b120 + (3.0*w*w*v)*b201 +
          (3.0*u*u*v)*b021 + (3.0*w*v*v)*b102 + (3.0*u*v*v)*b012 +
          (6.0*w*u*v)*b111;

    $surfaceDeltas[ii] = new_pos - $pos[ii];

   
    
  } ENDFORALL ;  	
} ;

