#include <Loci.h>
using namespace std ;
$include "FVM.lh"
$include "heat.lh"

// Compute when we want to make plot files
$type doPlot param<bool> ;

$rule singleton(doPlot<-$n,plot_freq) {
  $doPlot = (($$n % $plot_freq) == 0) ;
}


// OUTPUT is a special Loci variable.  Loci will compute rules that result
// in OUTPUT if it can, even though this wasn't explcitly needed to satisfy
// the query.  The conditional statement will cause this rule to be
// conditionally executed only when doPlot is true.  The constraint(pos)
// makes sure that we output for all nodes of the mesh.  The argument
// option(disable_threading) tells Loci that we are doing special computations
// that may be sensitive to computation order, so don't do fancy optimizations
// on this rule, just make one call and evaluate all entities at one time.
$rule pointwise(OUTPUT<-cell2node(temperature),$n,plot_modulo),
  constraint(pos),conditional(doPlot), option(disable_threading),
  prelude {
  int iter = *$$n % *$plot_modulo ;
  ostringstream oss ;
  string varname = "temperature" ;
  oss << "output/" << varname << "_hdf5." << iter ;
  string filename = oss.str() ;

  if(Loci::MPI_rank == 0)
    cout << "writing file " << filename << endl ;

  // Create an hdf5 file
  hid_t file_id = Loci::hdf5CreateFile(filename.c_str(),H5F_ACC_TRUNC,
                                       H5P_DEFAULT,H5P_DEFAULT) ;

  // Write the values of the nodal temperatures into the file
  Loci::writeContainer(file_id,varname,$cell2node(temperature).Rep()) ;

  // Close the hdf5 file
  Loci::hdf5CloseFile(file_id) ;
} ;

// Here we check the MPI_rank so that we only output from processor
// zero, otherwise the message would be printed p times from each
// processor
$rule singleton(OUTPUT<-L2Norm(qresidual,geom_cells),$n),
  option(disable_threading) {
  if(Loci::MPI_rank==0) {
    cout << "R" << $$n << ": " << $L2Norm(qresidual,geom_cells) << endl ;
  }
}

