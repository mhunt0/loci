\appendix
\chapter { Makefile Example}
\label{chap:makefile}
\include{Makefile_ex}

% \chapter { Basic Classes}

% \section { EntitySet Class }
% \begin{verbatim}

% class EntitySet 
% {
% public:
%   void  friend  Union( const interval &);
%   void  friend  Union( const entitySet &e);
%   static friend Union( const entitySet &set1, const entitySet &set2);

%   // Returns true if the integer value is present.
%   bool  inSet( int_type indx ) const;

%   // Returns the number of intervals.
%   int   num_itervals() const;

%   // A.Equal(B)
%   // Returns true if both A and B point to the entitySet 
%   //
%   bool  Equal( const entitySet &p);

%   // Provides a canonical ordering for entitySet objects so that
%   // they can be used as keys to associate containers such as STL map<>

%   bool  less_than( const entitySet &p);

%   // Provides a canonical ordering for entitySet objects so that they
%   // can be used as keys to associate containers such as STL map<> 

%    bool  greater_than( const entitySet &p);

%   //  A.min() returns the minimum value of the integer identifiers in 
%   //  the entitySet A.
%   int   Min() const;

%   //  A.max() returns the maximum value of the integer identifiers in 
%   //  the entitySet A.

%   int   Max() const;
%   void  Complement();

%   inline ostream &operator << ( ostream &s, const entitySet &e);
%   inline istream &operator << ( istream &s, entitySet &e);

%   inline &operator += ( entitySet &e, int_type val);
% inline &operator |= ( entitySet &e1, const entitySet &e2);
% inline &operator &= ( entitySet &e, const interval &in);
% inline &operator ^  ( const entitySet &e1, const entitySet &e2);
% }
% \end{verbatim}


% \section { Store Class }

% \begin{verbatim}

% template <class T>
% class store
% {
% public:
%    // After declaring a store the next step is to allocate memory.
%    // Member function allocate() allocates memory for all entities
%    // in the specified entitySet.
%    void        allocate(const entitySet &p);

%    // Returns the domain of the store. It is nothing but the entitySet
%    // over which the store is defined.
%    entitySet   domain() const;
   
%    // The operator [] is used to access the elements associated with 
%    // a store. 
%    T       &operator[](int indx);
% }

% \end{verbatim}

% \section { storeVec $\&$ storeMat }
% \begin{verbatim}
% template <class T>
% class store
% {
% public:

%  // Specify the size of the vector.
%   void setVecSize( int size );

%  // Returns the size of the vector associated with each entity
%   int vecSize() const;

%   inline &operator []( int_type val);

%   inline ostream &operator << ( ostream &s, const store &e);
%   inline istream &operator << ( istream &s, store &e);

%   inline &operator  = ( entitySet &e, int_type val);
%   inline &operator += ( entitySet &e, int_type val);
%   inline &operator -= ( entitySet &e, int_type val);
%   inline &operator *= ( entitySet &e1, const entitySet &e2);
%   inline &operator /= ( entitySet &e1, const entitySet &e2);
% }
% \end{verbatim}

% \section { Parameter }

% \begin{verbatim}


% \end{verbatim}

% \section { Maps }

% \begin{verbatim}

% class Map : public store_instance
% {
% public:
%     Map();

% }

% class multiMap : public store_instance
% {
% public:
%     multiMap();

% }


% \end{verbatim}


