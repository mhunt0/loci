\section { 1D Finite Volume Calculation}
Consider a 1D linear diffusion given by
\begin{equation}
u_t = \nu u_{xx}, \hspace{5mm}
\end{equation}
with initial and boundary conditions given by
\begin{eqnarray}
u(x,0) = f(x)    \\
u_x(0,t) = g(t)  \\
u_x(1,t) = h(t)
\end{eqnarray}

\begin{figure}[h]
\special{psfile=heat.eps vscale=50 hscale=50 voffset=-100 hoffset=1}
\vspace*{1.60in}\caption {Problem Specification of 1D Diffusion }
\end{figure}

\subsection{ What you will learn from this example }
\begin{itemize}
\item  How they entities and relationship are identified.
\item  This program make use of stationary and time promotion rules,
       which are automatically generated by Loci, but you should
       know about them.
\end{itemize}
      

\subsection{A Finite Volume Solution}

The first step in numerically approximating the function $u(x,t)$ is
the discretization of the spatial domain (in this case the interval
$[0,1]$).  For this example, the finite volume discretization method
is chosen.\footnote{Other discretization schemes follow similar lines.
  See Appendix \ref{app:numerical} for alternative discretization
  examples.} Using this discretization approach, the interval $[0,1]$
is divided into $N$ sub-intervals, as illustrated in figure
\ref{fig3:oned}.  To facilitate describing the discretization process,
the $N$ sub-intervals, or cells, are labeled by $c = N+1, \cdots, 2N$,
while the interfaces at the boundaries of sub-intervals are labeled $i
= 0, \cdots, N$.  Note that the typical labeling used for theoretical
purposes would include half step labels for the interfaces, while a
typical unstructured application code might label both cells and
interfaces starting from zero and use context to distinguish between
the two cases.  However, for the purposes of automating reasoning
about these entities of computations it is assumed that these labels
are integers and that independent computational sites (in this case,
cells and interfaces) are labeled distinctly.  The proposed labeling
satisfies both of these constraints.

%\begin{figure}[htbp]
% \centerline{
%  \epsfxsize=5.50in
%  \epsfbox{one-d.eps}}
% \caption{A Discretization of the Interval $[0,1]$}
% \label{fig3:oned}
%\end{figure}

As illustrated in figure \ref{fig3:oned}, the discretization yields
$N+1$ interfaces which have the positions given by
\begin{equation}
x = \lbrace (i,x_i) | i \in [0, \cdots, N], x_i = i/N \rbrace.
\label{eq3:interfacex}
\end{equation}
Notice that the variable $x$ in this equation is described by a set of
ordered pairs where the first entry is the entity identifier, whereas
the second entry is the value bound to that entity.  This is a more
general abstraction of the array.  For example {\tt x[i]} is
represented abstractly as $\lbrace x_i | (i,x_i) \in x \rbrace$.

In addition, this discretization yields $N$ intervals, or cells, which
are represented by the mappings between cells and interfaces by way of
the following relationships
\begin{equation}
\begin{array}{rcl}
il & = & \lbrace (c,l) | c \in [N+1, \cdots, 2N], l = c-N-1 \rbrace,\\
ir & = & \lbrace (c,r) | c \in [N+1, \cdots, 2N], r = c-N \rbrace.\\
\end{array}
\label{eq3:cellmaps}
\end{equation}
The mappings $il$ and $ir$ provide mappings from every cell to their
left and right interfaces.  The domain of $ir$ and $il$ is $[N+1,
\cdots, 2N]$, or the cells in the discretization, while the ranges are
$\mathrm{ran}(ir) = [0, \cdots, N-1]$ and $\mathrm{ran}(il) = [1, \cdots, N]$.  This
mapping is used to conveniently describe subscripts, {\it i.e.}
$x_{c-N} = ir \rightarrow x$, where the composition operator,
$\rightarrow$, defines the application of the mapping, as in
\begin{equation}
il\rightarrow x = \lbrace (c,x_l) | (c,l) \in il, (l,x_l) \in x \rbrace.
\end{equation}
Using this notation, it is possible to conveniently describe cell
based calculations.  For example, a generic description of each cell
center is given by
\begin{equation}
\label{eq3:cellcenter}
x = (ir \rightarrow x + il \rightarrow x)/2.
\end{equation}
Note that the definition of $x$ provided by equation
(\ref{eq3:cellcenter}) is only applicable to cells since only cells are in
the domain of maps $ir$ and $il$; however, this does not prevent the
definition of $x$ for other entities (for example, interfaces) via
other rules.

The mappings $il$ and $ir$ are used to describe the first
step of the finite volume discretization, where integration of
equation (\ref{eq3:diffuse}) over each cell produces the equation
\begin{equation}
\int_{t_n}^{t_{n+1}} \int_{il \rightarrow x}^{ir \rightarrow x} u_t dx
dt = \int_{t_n}^{t_{n+1}} \nu(ir \rightarrow u_x - il \rightarrow
u_x) dt.
\label{eq3:diffinteg}
\end{equation}

Equation (\ref{eq3:diffinteg}) is an exact equation, which can be
integrated numerically to obtain a numerical solution algorithm.
For example, a first order end-point rule is applied to the time
integrations while a second order mid-point rule is applied to the space
integrations to obtain a finite-volume numerical method, expressed as
\begin{equation}
u^{n+1} = u^n + \nu \Delta t
\left[ \frac{ir \rightarrow u^n_x - il \rightarrow u^n_x}
          {ir\rightarrow x - il\rightarrow x}\right]
\label{eq3:timeadvance}
\end{equation}

Equation (\ref{eq3:timeadvance}) describes the numerical method for
advancing the time step, but it is not complete.  The gradient term,
$u^n_x$, located at the interfaces has not been defined as a numerical
approximation.  The most straightforward approximation for $u_x$ is a
central difference formula using the values at the cell centers at
either side of the interface.  In order to perform this calculation it
will be convenient to have a mapping from interfaces to cells similar to
the development of $il$ and $ir$.  These mappings are defined by
the relations
\begin{equation}
\begin{array}{rcl}
cl & = & \lbrace (i,l) | i \in [1, \cdots, N], l = i+N \rbrace,\\
cr & = & \lbrace (i,r) | i \in [0, \cdots, N-1], r = i+N+1 \rbrace.\\
\end{array}
\label{eq3:facemaps}
\end{equation}

Using the definitions of $cl$ and $cr$ of (\ref{eq3:facemaps}), a
numerical approximation to the gradient can be given as
\begin{equation}
u_x^n = \frac{cr\rightarrow u^n - cl\rightarrow u^n}
           {cr\rightarrow x - cl\rightarrow x}.
\label{eq3:ux}
\end{equation}
Notice that this equation uses the x-coordinate at the cell centers
that is computed by equation (\ref{eq3:cellcenter}).  In addition,
since this rule uses both maps $cr$ and $cl$, it only defines $u_x$ on
the intersection of the domains of $cr$ and $cl$, given by $[1, \cdots,
N-1]$.  By this reasoning, equation (\ref{eq3:ux}) only provides
gradients at the internal faces of the domain.  The gradient at the
boundary faces is provided by the boundary conditions given in
equations (\ref{eq3:diffuseb0}) and (\ref{eq3:diffuseb1}).  The
question is, how do these boundary conditions specify $u_x$ at the
boundaries without specifying $u_x$ everywhere in the domain?
Obviously additional information must be provided that constrains
the application of boundary condition gradients only to the boundary
interfaces.  A solution to this problem can be found with the
observation that the boundary interfaces have the distinction that
either $cl$ is defined or $cr$ is defined, but not both.  Using this
fact, the rules for calculating the boundary gradients can be given by
\begin{eqnarray}
u_x^n & = g(n \Delta t), \mbox{constraint}\lbrace \neg \mathrm{dom}(cl) \wedge
\mathrm{dom}(cr) \rbrace, \label{eq3:brule0}\\
u_x^n & = h(n \Delta t), \mbox{constraint}\lbrace \mathrm{dom}(cl)
\wedge \neg \mathrm{dom}(cr) \rbrace.\label{eq3:brule1}
\end{eqnarray}
Here the constraint term added to the rule indicates a constraint on
the application of the rule.  In this case it constrains the
application of the boundary conditions to the appropriate boundary faces.

At this point, the computation of $u^{n+1}$ from $u^n$ is completely
specified.  However, before any such iteration can begin, an initial
value, or $u^{n=0}$, must be given.  To be consistent with the finite
volume formulation, the derivation of the initial conditions begins
with the integral form of equation (\ref{eq3:diffuseinitial}), given by
\begin{equation}
\int^{ir\rightarrow x}_{il\rightarrow x} u^{n=0} dx =
\int^{ir\rightarrow x}_{il\rightarrow x} f(x) dx.
\end{equation}
Using a midpoint rule to numerically integrate this equation one
obtains the rule
\begin{equation}
u^{n=0} = f(x), \mbox{constraint}\lbrace (il,ir)\rightarrow x\rbrace.
\label{eq3:ic}
\end{equation}
For this rule, the constraint is used to indicate that although the
coordinates of the interfaces cancel in the derivation, their
existence is predicated by the integration.  In other words, the
derivation assumed a cell perspective that includes left and right
interface positions.

\subsection{On Problem Specification}

For an analytic solution method, equations (\ref{eq3:diffuse}) through
(\ref{eq3:diffuseb1}) are sufficient to define the problem at hand.
For numerical solution methods, additional definitions are required,
due to the fact that these are inexact methods.  For example, there
are often tradeoffs between discretization and accuracy that require
additional specification.  In addition, since discretization for
complex geometries (grid generation) is not a completely automatic
process, the discretization becomes part of the problem definition for
numerical solution methods.  For the example diffusion problem already
introduced, the definition of the numerical problem consists of
spatially independent information such as the diffusion constant
$\nu$, the initial condition function $f(x)$, the numerical time step
$\Delta t$, and a representation of the discretization of space.  The
discretization of space is given by a set of positions,
(\ref{eq3:interfacex}), and the collection of mappings given in
(\ref{eq3:cellmaps}) and (\ref{eq3:facemaps}).  Table
\ref{table3:facts} summarizes these formal definitions for the example
diffusion problem.


\begin{table}[htbp]
\caption{ A Summary of Definitions for the Example Diffusion
  Problem}
\label{table3:facts}
\begin{center}
  \begin{tabular}{|l|l|}
    \hline
    fact      & meaning \\
    \hline
    $\nu$     & given diffusion constant  \\
    $f(x)$     & given initial condition  \\
    $g(t)$     & given left bc \\
    $h(t)$     & given right bc  \\
    $\Delta t$& given time-step  \\
    $x$       & $\lbrace (i,x_i) | i \in [0, \cdots, N], x_i = i/N    \rbrace$\\
    $il$      & $\lbrace (c,l)   | c \in [N+1, \cdots, 2N], l = c-N-1 \rbrace$\\
    $ir$      & $\lbrace (c,r)   | c \in [N+1, \cdots, 2N], r = c-N   \rbrace$\\
    $cl$      & $\lbrace (i,l)   | i \in [1, \cdots, N], l = i+N      \rbrace$\\
    $cr$      & $\lbrace (i,r)   | i \in [0, \cdots, N-1], r = i+N+1  \rbrace$\\
    \hline
  \end{tabular}
\end{center}
\end{table}

\subsection{On Specification of Process}

Given the definition of the problem, the process of solving the
problem is dictated by a prescribed set of transformations.  For
example, consider equation (\ref{eq3:cellcenter}) as an example of a
transformation that transforms $x$ located at $il$ and $ir$ into a
cell $x$.  To simplify discussions of the structure of the
calculations, the transformation rules are represented by a rule
signature that is denoted by a list of targets of the transformation
delineated from the sources of the transformation by the left arrow
symbol, '$\leftarrow$'.  Thus the cell center position calculation is
represented by the rule signature $x \leftarrow (ir,il)\rightarrow x$.
This rule signature represents the augmentation of the set of ordered
pairs defined in equation (\ref{eq3:interfacex}) with the additional
set given as
\begin{equation}
x\leftarrow\lbrace (c, x_c) |  x_c = (x_l + x_r)/2,
                               (l,x_l) \in x, (r,x_r) \in x, 
                               (c,l) \in il, (c,r) \in ir \rbrace.
\end{equation}
For the moment, the augmentation of $x$ with this set can be
considered as a set union operation, with the caveat that it will
become more complex once issues of specification consistency are
considered.  Given this notation, the specification of the finite
volume scheme derived in this section can be summarized by six rules
given in table \ref{table3:rules}.

\begin{table}[htbp]
\caption{ A Summary of Rules Describing the Solution of the Example
    Diffusion Problem.}
\label{table3:rules}
\begin{center}
  \begin{tabular}{|l|l|l|}
    \hline
    Rule  & Rule Signature & Equation\\
    \hline
    Rule 1 & $x \leftarrow (ir,il)\rightarrow x $ &
    (\ref{eq3:cellcenter})\\
    Rule 2 & $u^{n+1} \leftarrow u^n,(ir,il)\rightarrow(u_x^n,x)$ &
    (\ref{eq3:timeadvance})\\
    Rule 3 & $u_x^n \leftarrow (cr,cl)\rightarrow(u^n,x)$ &
    (\ref{eq3:ux})\\
    Rule 4 & $u_x^n \leftarrow  g, n, \Delta t, \mbox{constraint}\lbrace 
    \neg \mathrm{dom}(cl) \wedge \mathrm{dom}(cr) \rbrace$&
    (\ref{eq3:brule0})\\
    Rule 5 & $u_x^n \leftarrow  h, n, \Delta t, \mbox{constraint}\lbrace 
    \mathrm{dom}(cl) \wedge \neg \mathrm{dom}(cr) \rbrace$ &
    (\ref{eq3:brule1})\\
    Rule 6 & $u^{n=0} \leftarrow f,x,\mbox{constraint}\lbrace(il,ir)\rightarrow
    x\rbrace $ &
    (\ref{eq3:ic})\\
    \hline
  \end{tabular}
\end{center}
\end{table}

\subsection{Implementing the  Problem Specification}

How does one translate the definition of the problem given in table
\ref{table3:facts} and the specification of the solution method given
in table \ref{table3:rules} into an implementation that can solve for
$u^n, n=0,1, \cdots$?  One accomplishes this implementation by
starting from what is known and using the rules of table
\ref{table3:rules} to incrementally derive the specified goal.  As in
Prolog\cite{Clocksin.87}\cite{Sterling.86}, rule resolution, a
generalization of modus ponens, is used to produce these incremental
derivations.  In other words, rules are applied where their sources
are satisfied.  The set of entities that satisfy a rules sources is
the context of the rule.  For example, Rule 1 from table
\ref{table3:rules} can be resolved with the definitions of $il$, $ir$,
and $x$ given in table \ref{table3:facts} for the entities numbered
$N+1, \cdots, 2N$.  Similarly, once Rule 1 is resolved, Rule 6 can be
resolved using the values of $x$ generated by Rule 1.  Iteration is
recovered by way of induction.  For example, if a rule generates
$u^{n=0}$ while another rule generates $u^{n+1}$, then these two rules
can be used to iteratively generate $u^n$ for $n=0,1, \cdots$.  Thus
by resolving the rules that provide the interface and boundary
gradients $u_x^n$ a complete schedule as shown in table
\ref{table3:schedule} can be derived from the given specification.

\begin{table}[htbp]
\caption{ A Deduced Execution Schedule for the Example
  Diffusion Problem}
\begin{center}
  \begin{tabular}{|l|l|l|l|}
    \hline
    Rule Used & variable computed  & context          & comment \\
    \hline
    Rule 1 & compute $x_c$         & $c=N+1, \cdots, 2N$ & cell centers\\
    Rule 6 & compute $u^{n=0}_c$   & $c=N+1, \cdots, 2N$ & initial conditions \\
    Loop   &                       & define $n=0$     & for $n=0,\cdots$ \\
    Rule 4 & compute $(u_x)^n_i$   & $i=0$       & left boundary condition\\
    Rule 5 & compute $(u_x)^n_i$   & $i=N$       & right boundary condition\\
    Rule 3 & compute $(u_x)^n_i$   & $i=1..N-1$  & diffusion flux at time $n$\\
    Rule 2 & compute $u^{n+1}_i$   & $i=0..N$    & advance time-step\\
    End Loop &                     & loop to Rule 4 & replace $n=n+1$, repeat\\
    \hline
  \end{tabular}
\end{center}
\label{table3:schedule}
\end{table}

\subsection { Implementation }

\begin{verbatim}
1  #include <Loci.h>
2  #include <iostream>
3
4  using namespace std ;
5
6  int main()
7  {
8    const int N = 50 ; // Number of points in grid.
9
10    //-----------------------------------------------------------------
11    // Create a 1-d unstructured grid ; Node and Cells are identified
12    // separately.
13    //-----------------------------------------------------------------
14    entitySet nodes  = interval(0,N) ;
15    entitySet cells  = interval(N+1,2*N);
16
17    //-----------------------------------------------------------------
18    // Generate 1D grid positions at the nodes.
19    //-----------------------------------------------------------------
20    store<float> x;
21    x.allocate(nodes);
22
23    entitySet::const_iterator ei ; // Generic iterator
24
25    for(ei=nodes.begin();ei!=nodes.end();++ei)
26      x[*ei] = float(*ei)/float(N);
27    //-----------------------------------------------------------------
28    // Create mapping from interface to cells
29    // cl = cell left , cr = cell right
30    //-----------------------------------------------------------------
31
32    Map cl,cr ;
33    cl.allocate(nodes-interval(0,0)) ; // do not allocate for leftmost interface
34    cr.allocate(nodes-interval(N,N)) ; // do not allocate for rightmost interface
35
36    // Assign maps from nodes to cells
37    // cl = {(i,l) | i \in [1,N], l = i+N}
38    // cr = {(i,r) | i \in [0,N-1], r = i+N+1}
39    for(ei=cl.domain().begin();ei!=cl.domain().end();++ei)
40      cl[*ei] = *ei + N;
41    for(ei=cr.domain().begin();ei!=cr.domain().end();++ei)
42      cr[*ei] = *ei + N + 1;
43
44    //-----------------------------------------------------------------
45    // Create mapping from cells to interface
46    // il = interface left, ir = interface right
47    // il = {(c,l) | c \in cells, l = c-N-1},
48    // ir = {(c,r) | c \in cells, l = c-N}
49    //-----------------------------------------------------------------
50    Map il,ir ;
51    il.allocate(cells) ;
52    ir.allocate(cells) ;
53
54    for(ei=cells.begin();ei!=cells.end();++ei) {
55      il[*ei] = *ei - N - 1 ;
56      ir[*ei] = *ei - N ;
57    }
58
59    //-----------------------------------------------------------------
60    // Create Facts Database
61    //-----------------------------------------------------------------
62    fact_db facts ;
63
64    facts.create_fact("il",il) ;
65    facts.create_fact("ir",ir) ;
66    facts.create_fact("x", x) ;
67    facts.create_fact("cl",cl) ;
68    facts.create_fact("cr",cr);
69
70    // Diffusion constant
71    param<float> nu ;
72    *nu = 1.0 ;
73    facts.create_fact("nu",nu) ;
74
75    // Number of iterations to run simulation
76    param<int> max_iteration ;
77    *max_iteration = 100 ;
78    facts.create_fact("max_iteration",max_iteration) ;
79
80    // Minimum L1 norm for convergence test
81    param<double> error_tolerance;
82    *error_tolerance = 1.0E-03;
83    facts.create_fact( "error_tolerance", error_tolerance);
84
85    // Identify boundary conditions
86    constraint left_boundary ;
87    constraint right_boundary ;
88    *right_boundary = cl.domain() - cr.domain() ;
89    *left_boundary = cr.domain() - cl.domain() ;
90
91    facts.create_fact("left_boundary",left_boundary) ;
92    facts.create_fact("right_boundary",right_boundary) ;
93
94    //-----------------------------------------------------------------
95    // Create Rule database ...
96    //-----------------------------------------------------------------
97
98    rule_db rdb ;
99    rdb.add_rules(global_rule_list) ;
100
101    //-----------------------------------------------------------------
102    // Create and execute the schedule to  obtains the solution
103    //-----------------------------------------------------------------
104    executeP schedule = create_execution_schedule(rdb,facts,"solution") ;
105
106    //schedule->Print(cout) ;                   // Display schedule
107
108    schedule->execute(facts) ;           // Execute the schedule
109
110    //-----------------------------------------------------------------
111    // Final Step: Query the database for solution:
112    //-----------------------------------------------------------------
113
114    store<float> usol ;
115    usol = facts.get_variable("solution") ;
116
117    cout << "The solution is : " <<endl;
118    for(ei=cells.begin();ei!=cells.end();++ei)
119      cout << ""<< *ei<<" "<<usol[*ei]<<endl ;
120
121    //-----------------------------------------------------------------
122    // End of computations::
123    //-----------------------------------------------------------------
124
125    return(0);
126
127  }
128  //*******************************************************************
\end{verbatim}

\begin{verbatim}
1  class cell_center : public pointwise_rule {
2    const_store<float> x ;
3    const_Map il,ir ;
4    store<float> xc ;
5  public:
6    cell_center() {
7      name_store("x",x) ;
8      name_store("il",il) ;
9      name_store("ir",ir) ;
10      name_store("xc",xc) ;
11      input("(il,ir)->x") ;
12      output("xc") ;         // xc <- (il,ir)->x
13    }
14    void calculate(Entity e) {
15      xc[e] = 0.5*(x[il[e]]+x[ir[e]]);
16    }
17  
18    virtual void compute(const sequence &seq) {
19      do_loop(seq,this,&cell_center::calculate) ;
20    }
21  } ;
22  
23  register_rule<cell_center> register_cell_center ;
24  
25
//*******************************************************************
\end{verbatim}

\begin{verbatim}
1  //*******************************************************************
2  //Initializing values at time= 0 using u(x,0) = f(x). Since "xc" is
3  //used, it will calculate the values are cell-centers.
4  //*******************************************************************
5
6  float f(float x) {
7    return 0 ;
8  }
9
10  class initial_condition : public pointwise_rule {
11    const_store<float> xc ;
12    store<float> u ;
13  public:
14    initial_condition() {
15      name_store("xc",xc) ;
16      name_store("u{n=0}",u) ;
17      input("xc") ;
18      output("u{n=0}") ; // u{n=0}<-xc
19    }
20    void calculate(Entity e) {
21      u[e] = f(xc[e]) ;
22    }
23
24    virtual void compute(const sequence &seq) {
25      do_loop(seq,this,&initial_condition::calculate) ;
26    }
27  } ;
28
29  register_rule<initial_condition> register_initial_condition ;
\end{verbatim}

\begin{verbatim}
1  //*******************************************************************
2  // Compute boundary condition at leftmost interface. At left we are
3  // imposing Neumann Boundary Condition.
4  //*******************************************************************
5
6  class left_bc : public pointwise_rule {
7    store<float> ux ;
8  public:
9    left_bc() {
10      name_store("ux",ux) ;
11      constraint("left_boundary") ;
12      output("ux") ;
13    }
14    void calculate(Entity e) {
15      ux[e] = -1 ;
16    }
17
18    virtual void compute(const sequence &seq) {
19      do_loop(seq,this,&left_bc::calculate) ;
20    }
21  } ;
22
23  register_rule<left_bc> register_left_bc ;
24
25  //*******************************************************************
26  // Compute boundary condition at rightmost interface. At right we are
27  // imposing Neumann Boundary Condition.
28  //*******************************************************************
29
30  class right_bc : public pointwise_rule {
31    const_store<float> u,xc,x ;
32    const_Map cl ;
33    store<float> ux ;
34  public:
35    right_bc() {
36      name_store("u",u) ;
37      name_store("cl",cl) ;
38      name_store("x",x) ;
39      name_store("xc",xc) ;
40      name_store("ux",ux) ;
41      input("x,cl->(u,xc)") ;
42      output("ux") ;
43      constraint("right_boundary") ;
44    }
45    void calculate(Entity e) {
46      ux[e] = (u[cl[e]])/(xc[cl[e]]-x[e]) ;
47    }
48
49    virtual void compute(const sequence &seq) {
50      do_loop(seq,this,&right_bc::calculate) ;
51    }
52  } ;
53
54  register_rule<right_bc> register_right_bc ;
55
56  //*******************************************************************
\end{verbatim}

\begin{verbatim}
1     class interface_gradient : public pointwise_rule {
2    const_store<float> u ;
3    const_Map cl,cr ;
4    const_store<float> xc ;
5    store<float> ux ;
6  public:
7    interface_gradient() {
8      name_store("u",u) ;
9      name_store("cl",cl) ;
10      name_store("cr",cr) ;
11      name_store("xc",xc) ;
12      name_store("ux",ux) ;
13      input("(cl,cr)->(u,xc)") ;
14      output("ux") ; 
15    }
16    void calculate(Entity e) {
17      ux[e] = (u[cl[e]]-u[cr[e]])/(xc[cl[e]]-xc[cr[e]]) ;
18    }
19  
20    virtual void compute(const sequence &seq) {
21      do_loop(seq,this,&interface_gradient::calculate) ;
22    }
23  } ;
24  
25  register_rule<interface_gradient> register_interface_gradient ;
\end{verbatim}

\begin{verbatim}
1  //*******************************************************************
2  // Compute maximum stable timestep for simulation.  Use reduction rule
3  // and calculate timestep as a function of local conditions.  The global
4  // timestep is the minimum of these local timesteps
5  //*******************************************************************
6
7  class timestep_unit : public unit_rule {
8    param<float> dt ;
9  public:
10    timestep_unit() {
11      name_store("dt",dt) ;
12      output("dt") ;
13      constraint("UNIVERSE") ;  // This property applies to all entities
14    }
15    virtual void compute(const sequence &seq) {
16      *dt = 1e30 ;              // Largest allowable timestep
17    }
18  } ;
19
20  register_rule<timestep_unit> register_timestep_unit ;
21
22  //*******************************************************************
23
24  class timestep_apply : public apply_rule<param<float>,
25                         Loci::Minimum<float> > {
26    const_store<float> xc ;
27    const_Map cl,cr ;
28    const_param<float> nu ;
29    param<float> dt ;
30  public:
31    timestep_apply() {
32      name_store("xc",xc) ;
33      name_store("cl",cl) ;
34      name_store("cr",cr) ;
35      name_store("nu",nu) ;
36      name_store("dt",dt) ;
37      input("dt,(cl,cr)->xc,nu") ;
38      output("dt") ;
39    }
40    void calculate(Entity e) {
41      float dx = abs(xc[cr[e]]-xc[cl[e]]) ;
42      // Compute timestep as 1/2 of maximum stable timestep
43      float local_dt = dx*dx*nu[e]/4. ;
44
45      join(dt[e],local_dt) ; // Set dt = min(dt,local_dt)
46    }
47
48    virtual void compute(const sequence &seq) {
49      do_loop(seq,this,&timestep_apply::calculate) ;
50    }
51
52  } ;
53
54  register_rule<timestep_apply> register_timestep_apply ;
55
56  //*******************************************************************
\end{verbatim}

\begin{verbatim}

1  //-------------------------------------------------------------------
2  // Objective :  Compute u{n+1} based on explicit euler time integration method
3  //-------------------------------------------------------------------
4
5  class advance_time : public pointwise_rule {
6    const_store<float> x,ux,un ;
7    const_Map il,ir ;
8    const_param<float> dt,nu ;
9    store<float> unp1 ;
10  public:
11    advance_time() {
12      name_store("x{n}",x) ;
13      name_store("ux{n}",ux) ;
14      name_store("u{n}",un) ;
15      name_store("il{n}",il) ;
16      name_store("ir{n}",ir) ;
17      name_store("nu{n}",nu) ;
18      name_store("dt{n}",dt) ;
19      name_store("u{n+1}",unp1) ;
20      input("u{n},nu{n},dt{n},(ir{n},il{n})->(ux{n},x{n})") ;
21      output("u{n+1}") ;
22
23      constraint("(il{n},ir{n})->x{n}") ; // Assert update for all valid cells
24    }
25
26    void calculate(Entity e) {
27      unp1[e] = un[e] + nu[e]*dt[e]*(ux[ir[e]]-ux[il[e]])/(x[ir[e]]-x[il[e]]) ;
28    }
29
30    virtual void compute(const sequence &seq) {
31      do_loop(seq,this,&advance_time::calculate) ;
32    }
33  } ;
34
35  register_rule<advance_time> register_advance_time ;
36
37  //*******************************************************************
\end{verbatim}
\begin{verbatim}

1  //*******************************************************************
2  // When simulation is finished, copy current iteration results to
3  // solution
4  //*******************************************************************
5
6  class collapse_time : public pointwise_rule {
7    const_store<float> u ;
8    store<float> solution ;
9  public:
10    collapse_time() {
11      name_store("u{n}",u) ;
12      name_store("solution",solution) ;
13      input("u{n}") ;
14      output("solution") ;
15      conditional("simulation_finished{n}") ;
16    }
17    void calculate(Entity e) {
18      solution[e] = u[e] ;
19    }
20
21    virtual void compute(const sequence &seq) {
22      do_loop(seq,this,&collapse_time::calculate) ;
23    }
24  } ;
25
26  register_rule<collapse_time> register_collapse_time ;
27
28  //*******************************************************************
29  // Condition that determines when iteration is complete
30  //*******************************************************************
31
32  class collapse_condition : public singleton_rule {
33    const_param<int> n, max_iteration ;
34    param<bool> simulation_finished ;
35  public:
36    collapse_condition() {
37      name_store("$n",n) ;
38      name_store("max_iteration",max_iteration) ;
39      name_store("simulation_finished",simulation_finished) ;
40      input("$n,max_iteration") ;
41      output("simulation_finished") ;
42    }
43    virtual void compute(const sequence &seq) {
44      *simulation_finished = (*n >= *max_iteration) ;
45    }
46  } ;
47
48  register_rule<collapse_condition> register_collapse_condition ;
49
50  //*******************************************************************
~
\end{verbatim}
