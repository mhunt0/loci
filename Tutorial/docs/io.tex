\chapter {Input Output}
Loci used HDF5 (Hierarchical Data Format)  to read-write data from its 
containers. All the containers of Loci has the following member virtual functions
%
\begin{itemize} 
\item virtual void readhdf5( hid\_t group, entitySet \&  eset);
\item virtual void writehdf5( hid\_t group, entitySet \& eset) const ;
\end{itemize}
%
{\em group\_id} is the valid HDF5 group in which data is written. {\em eset} is
the entitySet for which data is written. One simple example of
creating a group is given below
%
\begin{verbatim} 
hid_t file_id  = H5Fopen(filename, H5F_ACC_RDONLY, H5P_DEFAULT);
hid_t group_id = H5Gopen(file_id, groupname.c_str() );
\end{verbatim} 

\section {Rules for writing facts}
The following conventions are adopted for writing containers in files
All files written in HDF5 ends with .hdf5
All the facts are written in a single file, but in different groups.
\subsection {Distributed facts}
\begin{enumerate}
\item they are written in {\em filename\_p0.hdf5}, {\em filename\_p1.hdf5}, \dots
\item they use local numbering.
\item local to global numbering is provided in each file and this
mapping is shared by all facts in the fact database.
\item each process is responsible for writing only its own data, and
no clone data is written.
\item if there is only process, facts are written with global numbering.
\end{enumerate}

\subsection {Undistributed facts}

\begin{enumerate}
\item they are written in {\em filename\_p0.hdf5}
\item facts are written with global numbering.
\end{enumerate}
\section {Rules for reading data from files}

\begin{enumerate}
\item A processor can read any number of files in round-robin fashion. 
\item If the facts are distributed then the objects move to their
correct location after reading the file. 
\item If the number of processes is only one, facts are stored with
global numbering
\end{enumerate}

\section {Reading and Writing facts}
\par Reading and writing facts in Loci is very simple. 
\begin{itemize}
\item  Specify the appropriate Loci datatype 
(if they are not already defined in Loci framework).
\item  Specify Loci container (i.e. store, storeVec ...etc)
\item  Create the facts using the member function
\begin{verbatim}
   fact_db  facts;
   facts.create_fact(factname, container); 
\end{verbatim}
\item  Write the facts database in file using (.hdf5 will be appended
to the file)
\begin{verbatim}
   facts.write_hdf5( fact_database_filename ); 
\end{verbatim}
\item  Read the facts database from file using (.hdf5 will be appended
to the file)
\begin{verbatim}
   facts.read_hdf5( fact_database_filename ); 
\end{verbatim}
\item Using h5dump tool to see the contains of the file
\end{itemize}
%
\par Now we shall give three examples for writing facts
\begin{itemize}
\item  In the first example, we shall write facts with atomic datatype, which
are predefined in Loci. Using these datatype doesn't require anything extra 
from the user.
\item In the second example, we will write compound datatype, in which user
specify {\em Identity Converters} and insert them into Loci datatype. Once the
new datatype is build, using is as simple as example one.
\item In the third example, we will write class which uses {\em user defined conversion}
\end{itemize}
\section { Writing atomic datatype }
In the following example, we shall use {\em store} container and fill it with
some data. We will demonstrate how the facts database is called to write the
contains of the container in HDF5 data format.
\begin{verbatim}
  #include <Loci.h>
  using namespace std;
 
  store<int>      data;   // Container with integer datatype
  entitySet       eset;   // EntitySet
  fact_db         facts;  // facts database

  //*******************************************************************
  // Create a fact, fill it with some data and register it with facts
  // database
  //*******************************************************************
  void GenerateData()
  {
    int num = 10;
    eset = interval(1,num);

    data.allocate(eset);
    for( int j = 1; j <= num; j++) {
      data[j] =   100+j;
    }

    facts.create_fact("store",data) ;
  }
  //*******************************************************************

  int main(int argc, char *argv[])
  {
    GenerateData();
    facts.write_hdf5( "example");
  }
  //*******************************************************************
\end{verbatim}
The execution of the above program will produce {\em example\_p0.hdf5} file. 
\begin{verbatim}
 HDF5 "example_p0.hdf5" {
 GROUP "/" {
   GROUP "store" {
      DATASET "Interval Set" {
         DATATYPE { H5T_STD_I32BE }
         DATASPACE { SIMPLE ( 2 ) / ( 2 ) }
         DATA {
            1, 10
         }
      }
      DATASET "VariableData" {
         DATATYPE { H5T_STD_I32BE }
         DATASPACE { SIMPLE ( 10 ) / ( 10 ) }
         DATA {
            101, 102, 103, 104, 105, 106, 107, 108, 109, 110
         }
      }
   }
}
}
\end{verbatim}
\par Notice the output, HDF5 write all necessary information about the container. EntitySet is 
written under the {\em Interval Set} dataset and the data is written under {\em VariableData}
dataset. Each datatype and dataspace is also specified in the file. {\bf H5T\_STD\_I32BE} tells
us that data was 32 bit, and big-endian integer data.
%
\section { Writing Compound datatype}
Creating datatypes which contains another compound datatypes is fairly
simple. Just define each datatype individually and add these types in 
the parent datatype.

\begin{verbatim}
 #include <Loci.h>
 using namespace std;

 namespace Loci {
   struct Velocity {
     Array<double,3>  comp;
   };

   struct CellAttrib {
     int      local_id;
     double   density;
     double   pressure;
     Velocity vel;
   };

   template <>
   struct data_schema_traits<Velocity> {
     typedef IDENTITY_CONVERTER Schema_Converter ;
     static DatatypeP get_type() {
       return DatatypeP(comp);
     }
   };

   template <>
   struct data_schema_traits<CellAttrib> {
     typedef IDENTITY_CONVERTER Schema_Converter ;
     static DatatypeP get_type() {
       CompoundDatatypeP  cmpd = CompoundFactory( CellAttrib() );
       LOCI_INSERT_TYPE(cmpd, CellAttrib, local_id );
       LOCI_INSERT_TYPE(cmpd, CellAttrib, density  );
       LOCI_INSERT_TYPE(cmpd, CellAttrib, pressure );
       LOCI_INSERT_TYPE(cmpd, CellAttrib, vel );
       return DatatypeP(cmpd);
     }
   };


 }
 //*******************************************************************
 store<Loci::CellAttrib>  data;   // Container
 entitySet                eset;   // EntitySet
 fact_db                  facts;  // facts database

 //*******************************************************************
 // Create the facts and register with facts database
 //*******************************************************************

 void GenerateData()
 {
   int num = 2;
   eset = interval(1,num);

   data.allocate(eset);
   for( int j = 1; j <= num; j++) {
     data[j].local_id  =   j;
     data[j].density   =   0.25*j;
     data[j].pressure  =   1.25*j;
     data[j].vel.comp[0]  =   1.05*j;
     data[j].vel.comp[1]  =   2.05*j;
     data[j].vel.comp[2]  =   3.05*j;
   }
   facts.create_fact("store",data) ;
 }
 //*******************************************************************
 int main(int argc, char *argv[])
 {
   GenerateData();
   facts.write_hdf5( "example");
 }
 //*******************************************************************
\end{verbatim}
\begin{verbatim}
  HDF5 "example_p0.hdf5" {
  GROUP "/" {
    GROUP "store" {
       DATASET "Interval Set" {
          DATATYPE { H5T_STD_I32BE }
          DATASPACE { SIMPLE ( 2 ) / ( 2 ) }
          DATA {
             1, 2
          }
       }
       DATASET "VariableData" {
          DATATYPE {
             H5T_STD_I32BE "local_id";
             H5T_IEEE_F64BE "density";
             H5T_IEEE_F64BE "pressure";
             {
                H5T_IEEE_F64BE "Array"[3];
             } "velocity";
          }
          DATASPACE { SIMPLE ( 2 ) / ( 2 ) }
          DATA {
             {
                1,
                0.25,
                1.25,
                {
                   [ 1.05, 2.05, 3.05 ]
                }
             },
             {
                2,
                0.5,
                2.5,
                {
                   [ 2.1, 4.1, 6.1 ]
                }
             }
          }
       }
    }
 }
 }
\end{verbatim}

\section { Writing containers with user defined datatype}
All attribute containers have to store information from which state of an user defined
datatype should be reconstructed. Two different cases arises with user defined datatype
An user defined container may contain objects of varying size and shapes. All these
information must be stored in the file for later retrieval. 

\par All user defined datatypes requires
\begin{enumerate}
\item  input and output stream overloaded functions.
\item  Specialized template {\em data\_schema\_traits} class
\item  A class which can pack and unpack data of an object
\end{enumerate}

\begin{verbatim}
   #include <Loci.h>
   using namespace std;
 
   namespace Loci {
     struct My_Type {
      list<int>  alist;
      friend ostream& operator << (ostream &, const My_Type &);
      friend istream& operator >> (istream &, My_Type &);
    };

    //*******************************************************************
    inline std::ostream& operator << ( std::ostream &s, const My_Type &obj)
  {
    list<int> :: const_iterator ci;
    list<int> :: const_iterator begin = obj.alist.begin();
    list<int> :: const_iterator end   = obj.alist.end();
    for( ci = begin; ci != end; ++ci)
      s << *ci <<" ";
    return s;
  }
    //*******************************************************************
    inline std::istream& operator >> ( std::istream &s, My_Type &obj)
  {
    obj.alist.clear();
    int newval;
    s >> newval;
    obj.alist.push_back( newval );
    return s;
  }
  //*******************************************************************
  class My_Type_SchemaConverter;

  template <>
  struct data_schema_traits<My_Type> {
    typedef USER_DEFINED_CONVERTER Schema_Converter ;

    typedef int Converter_Base_Type ;
    typedef My_Type_SchemaConverter Converter_Type ;
  };

  class My_Type_SchemaConverter {
    // For the schema converter, we always store a reference to the object
    // we are converting schmata for.
    My_Type &RefObj ;
  public:
    explicit My_Type_SchemaConverter(My_Type &new_obj): RefObj(new_obj) {}
    int getSize() const {
      return RefObj.alist.size() ;
    }
    void getState(int *buf, int &size) {
      size = getSize() ;
      int ii=0;

      list<int> :: const_iterator ci;
      list<int> :: const_iterator begin = RefObj.alist.begin();
      list<int> :: const_iterator end   = RefObj.alist.end();
      for(ci = begin; ci != end; ++ci)  {
        buf[ii++] = *ci;
      }
    }
    void setState(int *buf, int size) {
      RefObj.alist.clear();
      list<int> :: iterator ci;
      for(int i=0;i<size;++i)
        RefObj.alist.push_back(buf[i]);
    }
  };
  }


  store<Loci::My_Type>   data;   // Container
  entitySet              eset;   // EntitySet
  fact_db                facts;  // facts database

  void GenerateData()
  {
    int num = 2;
    eset = interval(1,num);

    data.allocate(eset);
    int indx = 1;
    for( int j = 0; j < 3; j++) {
      data[1].alist.push_back(indx);
      indx++;
    }

    indx = 1;
    for( int j = 0; j < 5; j++) {
      data[2].alist.push_back(indx+100);
      indx++;
    }

    facts.create_fact("store",data) ;
 }
    
 //*******************************************************************
 int main(int argc, char *argv[])
 {
   GenerateData();
   facts.write_hdf5( "example");
 }
 //*******************************************************************
\end{verbatim}
\begin{verbatim}
HDF5 "example_p0.hdf5" {
GROUP "/" {
   GROUP "store" {
      DATASET "ContainerSize" {
         DATATYPE  H5T_STD_I32BE  
         DATASPACE  SIMPLE { ( 2 ) / ( 2 ) } 
         DATA {
            3, 5
         } 
      } 
      DATASET "Interval Set" {
         DATATYPE  H5T_STD_I32BE  
         DATASPACE  SIMPLE { ( 2 ) / ( 2 ) } 
         DATA {
            1, 2
         } 
      } 
      DATASET "VariableData" {
         DATATYPE  H5T_STD_I32BE  
         DATASPACE  SIMPLE { ( 8 ) / ( 8 ) } 
         DATA {
            1, 2, 3, 101, 102, 103, 104, 105
         } 
      } 
   } 
} 
} 
\end{verbatim}
\section {Distributed facts }
\begin{verbatim} 
      #include <Loci.h>
      using namespace std;
    
      int                 my_rank, numprocs;  // MPI information
      storeVec<int>       data;               // Container
      entitySet           eset;               // EntitySet
      fact_db             facts;              // facts database
    
    
      void GenerateData()
      {
        int num = 10;
        eset = interval(1,num);
        data.setVecSize(2);
    
        data.allocate(eset);
        for(int i = 1; i < num+1; i++) {
            data[i][0] = 10*i;
            data[i][1] = 100*i;
        }
        facts.create_fact("storeVec",data) ;
      }
    
      int main(int argc, char *argv[])
      {
        Loci::Init(&argc, &argv) ;
        GenerateData();
    
        std::vector<entitySet> partition(Loci::MPI_processes) ;
        partition = Loci::generate_distribution(facts, rdb, Loci::MPI_processes) ;
        Loci::distribute_facts(partition, facts, rdb) ;

        facts.write_hdf5( "example");
    
        Loci::Finalize();
      }
\end{verbatim} 
Execute the above program with 2 processors and the output will be written in {\em example\_p0,hdf5},
and {\em example\_p1.hdf5}
\begin{verbatim} 
     1  HDF5 "example_p1.hdf5" {
     2  GROUP "/" {
     3     GROUP "ProcessorID" {
     4        DATASET "Processor" {
     5           DATATYPE { H5T_STD_I32BE }
     6           DATASPACE { SIMPLE ( 2 ) / ( 2 ) }
     7           DATA {
     8              1, 2
     9           }
    10        }
    11     }
    12     GROUP "l2g" {
    13        DATASET "Interval Set" {
    14           DATATYPE { H5T_STD_I32BE }
    15           DATASPACE { SIMPLE ( 2 ) / ( 2 ) }
    16           DATA {
    17              0, 4
    18           }
    19        }
    20        DATASET "Map" {
    21           DATATYPE { H5T_STD_I32BE }
    22           DATASPACE { SIMPLE ( 5 ) / ( 5 ) }
    23           DATA {
    24              1, 2, 6, 9, 10
    25           }
    26        }
    27     }
    28     GROUP "storeVec" {
    29        DATASET "Interval Set" {
    30           DATATYPE { H5T_STD_I32BE }
    31           DATASPACE { SIMPLE ( 2 ) / ( 2 ) }
    32           DATA {
    33              0, 4
    34           }
    35        }
    36        DATASET "VariableData" {
    37           DATATYPE { H5T_STD_I32BE }
    38           DATASPACE { SIMPLE ( 10 ) / ( 10 ) }
    39           DATA {
    40              10, 100, 20, 200, 60, 600, 90, 900, 100, 1000
    41           }
    42        }
    43        DATASET "VecSize" {
    44           DATATYPE { H5T_STD_I32BE }
    45           DATASPACE { SIMPLE ( 1 ) / ( 1 ) }
    46           DATA {
    47              2
    48           }
    49        }
    50     }
    51  }
    52  }
\end{verbatim} 

\par In the above example line 3-11, {\em ProcessorID} group provides 
information about distribution. Line 6 says that number of entries in
this group is two, Line 8 specifies that this data was written on
process ID 1, and the maximum number of process on which
the simulation was carried out was 2. \\

\par In line 12-19, information about local to global numbering is
provided which is owned by process id 1 {specified by {em ProcessorID}
group} Line 17 says that there are 5 local entities with {0,1, ...4} ids. 

\par Line 20-27 provides mapping from local to global entitySet. The
mapping in one-to-one and for this example as follows.

\begin{center}
\begin{tabular}[h]{|c|c|} \hline
Local numbering & Global numbering \\ \hline
0   &  1         \\
1   &  2         \\
2   &  6         \\
3   &  9         \\
4   &  10        \\ \hline
\end{tabular}
\end{center}

\par Line 28-51 actually write the attribute data. In this example, in
the group {\em storeVec}
we write the storeVec container data. Any {\em Loci} datatypes could
be used to write data in
the in this group. (Refer to Loci Datatypes for more details )

\begin{center}
\begin{tabular}[h]{|c|c|} \hline
Local numbering & storeVec container Data \\ \hline
0   &  (10,100)         \\
1   &  (20,200)         \\
2   &  (60,600)         \\
3   &  (90,900)         \\
4   &  (100,1000)      \\ \hline
\end{tabular}
\end{center}

\par Line 43-49 group specifies that the size of storeVec
container. Line 47 inform that the size is 2

