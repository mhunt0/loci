\section { Laplace Smoothing }
Laplacian Smoothing is a common technique for smoothing the noisy signal.
Its formula is given as 
\begin{equation}
\phi^s = { 1 \over n} { \sum_{i=1}^{i=n} } \alpha_i \phi_i^n
\end{equation}

Where $\alpha_i$ is the weight associated to $\phi_i$. For simple case it can be taken
as unity.

\begin{figure}[h]
\special{psfile=lap.eps vscale=40 hscale=40 voffset=-215 hoffset=50}
\vspace{2.96in}\caption { Laplacian Smoothing over internal nodes }
\end{figure}

For simplicity we take square domain  consisting of the points $(x_i, y_i)$ given by
\begin{eqnarray}
x_i =  i / (n+1), i = 0, \dots n+1  \\
y_i =  j / (n+1), j = 0, \dots n+1  \\
\end{eqnarray}

where there are $n+2$ points along each edge of the mesh. We can approximate the 
operator at each of these points with the formula
\begin{equation}
{u_{i-1,j} + u_{i,j+1} + u_{i,j-1} + u_{i+1,j} - 4 u_{i,j}} = 0
\end{equation}

Since the formula involves $u$ at five points, we must find some wait to solve
for $u$ everywhere,. One approach is to rewrite above equation as 

\begin{equation}
u_{i,j} = {1 \over 4}(u_{i-1,j} + u_{i,j+1} + u_{i,j-1} + u_{i+1,j})
\end{equation}

iterate by choosing values for all mesh points $u_{i,j}$ and then replace them by
using

\begin{equation}
u_{i,j}^{k+1} = {1 \over 4}(u_{i-1,j}^k + u_{i,j+1}^k + u_{i,j-1}^k + u_{i+1,j}^k)
\end{equation}

\subsection { What you will learn from this example }
At the end of this examples, you should be able to know the following.
\begin{enumerate}
\item How to read facts from the file.
\item How to use mapVec.
\item How to write operation that works on only subsets.
\item How to use priority rules.
\end{enumerate}

\subsection { How to identify internal nodes }

In order to clarify the use of entitySets, we would like to apply smoothing
only on the internal nodes. There are many ways we can make use of entitySet
in this example, we will explain only two.  

\begin{enumerate}
\item  The first ways is very simple, we can create one entitySet of 
{\em mapVec$<4>$} and store the four neighbors for all internal nodes. This
map could be supplied to the rule.
\item The second way is more elegant, we will create four maps 
\begin{itemize}
\item {\bf eastmap} :  All Entities which have east as their neighbor. Only the
rightmost boundary entities will not be included in this map.
\item {\bf westmap} :  All Entities which have west as their neighbor. Only the
leftmost boundary entities will not be included in this map.
\item {\bf northmap}:  All Entities which have north as their neighbor. Only the
uppermost boundary entities will not be included in this map.
\item {\bf southmap}:  All Entities which have north as their neighbor. Only the
lowermost boundary entities will not be included in this map.
\end{itemize}
\par Using the second approach, an internal entity is identified as an entity
which have all four neighbors. 
\end{enumerate}
               
\subsection { Using C/C++ }
\begin{verbatim}
1  int main()
2  {
3
4    double     noisyData[100], smooth[100], noise[100];
5    int        xnodes, ynodes;
6    int        i,j, n1, n2, n3, n4, iter;
7    ofstream   outfile("noise.dat", ios::out);
8
9    outfile << xnodes << " " << ynodes << endl;
10    for( i = 0; i < xnodes*ynodes; i++) {
11      noisyData[i]  = drand48();
12      outfile << noisyData[i] << endl;
13    }
14
15    for( i = 0; i < xnodes*ynodes; i++) {
16      noise[i]  = noisyData[i];
17      smooth[i] = noisyData[i];
18    }
19
20    int  offset, numIters = 100;
21    for( iter = 0; iter < numIters; iter++) {
22      cout << iter << endl;
23      for( j = 1; j < ynodes-1; j++) {
24        for( i = 1; i < xnodes-1; i++) {
25          offset         = j*xnodes + i;
26          n1             = offset-1;      // Left
27          n2             = offset+1;      // Right
28          n3             = offset+xnodes; // Top
29          n4             = offset-xnodes; // Bottom
30          smooth[offset] = 0.25*(noise[n1]+noise[n2]+noise[n3]+noise[n4]);
31        }
32      }
33      for( i = 0; i < xnodes*ynodes; i++)
34        noise[i] = smooth[i];
35    }
36
37    cout.setf( ios::fixed);
38    cout << " Original Noisy Data " << endl;
39    for( j = 0; j < ynodes; j++) {
40      for( i = 0; i < xnodes; i++)
41        cout << noisyData[j*xnodes+i] << " ";
42      cout << endl;
43
44    }
45
46    cout << " Smooth Data " << endl;
47    for( j = 0; j < ynodes; j++) {
48        for( i = 0; i < xnodes; i++)
49          cout << smooth[j*xnodes+i] << " ";
50        cout << endl;
51    }
52
53  }
54
55  //*********************************************************************
\end{verbatim}


\subsection{ Using Loci : Method 1}
\subsubsection { Creating Facts }
\begin{verbatim}
1  int main(int argc, char *argv[])
2  {
3
4    //-------------------------------------------------------------------
5    // Step 1: Specify queries ...
6    //-------------------------------------------------------------------
7
8    string query = "smooth" ;
9
10    //-------------------------------------------------------------------
11    // Step 2: Create fact database
12    //-------------------------------------------------------------------
13
14    fact_db     facts ;                 // Facts Database
15    param<int>     max_iterations;
16    *max_iterations = 100;
17
18    facts.create_fact( "max_iterations", max_iterations);
19
20    //-------------------------------------------------------------------
21    // Create entities. In this example, all the internal nodes are our
22    // entities where calculation will be performed i.e. where Laplacian
23    // operator will be applied. For this example, we are creating data
24    // statically, but can be modified to read through a file.
25    //-------------------------------------------------------------------
26
27    int  xnodes, ynodes;
28
29    ifstream infile("noise.dat", ios::in);
30    if( infile.fail()) {
31        cout << "Error: Cann't open file " << endl;
32        exit(0);
33    }
34
35    infile >> xnodes >> ynodes;
36
37    int    i,j;
38    entitySet internalNodes;
39    for( j = 1; j < ynodes-1; j++) {
40      for( i = 1; i < xnodes-1; i++) {
41        internalNodes += j*xnodes + i;
42      }
43    }
44
45    store<double> noisyData;
46    entitySet     nodes = interval(0,xnodes*ynodes-1);
47    noisyData.allocate(nodes);
48
49    for( i = 0; i < xnodes*ynodes; i++)
50        infile >> noisyData[i];
51    infile.close();
52
53    facts.create_fact( "noisyData",noisyData);
54
55    //-------------------------------------------------------------------
56    // In 2D structured grid, all internal nodes have four neighbors.
57    //-------------------------------------------------------------------
58
59    MapVec<4>      neighConnect;
60    neighConnect.allocate(internalNodes);
61
62    size_t offset;
63    for( j = 1; j < ynodes-1; j++) {
64      for( i = 1; i < xnodes-1; i++) {
65        offset                   = j*xnodes + i;
66        neighConnect[offset][0]  = offset-1;      // Left
67        neighConnect[offset][1]  = offset+1;      // Right
68        neighConnect[offset][2]  = offset+xnodes; // Top
69        neighConnect[offset][3]  = offset-xnodes; // Bottom
70      }
71    }
72    facts.create_fact( "neighConnect", neighConnect);
73
74
75
76    //-------------------------------------------------------------------
77    // Step 3: Create Rules and register then into Rule database
78    //-------------------------------------------------------------------
79    rule_db    rdb ;                  // Rule Database
80
81    rdb.add_rules(global_rule_list) ;
82
83    //-------------------------------------------------------------------
84    // Step 4: Create and Execute the Schedule
85    //-------------------------------------------------------------------
86
87    facts.write(cout) ;
88
89    executeP schedule = create_execution_schedule(rdb,facts,query ) ;
90
91    if(schedule != 0) {
92      cout << "schedule = " << endl ;
93      schedule->Print(cout) ;
94      schedule->execute(facts) ;
95    }
96
97    //-------------------------------------------------------------------
98    // Step 5: Execution Over, Query the database
99    //-------------------------------------------------------------------
100
101    Loci::variableSet query_vars( Loci::expression::create(query));
102
103    Loci::variableSet::const_iterator vi ;
104
105    for(vi=query_vars.begin();vi!=query_vars.end();++vi) {
106      Loci::storeRepP sr = facts.get_variable(*vi) ;
107      if(sr == 0) {
108         cout << "variable " << *vi << " does not exist in fact database."
109      << endl ;
110      } else {
111      sr->Print(cout) ;
112      }
113    }
114
115    //-------------------------------------------------------------------
116    // Execution over successfully
117    //-------------------------------------------------------------------
118
119    return 0 ;
120  }
121
122  //*********************************************************************
\end{verbatim}

\subsubsection { Creating Rules }
\begin{verbatim}
1  class laplaceConvergence_unit : public unit_rule {
2    param<double>    maxError;
3  public:
4    laplaceConvergence_unit() {
5      name_store( "maxError", maxError );
6      constraint( "UNIVERSE");
7
8      output("maxError");
9    }
10    virtual void compute(const sequence &seq){
11      *maxError = 0.0;
12    }
13
14  };
15  register_rule<laplaceConvergence_unit>
16                register_laplaceConvergence_unit;
17
18  //*********************************************************************
19
20  class laplaceConvergence_apply : public apply_rule<param<double>,
21                                                 Loci::Maximum<double> >
22  {
23    param<double>       maxError;
24    const_store<double> fnew, fold ;
25  public:
26    laplaceConvergence_apply() {
27      name_store("maxError", maxError);
28      name_store("smooth{n}",  fold);
29      name_store("smooth{n+1}",fnew);
30
31      input( "smooth{n}");
32      input( "smooth{n+1}");
33      output("maxError");
34    }
35    void calculate( Entity e) {
36      join(maxError[e], fabs(fold[e]-fnew[e])) ;
37    }
38    virtual void compute( const sequence &seq) {
39      do_loop( seq, this );
40    }
41  };
42
43  register_rule<laplaceConvergence_apply>
44    register_laplaceConvergence_apply;
45
46  //*********************************************************************
47
48  class laplaceSmoothing_initial : public pointwise_rule {
49    store<double>          finit ;
50    const_store<double>    noisyData;
51  public:
52    laplaceSmoothing_initial() {
53      name_store("smooth{n=0}",finit) ;
54      name_store("noisyData",noisyData) ;
55
56      input( "noisyData" );
57      output("smooth{n=0}") ;
58    }
59    void calculate(Entity e) {
60      finit[e] = noisyData[e] ;
61    }
62    virtual void compute(const sequence &seq) {
63      do_loop(seq,this ) ;
64    }
65  } ;
66
67  register_rule<laplaceSmoothing_initial>
68               register_laplaceSmoothing_initial ;
69
70  //*********************************************************************
71
72  class laplaceSmoothing_default : public pointwise_rule
73  {
74    store<double>      fnew;
75    const_store<double>      fold;
76  public:
77    laplaceSmoothing_default() {
78      name_store( "smooth{n}",  fold );
79      name_store( "smooth{n+1}",fnew );
80
81      input ("smooth{n}");
82      output("smooth{n+1}");
83    }
84    void calculate( Entity e){
85      fnew[e] = fold[e];
86    }
87
88    virtual void compute( const sequence &seq)
89    {
90      do_loop( seq, this );
91    }
92  };
93
94  register_rule<laplaceSmoothing_default>
95               register_laplaceSmoothing_default;
96
97  //*********************************************************************
98
99  class laplaceSmoothing_advance : public pointwise_rule{
100    store<double>         fnew;
101    const_store<double>   fold;
102    const_MapVec<4>       neighConnect;
103  public:
104    laplaceSmoothing_advance() {
105      name_store( "smooth{n}",  fold );
106      name_store( "interior::smooth{n+1}",fnew );
107      name_store( "neighConnect", neighConnect);
108
109      input ("neighConnect->smooth{n}");
110      output("interior::smooth{n+1}");
111    }
112    void calculate( Entity e){
113      int    n1, n2, n3, n4;
114      n1      = neighConnect[e][0];
115      n2      = neighConnect[e][1];
116      n3      = neighConnect[e][2];
117      n4      = neighConnect[e][3];
118      fnew[e] = (fold[n1] + fold[n2] + fold[n3] + fold[n4])/4.0;
119    }
120
121    virtual void compute( const sequence &seq)
122    {
123      do_loop( seq, this );
124    }
125  };
126
127  register_rule<laplaceSmoothing_advance>
128                register_laplaceSmoothing_advance;
129
130  //*********************************************************************
131
132  class laplaceSmoothingOver_condition : public singleton_rule {
133    const_param<int> n, max_iteration ;
134    param<bool>      smoothingOver ;
135  public:
136    laplaceSmoothingOver_condition() {
137      name_store("$n",n) ;
138      name_store("max_iterations",max_iteration);
139      name_store("SmoothingOver",smoothingOver);
140
141      input("$n,max_iterations") ;
142      output("SmoothingOver") ;
143    }
144    virtual void compute(const sequence &seq) {
145      *smoothingOver = (*n >= *max_iteration);
146    }
147  } ;
148
149  register_rule<laplaceSmoothingOver_condition>
150                register_laplaceSmoothingOver_condition;
151
152  //*********************************************************************
153
154  class collapse_smoothing : public pointwise_rule {
155    store<double>        result ;
156    const_store<double>  smooth ;
157
158  public:
159    collapse_smoothing() {
160      name_store("smooth{n}",smooth) ;
161      name_store("smooth",result) ;
162
163      input("smooth{n}") ;
164      output("smooth") ;
165      conditional("SmoothingOver{n}") ;
166    }
167    void calculate(Entity e) {
168      result[e] = smooth[e] ;
169    }
170    virtual void compute(const sequence &seq) {
171      do_loop(seq,this ) ;
172    }
173  } ;
174
175  register_rule<collapse_smoothing>
176                register_collapse_smoothing ;
177
178  //*********************************************************************
\end{verbatim}

\subsection{ Using Loci : Method 2}

\subsubsection { Creating fact database }
\begin{verbatim}
     1
     2  int main(int argc, char *argv[])
     3  {
     4
     5    //-------------------------------------------------------------------
     6    // Step 1: Specify queries ...
     7    //-------------------------------------------------------------------
     8
     9    string query = "smooth" ;
    10
    11    //-------------------------------------------------------------------
    12    // Step 2: Create fact database
    13    //-------------------------------------------------------------------
    14
    15    fact_db     facts ;               // Facts Database
    16    param<int>     max_iterations;
    17    *max_iterations = 100;
    18
    19    facts.create_fact( "max_iterations", max_iterations);
    20
    21    //-------------------------------------------------------------------
    22    // Create entities. In this example, all the internal nodes are our
    23    // entities where calculation will be performed i.e. where Laplacian
    24    // operator will be applied. For this example, we are creating data
    25    // statically, but can be modified to read through a file.
    26    //-------------------------------------------------------------------
    27
    28    int  xnodes, ynodes;
    29
    30    ifstream infile("noise.dat", ios::in);
    31    if( infile.fail()) {
    32      cout << "Error: Cann't open file " << endl;
    33      exit(0);
    34    }
    35
    36    infile >> xnodes >> ynodes;
    37
    38    store<double> noisyData;
    39    entitySet     nodes = interval(0,xnodes*ynodes-1);
    40    noisyData.allocate(nodes);
    41
    42    for( i = 0; i < xnodes*ynodes; i++)
    43      infile >> noisyData[i];
    44    infile.close();
    45
    46    facts.create_fact( "noisyData",noisyData);
    47
    48    //-------------------------------------------------------------------
    49    // In 2D structured grid, all internal nodes have four neighbors.
    50    //-------------------------------------------------------------------
    51
    52    size_t offset;
    53    // Create East map
    54    Map      eastmap;
    55
    56    for( i = 1; i < xnodes-2; i++) {
    57      for( j = 1; j < ynodes-1; j++) {
    58        offset          = j*xnodes + i;
    59        eastmap[offset] = offset+1;     // rightConnect
    60      }
    61    }
    62    facts.create_fact( "EastConnect", eastmap);
    63
    64    // Create West map
    65    Map      westmap;
    66    for( i = 2; i < xnodes-1; i++) {
    67      for( j = 1; j < ynodes-1; j++) {
    68        offset          = j*xnodes + i;
    69        westmap[offset] = offset-1;     // rightConnect
    70      }
    71    }
    72    facts.create_fact( "WestConnect", westmap);
    73
    74    // Create North map
    75    Map      northmap;
    76    for( j = 1; j < ynodes-2; j++) {
    77      for( i = 1; i < xnodes-1; i++) {
    78        offset          = j*xnodes + i;
    79        northmap[offset] = offset+xnodes;
    80      }
    81    }
    82    facts.create_fact( "NorthConnect", northmap);
    83
    84    // Create South map
    85    Map      southmap;
    86    for( j = 2; j < ynodes-1; j++) {
    87      for( i = 2; i < xnodes-1; i++) {
    88        offset          = j*xnodes + i;
    89        southmap[offset] = offset-xnodes;     // rightConnect
    90      }
    91    }
    92    facts.create_fact( "SouthConnect", southmap);
    93
    94    //-------------------------------------------------------------------
    95    // Step 3: Create Rules and register then into Rule database
    96    //-------------------------------------------------------------------
    97    rule_db    rdb ;                  // Rule Database
    98
    99    rdb.add_rules(global_rule_list) ;
   100
   101    //-------------------------------------------------------------------
   102    // Step 4: Create Scheduler
   103    //-------------------------------------------------------------------
   104
   105    facts.write(cout) ;
   106
   107    executeP schedule = create_execution_schedule(rdb,facts,query ) ;
   108
   109    if(schedule != 0) {
   110      cout << "schedule = " << endl ;
   111      schedule->Print(cout) ;
   112      schedule->execute(facts) ;
   113    }
   114
   115    //-------------------------------------------------------------------
   116    // Step 5: Execute the scheduler
   117    //-------------------------------------------------------------------
   118
   119    Loci::variableSet query_vars( Loci::expression::create(query));
   120
   121    //-------------------------------------------------------------------
   122    // Step 6: Query the database ...
   123    //-------------------------------------------------------------------
   124
   125    Loci::variableSet::const_iterator vi ;
   126
   127    for(vi=query_vars.begin();vi!=query_vars.end();++vi) {
   128      Loci::storeRepP sr = facts.get_variable(*vi) ;
   129      if(sr == 0) {
   130        cout << "variable " << *vi << " does not exist in fact database."
   131             << endl ;
   132      } else {
   133        sr->Print(cout) ;
   134      }
   135    }
   136
   137    //-------------------------------------------------------------------
   138    // Execution over successfully
   139    //-------------------------------------------------------------------
   140
   141    return 0 ;
   142  }
\end{verbatim}

\subsection { Creating rules }
\begin{verbatim}
     1  class laplaceConvergence_unit : public unit_rule {
     2    param<double>    maxError;
     3  public:
     4    laplaceConvergence_unit() {
     5      name_store( "maxError", maxError );
     6      constraint( "UNIVERSE");
     7
     8      output("maxError");
     9    }
    10    virtual void compute(const sequence &seq){
    11      *maxError = 0.0;
    12    }
    13
    14  };
    15  register_rule<laplaceConvergence_unit>
    16                register_laplaceConvergence_unit;
    17
    18  //*********************************************************************
    19
    20  class laplaceConvergence_apply : public apply_rule<param<double>,
    21                                                 Loci::Maximum<double> >
    22  {
    23    param<double>       maxError;
    24    const_store<double> fnew, fold ;
    25  public:
    26    laplaceConvergence_apply() {
    27      name_store("maxError", maxError);
    28      name_store("smooth{n}",  fold);
    29      name_store("smooth{n+1}",fnew);
    30
    31      input( "smooth{n}");
    32      input( "smooth{n+1}");
    33      output("maxError");
    34    }
    35    void calculate( Entity e) {
    36      join(maxError[e], fabs(fold[e]-fnew[e])) ;
    37    }
    38    virtual void compute( const sequence &seq) {
    39      do_loop( seq, this );
    40    }
    41  };
    42
    43  register_rule<laplaceConvergence_apply>
    44    register_laplaceConvergence_apply;
    45
    46  //*********************************************************************
    47
    48  class laplaceSmoothing_initial : public pointwise_rule {
    49    store<double>          finit ;
    50    const_store<double>    noisyData;
    51  public:
    52    laplaceSmoothing_initial() {
    53      name_store("smooth{n=0}",finit) ;
    54      name_store("noisyData",noisyData) ;
    55
    56      input( "noisyData" );
    57      output("smooth{n=0}") ;
    58    }
    59    void calculate(Entity e) {
    60      finit[e] = noisyData[e] ;
    61    }
    62    virtual void compute(const sequence &seq) {
    63      do_loop(seq,this ) ;
    64    }
    65  } ;
    66
    67  register_rule<laplaceSmoothing_initial>
    68               register_laplaceSmoothing_initial ;
    69
    70  //*********************************************************************
    71
    72  class laplaceSmoothing_default : public pointwise_rule
    73  {
    74    store<double>      fnew;
    75    const_store<double>      fold;
    76  public:
    77    laplaceSmoothing_default() {
    78      name_store( "smooth{n}",  fold );
    79      name_store( "smooth{n+1}",fnew );
    80
    81      input ("smooth{n}");
    82      output("smooth{n+1}");
    83    }
    84    void calculate( Entity e){
    85      fnew[e] = fold[e];
    86    }
    87
    88    virtual void compute( const sequence &seq)
    89    {
    90      do_loop( seq, this );
    91    }
    92  };
    93
    94  register_rule<laplaceSmoothing_default>
    95               register_laplaceSmoothing_default;
    96
    97  //*********************************************************************
    98
    99  class laplaceSmoothing_advance : public pointwise_rule{
   100    store<double>         fnew;
   101    const_store<double>   fold;
   102    const_Map             eastmap, westmap, northmap, southmap;
   103  public:
   104    laplaceSmoothing_advance() {
   105      name_store( "smooth{n}",  fold );
   106      name_store( "interior::smooth{n+1}",fnew );
   107      name_store( "EastConnect",  eastmap);
   108      name_store( "WestConnect",  westmap);
   109      name_store( "NorthConnect", northmap);
   110      name_store( "SouthConnect", southmap);
   111
   112      input ("eastmap->smooth{n}");
   113      input ("westmap->smooth{n}");
   114      input ("northmap->smooth{n}");
   115      input ("southmap->smooth{n}");
   116
   117      output("interior::smooth{n+1}");
   118    }
   119    void calculate( Entity e){
   120      int    n1, n2, n3, n4;
   121      n1      = eastmap[e];
   122      n2      = westmap[e];
   123      n3      = northmap[e];
   124      n4      = southmap[e];
   125      fnew[e] = (fold[n1] + fold[n2] + fold[n3] + fold[n4])/4.0;
   126    }
   127
   128    virtual void compute( const sequence &seq)
   129    {
   130      do_loop( seq, this );
   131    }
   132  };
   133
   134  register_rule<laplaceSmoothing_advance>
   135                register_laplaceSmoothing_advance;
   136
   137  //*********************************************************************
   138
   139  class laplaceSmoothingOver_condition : public singleton_rule {
   140    const_param<int> n, max_iteration ;
   141    param<bool>      smoothingOver ;
   142  public:
   143    laplaceSmoothingOver_condition() {
   144      name_store("$n",n) ;
   145      name_store("max_iterations",max_iteration);
   146      name_store("SmoothingOver",smoothingOver);
   147
   148      input("$n,max_iterations") ;
   149      output("SmoothingOver") ;
   150    }
   151    virtual void compute(const sequence &seq) {
   152      *smoothingOver = (*n >= *max_iteration);
   153    }
   154  } ;
   155
   156  register_rule<laplaceSmoothingOver_condition>
   157                register_laplaceSmoothingOver_condition;
   158
   159  //*********************************************************************
   160  class collapse_smoothing : public pointwise_rule {
   161    store<double>        result ;
   162    const_store<double>  smooth ;
   163
   164  public:
   165    collapse_smoothing() {
   166      name_store("smooth{n}",smooth) ;
   167      name_store("smooth",result) ;
   168
   169      input("smooth{n}") ;
   170      output("smooth") ;
   171      conditional("SmoothingOver{n}") ;
   172    }
   173    void calculate(Entity e) {
   174      result[e] = smooth[e] ;
   175    }
   176    virtual void compute(const sequence &seq) {
   177      do_loop(seq,this ) ;
   178    }
   179  } ;
   180
   181  register_rule<collapse_smoothing>
   182                register_collapse_smoothing ;
   183
   184  //*********************************************************************
\end{verbatim}
~
