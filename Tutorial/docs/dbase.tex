\chapter { Database}

A database is the fundamental starting point for any logic 
programming systems. The definition of a problem to be solved begins
as a collection of facts stored in a database, while the result of a
rule applications is to modify the existing and/or creation of new
fact databases. Thus the database becomes a center of communication
for program derived from the specification.
%
\section { Facts and Facts database }

A Facts in Loci is a property associated with an entity. This property
could either be in the form of data or reference to some other
entities (maps). 

If the property is a map, it has to provided by the user before the
execution of the program.

If the property is a data, it could either user defined, or derived
using know facts.  In Loci, all facts are stored in the database,
hereafter called {\bf facts database} In general there are four types
of facts within the Loci system which are

\begin{enumerate}
\item Parameter
\item store
\item maps
\item constraint
\end{enumerate}

\section { Rules and Rules database }
In addition to a database of facts that includes the problem
specification, a database of rules describes transformations that can
be used to introduce new facts into the database. These rules
correspond to fundamental computations involved in solution algorithms
such as rules for evaluating areas of faces, or for solving equations
of state.  These rules are specified using text strings called rule
signatures that describe the input stores, parameters, and maps
required to perform a computation and the list of stores or parameters
that it generates.  Rule signatures are of the form {\tt head <- body}
where head consists of a list of variables that are generated by the
application of the rule, while the body contains a list of variables
that are accessed while performing the computation.  For example, the
rule signature {\tt p<-rho, T, R} represents that a value for pressure
({\tt p}) is provided when values for density ({\tt rho}), temperature
({\tt T}), and gas constant ({\tt R}) are present.

\begin{figure}[h]
\special{psfile=rule.eps vscale=50 hscale=50 voffset=-175 hoffset=125}
\vspace{2.50in}\caption { A Rule produces new facts }
\end{figure}

As shown in the above figure, a rule requires some input facts and 
produces new facts. In Loci, input facts cann't be modified, therefore,
they should be declared as read-only facts.

\par In Loci, rules can be classified in four basic rules, these are
\begin{enumerate}
\item {\bf Singleton Rule :} A rule which accepts parameters as input and 
generates a single value for an entitySet.
%
\item {\bf Pointwise Rule :}  A rule which operates on each entity independently and
produces for its own entitySet or for other entitySet over which the rule is applied.
%
\item {\bf Reduction Rule :}  A reduction rule is specified for reduction operations. 
A reduction operation works on a set of entities to produces a single value. A reduction
A reduction rule is an application of two rules
\begin{enumerate}
\item Unit Rule  A rule which initialize the values for reduction operation. 
\item Apply Rule A rule which applies operation over an entitySet.
\end{enumerate}
%
\item {\bf Iteration Rules :}  An iterative process is an set of rules, which requires
%
\begin{enumerate}
\item {\bf Build Rule(BR) :} A rule  which start an iteration hierarchy with initialization
of the values.
\item {\bf Advance Rule(AR) :} A Rule which specifies how to advance in the iterations.
\item {\bf Collapse Rule(CR):} A Rule which specifies what to do at the end of iterations.
\end{enumerate}
\end{enumerate}
%

\section {name\_store}
Every rule work on the facts to change or produce new facts. Rules and
facts are described in the next chapter. The {\em name\_store} specify the 
facts which are required by the rule. Although
no harm will be done, if you specify a fact which is not used to create
a new fact, but we should avoid to make the objective of the rule more
concise and elegant.

\par Another way we can think of class {\em name\_store} is that it opens the
files in a database. The syntax of {\em name\_store} is
\begin{center}
name\_store ("Fact", local\_store\_variable\_name)
\end{center}
where "Fact" is the variable name of the fact which is associated with the database,
and {\em local\_store\_variable\_name} is the locally defined name 
of the fact in a rule. 

\par Some conventions for defining facts name in the database.

\begin{itemize}
\item  It is case sensitive
\item  It is not a string, but a variable like any other variable, therefor
       "Fact-New", "Fact+New" are invalid names.
\item  This variable is different from locally defined variable, therefore 
       it is more elegant and acceptable to provide  name\_store("Fact", Fact)
       both the variables seems to have same name, but they are in different
       context.
\end{itemize}


\section  { A general skeleton of Loci Rule }
\begin{verbatim}
class newRule : public rule_name 
{
public:
  newRule() { 
     name_store( "Fact1", infact1);
     name_store( "Fact2", infact2);
     name_store( "Fact3", infact3);
     .
     .
     name_store( "Fact4", outfact1);
     name_store( "Fact5", outfact2);
     .
     .
     input( "Fact1");
     input( "Fact2");
     input( "Fact3");
     .
     .
     output( "Fact4");
     output( "Fact5");
     .
     .
  }
  void calculate( Entity e)
  {
     // Specify the formula to calculate new fact here.

  }
  virtual void compute( const sequence &seq)
  {
    do_loop( seq, this );
  }
private:
  const_store<datatype>    infact1, infact2;
  const_param<datatype>    infact3;

  store<datatype>          outfact1, outfact2;

};
register_rule <newRule>  register_newRule;
\end{verbatim}

\par Here datatype could be any datatype either standard or user-defined.

\section { Important things about rule specification }
\begin{itemize}
\item In Loci, any fact, which is not output of the rule specification
has to be declared const type. This allows strict checking of the intention of the fact
within a rule. For example, use const\_store instead of store.
%
\item A rule can have multiple inputs and multiple outputs facts.
%
\item All the rules must be registered before they can be used. 
%
\item The member function {\em compute} accept sequence as an 
argument which is generated by Loci schedule, by analyzing the rule signature 
%
\item The member function {\em calculate} applies rule for each entity
supplied by the sequence.
\end{itemize}
%
\section {Context of the Rule}
When we write a rule to generate a new facts, we have to apply the rule over an 
entitySet.  A context of the rule is defined as the set of entities, where a particular 
rule is applied.  
%
\section { Singleton Rule }
In Loci, computations on parameters are accomplished using Singleton Rule.
%
\begin{figure}[h]
\special{psfile=single.eps vscale=50 hscale=50 voffset=-250 hoffset=125}
\vspace{3.50in}\caption { A singleton rule produces a parameter fact}
\end{figure}
%
\par {\bf Example :} Suppose we are writing an iterative scheme and we 
would like to terminate the iterations when the iteration counter has
reached to the maximum which is specified by the user. We define a parameter named 
{\em smoothOver}, which is used as an indicator of the progress. If its value is 1, then the
iterations are stopped. Since this parameter is same for all the entities,
it is implemented as {\bf Singleton Rule }
\begin{verbatim}
class SmoothingOver_condition : public singleton_rule {
  const_param<int> n, max_iteration ;
  param<bool>      smoothingOver ;
public:
  SmoothingOver_Condition() {
    name_store("$n",n) ;
    name_store("max_iterations",max_iteration);
    name_store("SmoothingOver",smoothingOver);
    
    input("$n,max_iterations") ;
    output("SmoothingOver") ;
  }
  virtual void compute(const sequence &seq) {
    *smoothingOver = (*n >= *max_iteration);
  }
} ;
\end{verbatim}

\section{ Pointwise Rules }
A pointwise rule operates on each entity independently and produces new facts. This
rules is sometimes called {\em Rule of Production }.  
One important thing remember is that {\bf Pointwise rules they are unique
to Loci} and if you try to provide two rules for the generation of same new fact,
then Loci, will get confuse and will not proceed.
%
\begin{figure}[h]
\special{psfile=point.eps vscale=50 hscale=50 voffset=-175 hoffset=125}
\vspace{2.50in}\caption { A pointwise rule produces new facts for each entity  }
\end{figure}
%
\par {\bf Example : } In the previous example, given the node-coordinates and 
neighbor nodes information, we would like to calculate the area of each
cell. Obviously, are calculation of one triangle doesn't depend on the 
calculation for the other triangle, therefore the rule for generating
area of a triangle is a {\em pointwise rule}
\begin{verbatim}
1  class triCentroid : public pointwise_rule{
2    store<VECTOR>         centroid;
3    const_MapVec<3>       triConnect;
4    const_store<VECTOR>   pos;
5  public:
6    triCentroid ()
7    {
8      name_store( "Centroid", centroid );
9      name_store( "triConnect", triConnect);
10      name_store( "pos", pos);
11
12      input ("triConnect->pos");
13      output("Centroid");
14    }
15
16    //---------------------------------------------------------------------
17    // The following is the rule to calculate the centroid of triangle..
18    //---------------------------------------------------------------------
19    void calculate( Entity e)
20    {
21      int    n1, n2, n3;
22      n1            = triConnect[e][0];
23      n2            = triConnect[e][1];
24      n3            = triConnect[e][2];
25      centroid[e].x = (pos[n1].x + pos[n2].x + pos[n3].x)/3.0;
26      centroid[e].y = (pos[n1].y + pos[n2].y + pos[n3].y)/3.0;
27    }
28
29    virtual void compute( const sequence &seq)
30    {
31      do_loop( seq, this );
32    }
33  };
\end{verbatim}
%
\section {Recursion}
A {\bf Recursive definition} is a statement in which something is defined
in terms of {\bf smaller version of itself}. All recursive definition 
consists of two parts
\begin{enumerate}
\item {\bf Base case} is that part of the definition which {\bf cannot} 
be expressed in in terms of smaller version of itself. 
\item {\bf Recursive case} is that part of the definition which can
be expressed in terms of smaller version of itself.
\end{enumerate}

%**********************************************************************************************
%Consider a Russian Doll which consists of N nested dolls of decreasing sizes. One might 
%originally ask, "How many dolls actually exist in a given Russian Doll?"   The largest and 
%outermost doll might then reply saying, "Well, there's 1 of me and let me find out how 
%many dolls there are inside of me."   Turning to the next outermost doll, the largest doll 
%asks, "How many dolls are there?"   The answer of the outermost doll to the original 
%question is suspended while the next outermost dolls seeks an answer.   The next outermost 
%doll might reply saying, "Well there's 1 of me and let me find out how many dolls there are 
%inside of me."   Turning to the next doll, the next outermost doll asks, "How many dolls 
%are there?"   And the process continues until the questioning reaches the innermost doll 
%where that doll replies, "There's only 1 of me."   This then allows the next innermost 
%doll to reply, "There are 2 dolls."   And so on, until finally the outermost doll is 
%able to reply, "There are N dolls." 

%The corresponding recursive pseudo-function might look as follows : 
%\begin{verbatim}
%int function RussianDoll 
%{ 
%    int doll ; 
%    // base case 
%    if ( there's only one doll ) 
%       return ( 1 ) ; 
%
%    // else recursive case 
%    doll = 1 + RussianDoll ; 
%    return ( doll ) ; 
%} 
%\end{verbatim}
%After the questioning reaches the innermost doll and the process reverts back to the next 
%doll until it reaches the original inquirer, that process is referred to as back tracking . 
%**********************************************************************************************

One important thing about the recursion is the {\bf Recursion follows entities in a particular
sequence}, unlike pure pointwise rules which don't depend on the sequence order. This suggests 
us that if we are able to order the sequence for pointwise rule, we might get a correct results 
for recursion. Let us use an example to demonstrate how we can put entities in a some order. 

\par In this example, we will create some entities and enumerate them in increasing order
$(1 \dots n)$. We want to create two sequences
\begin{enumerate}
\item  {\bf Increasing Order }  Entities are traversed as $(1,2,3, \dots n-1,n)$
\item  {\bf Decreasing Order }  Entities are traversed as $(n-1,n-2,  \dots 2,1)$
\end{enumerate}

The way we implement this sequence is with the use of Map. In the first case, we define
a map {\em predecessor} which maps the immediately previous entity to the entity $e$. 
Only the first entity don't have the {\em predecessor} and this becomes the base of 
recursion.  In the second case, we define a map {\em successor } which holds the 
immediate next entity to an entity $e$. In this case, the last entity will not have
any mapping, and therefore, becomes the base of iteration. In both the cases, we will 
need two pointwise rules, one for the base, which require only one entity to participate 
in the rule invocation, and this could be enforced using the constraint environment and
the second rule will be invoked recursively till the end.

\par Now we will write programs which implements both the methods to create the sequence.

\section{ Reduction Rule }
\par A {\em Reduction Rule } is a rule, which operates on a set of entities
and returns a single value as a result. For example, the following C++
program uses operator *, to calculate the product of an array {\em someArray}
\begin{center}
\begin{verbatim}
prod = 1.0;
for( i = 0; i < arraySize; i++)
     prod  *=   someArray[i];
\end{verbatim}
\end{center}
\par In the above, a variable {\em prod }is initialized to 1, then a loop is
run over every element of an array, and its values are multiplies sequentially
to the variable {\em prod }


The target of reduction rules could be either single parameter or store for
each entity. For example, addition of 2 vectors produces an array, whose each
element is an obtained using reduction operation.
\begin{verbatim}
store<double>  prod;

// Initialzation : Unit Rule
for( i = 0; i < arraySize; i++)
     prod[i] = 1.0;

// Operation: Apply Rule
for( i = 0; i < arraySize; i++)
     prod[i]  =  a[i]*b[i];
\end{verbatim}
\par In the above, a variable {\em prod }is initialized to 1, then a loop is
run over every element of an array, and its values are multiplies sequentially

\section {Global v/s Local Reduction Rules}
There are two ways in which reduction operation are used.
\begin{itemize}
\item  {\bf Reduction for parameter datatype} When the reduction is used for
parameter datatype, then an entitySet produces a single value which is same
for that entitySet.
%
\par {\bf Example :} In CFD application, explicit schemes are frequently used,
If we are interested in the unsteady solution, we have to calculate CFL condition
for each entity, and then apply the reduction operation to get the global
minimum CFL number. Every entity uses this global minimum value to advance in
time. See Figure  A.
%
\item  {\bf Reduction for store datatype} When reduction is carried out over
a small subset of entities for each entity in the entitySet then the output
is a store datatype. Such a reduction is local to each entity.
\par {\bf Example :} If we are interested in steady state solution, we can
relax the stringent condition of global time step and allow each entity to 
proceed at its own time step. Therefore, we have to store the time step value 
for each entity. See Figure  B
\end{itemize}
\begin{figure}[h] 
\special{psfile=gloLoc.eps vscale=50 hscale=50 voffset=-175 hoffset=50}
\vspace{2.50in}\caption { Global and local reduction operation}
\end{figure}
\par In Loci, when a variable is defined by reduction rules, then its value
is the result of a set of rules applications. We have to define two rules
which are explained below.

\section { Unit Rule }
\par Before we apply reduction operation over an entitySet, it is necessary
to initialize the target value (values). In Loci, this is accomplished by
{\bf Unit Rule } For example, a summation operation requires initialization
of 0 value and a product operation requires initial value of 1 for each entity.
A {\bf unit rule} in Loci defines a unit value to each entity defined by
constraint environment. {\bf A unit rule is a single value assignment rule 
for the entities }, which mens that entities can not be initialized with
different values for each entity.
{\bf No value for a reduction can be generated without first binding a unit 
value to the target entitySet}. 
A {\bf unit\_rule} also has a constraint qualifier that limits
which entities are included in the computations.  

\section { Apply Rule }
Once the {\bf unit rule } has been applied to all the entities in an entity
set, we can apply reduction operation using the {\bf Apply Rule}

\par Loci provides four predefined reduction operators i.e. Summation, Product,
Maximum and Minimum. A user can define his/her own reduction operator, which we
will explain in the next examples.

\par A reduction operation is commutative that means $a\oplus (b \oplus c) =  (a \oplus b) \oplus c$.
This implies that the final result doesn't depend on the order of execution. 

\par Let us calculate the factorial value of an integer value using reduction operation.
In order to apply this rule, a fact consists of $(n,n-1,n-2, \dots 1)$
has to be created and stored in the fact database. A program in Loci will be 
as follows.
%
\begin{verbatim}
class Factorial_Unit : public unit_rule {
  param<int>  factorial;
public:
  Factorial_Unit() {
    name_store( "Factorial", factorial );
    constraint( "EntityVals");

    output("Factorial");
  }
  virtual void compute(const sequence &seq){
    *factorial = 1;
  }
};

register_rule<Factorial_Unit>  register_Factorial_Unit ;

class Factorial_Apply : public apply_rule<param<int>,
                                       Loci::Product<int> >
{
  param<int>         factorial;
  const_store<int>   entityVals ;
public:
  Factorial_Apply() {
    name_store("Factorial",  factorial);
    name_store("EntityVals", entityVals) ;

    input("EntityVals");
    input("Factorial");

    output("Factorial");
  }

  void calculate( Entity e) {
    join(factorial[e], entityVals[e]) ;
  }

  virtual void compute( const sequence &seq) {
    do_loop( seq, this );
  }
};

register_rule<Factorial_Apply> register_Factorial_Apply;
\end{verbatim}

%
\section { Defining your own reduction operators }
Although, Loci provides some frequently used reduction operations, but, it is fairly 
easy to create your own reduction operations. 
%
\par {\bf Example :} Although Loci provides {\bf Maximum } and {\bf Minimum} reduction
operations, we would like to create our own operation, which combines these two operation
into one operation, to demonstrate to create our own reduction operations.

\begin{verbatim}
class MinMax {
 public:
   void  operator() ( Array<float,2> &update, const Array<float,2> &newval)
   {
       update[0] = (float) min( (double)update[0],(double)newval[0] );
       update[1] = (float) max( (double)update[1],(double)newval[1] );
   }
};

class MyOp_Unit : public unit_rule {
  param<Array<float,2> > minmax;
public:
  MyOp_Unit() {
    name_store( "MinMax", minmax);
    constraint( "Density");
    
    output("MinMax");
  }

  virtual void compute(const sequence &seq){
    Array<float,2>   &newvec = *minmax;
    newvec[0]  =  1.0E+10;
    newvec[1]  = -1.0E+10;
  }

};

register_rule<MyOp_Unit>  register_myop_unit;

//*********************************************************************
// Notice that in the "apply rule" the value of PI has in-out intention.
// That is it value changes with this rule.
//
// This most important step is the "Join" statement, which combines the
// value of an entity using Reduction operator. In this example, we have
// used LOCI predefined operator "Summation" for the addition purpose. .
//*********************************************************************

class MinMax_apply : public apply_rule< param<Array<float,2> >, MinMax >
{
  param<Array<float,2> >   minmax;
  const_store<float>       array;
  Array<float,2>           newvec;
public:
  MinMax_apply() {
    name_store("MinMax",  minmax) ;
    name_store("Density", array);
    
    input("MinMax");
    input("Density") ;

    output("MinMax");
  }
  
  void calculate( Entity e) {
      newvec[0] = array[e];
      newvec[1] = array[e];
      join(minmax[e], newvec);
  }
  
  virtual void compute( const sequence &seq) {
    do_loop( seq, this );
  }
};

register_rule<MinMax_apply> register_MinMax_apply;
//*********************************************************************
\end{verbatim}
%
\section {Local Reduction v/s Pointwise Rule }
In global reduction all entities in an entity set participate to produce a single
value. In many cases, each entities participates only with few other entities in 
the reduction operation, such rules can be implemented with either reduction
or pointwise rules.
\begin{figure}[h]
\special{psfile=reduc2.eps vscale=50 hscale=50 voffset=-175 hoffset=100}
\vspace{2.50in}\caption { Applying reduction operation using local entities}
\end{figure}

\par { \bf Example :} In an unstructured grid, every face is shared by at the most 
two cells, and at each cell center, we would to like assign the maximum value 
around the neighboring cell, (including the cell itself). 
i.e.
\begin{eqnarray}
\phi[1] &=&  max ( \phi[1], \phi[2], \phi[3], \phi[4] ) \\
\phi[2] &=&  max ( \phi[1], \phi[2]) \\
\phi[3] &=&  max ( \phi[1], \phi[3])
\end{eqnarray}

\par Now there are two ways of doing this operation, which depends on choosing
the entities.

\begin{itemize}
\item { \bf Cells entities in the loop} In this case, we have to create a {\em multimap} which
store the cell-neighbors information. Since all the participating entities are 
known in advance, the final reduce value is immediately available. 
\begin{verbatim}

class Smooth_Rule : public pointwise_rule
{
  const_store<float>   density;
  const_multiMap       cellNeighs;
  store<float>         smooth;
public:
 Smooth_Rule() {
    name_store("CellDensity",  density) ;
    name_store("Smooth",       smooth);
    name_store("CellCellNeighbours", cellNeighs);

    input("CellDensity");
    input("CellCellNeighbours");

    output("Smooth");
  }

  void calculate( Entity e) {
     smooth[e]  = density[e];
     for( const int *ci = cellNeighs.begin(e); ci != cellNeighs.end(e); ++ci)
          smooth[e] +=  density[*ci];
  }

  virtual void compute( const sequence &seq) {
    do_loop( seq, this );

  }
};
register_rule<Smooth_Rule> register_Smooth_Rule;
\end{verbatim}
%
\item { \bf Face entities in the loop} In this case, we can create  a {\em map} 
for each internal face and associate two neighboring cells to it. In order to perform
the calculation, we have to define three rules as follows
\begin{enumerate}
\item  A rule to create unit value (=0.0) for each cell entity.
\item  A rule which iterative over all internal edges and add the values of associate
cell entities.
\item  A rule which iterate over all the cell entities and add its own value.
\end{enumerate}

\begin{verbatim}
class Smooth_Unit : public unit_rule
{
  store<float>   smooth;
public:
 Smooth_Unit() {
    name_store("Smooth",   smooth);
    constraint("Density");

    output("Smooth");
  }
  void calculate( Entity e) {
      smooth[e] = 0.0;
  }

  virtual void compute( const sequence &seq) {
    do_loop( seq, this );
  }
};

register_rule<Smooth_Unit> register_Smooth_Unit;

//*********************************************************************

class Smooth_Rule1 : public apply_rule<store<float>, Loci::Summation<float> >
{
  const_store<float>   density;
  const_MapVec<2>      edgeCells;
  store<float>         smooth;
public:
 Smooth_Rule1() {
    name_store("Density",  density) ;
    name_store("Smooth",   smooth);
    name_store("Cell_Edge_Neighbours", edgeCells);

    input("Cell_Edge_Neighbours->Density");
    input("Cell_Edge_Neighbours->Smooth");

    output("Cell_Edge_Neighbours->Smooth");
  }

  void calculate( Entity e) {
     Entity e1    =  edgeCells[e][0];
     Entity e2    =  edgeCells[e][1];
     join( smooth[e2], density[e1] );
     join( smooth[e1], density[e2] );
  }

  virtual void compute( const sequence &seq) {
    do_loop( seq, this );

  }
};

register_rule<Smooth_Rule1> register_Smooth_Rule1;

//*********************************************************************

class Smooth_Rule2 : public apply_rule<store<float>, Loci::Summation<float> >
{
  const_store<float>   density;
  const_MapVec<2>      edgeCells;
  store<float>         smooth;
public:
 Smooth_Rule2() {
    name_store("Density",  density) ;
    name_store("Smooth",   smooth);

    input( "Density");
    input( "Smooth");

    output("Smooth");
  }

  void calculate( Entity e) {
     join( smooth[e], density[e] );
  }

  virtual void compute( const sequence &seq) {
    do_loop( seq, this );
  }
};

register_rule<Smooth_Rule2> register_Smooth_Rule2;

//*********************************************************************
\end{verbatim}
\end{itemize}
\section { Every local reduction rule can be implemented as pointwise rule }
%
Whenever, the reduction operation target is store datatype, we can either
use pointwise rule or reduction rules to generate the desired result. But before
that, let us review the concept of {\bf Context of Rule}. 
\begin{center}
target $\leftarrow$ context $\rightarrow$ source 
\end{center}
When the context of the rule and the target entitySet is same, then we have all 
all the information required to generate the target data. but when the
context entitySet and target entitySet are not same, then, we don't have
sufficient information to generate the final target value for an entity. In
this case, we have to apply local reduction. 

%In general all reduction rules, could be implemented with pointwise rule also.
%Let us see one example, where we have used pointwise rule to calculate the
%global sum of an array.
%
%\begin{verbatim}
%class SumApply : public  pointwise_rule {
%{
%public:
%   SumApply() {
%     name_store("sum",  mysum);
%     name_store("Array",someArray) ;
%
%     input("Array");
%     input("sum") ;
%     output("sum");
%   }
%
%    void calculate( Entity e) {
%      sum[e] += someArray[e];
%    }
%
%    virtual void compute( const sequence &seq) {
%      sum = 0.0;
%      do_loop( seq, this );
%    }
%  };
%private:
%  param<double> sum ;
%  const_store<double> someArray;
%}
%\end{verbatim}

Notice that the initialization is done just before the {\em do\_loop}. Now
the question comes in mind, then why it is necessary to provide a different
rule. The reasons are as follows
\begin{itemize}
\item pointwise rules can be applied only when all the information is 
already available, and just for the reduction operation, it might be prohibitive
to create additional facts.
\item Reduction rules could be implemented in an efficient ways.
\end{itemize}
%
\par Another way to remember this rule is as follows: Thinks about for which
entities the rule is being applied, and if you are producing data for yourself,
you can always implement using this rule as pointwise, but if you looping over
some entities, but producing data for other entities, you have to apply 
reduction operation, because you do not know in advance how many entities, and
the sequence of entities that will contribute to the final result.

\section { Iteration Rule }
The mathematical foundation of iteration rules is the {\bf Theory of Induction},
which is used to verify the correctness of a theorem $p(n)$ for all non-negative
integers.
It has two component
\begin{enumerate}
\item {\bf Basic Step}  Prove the truth of $P(0)$. This is usually done by direct
verification. In general, the basic step merely involves demonstrating that the
the theorem is true for some smallest integer. It need not be $0$.
\item {\bf Inductive Step} Prove that for any integer n, if the $p(n)$ is true,
$p(n+1)$ must also be true. 
\end{enumerate}

\section{Naming Convention}
\par In the iteration context, any variable is identified by name, 
entity identifier, and iteration identifier. Perhaps many times
we have come across $u_i^n$ symbol, which represent variable
name $u$ associated with entity $i$ at iteration $n$. The iteration
identifier of a variable represents an iteration hierarchy. In Loci,
brace delimited iteration identifier are used to signify the iteration
identifier of a variable, thus $u^{n-1}$ is represented as $u\{n-1\}$

\par In Loci, an iteration counter is accessed as {\bf \$n} where $n$ is
the positive integer value.

\subsection { Two classical examples of iterative scheme }
Let us consider two typical iterative schemes to solve system
of linear equations $Ax=b$.
\begin{itemize}
\item {\bf Jacobi Scheme} In the Jacobi method we write for the $n^{th}$ step of
iteration 
\begin{equation}
 D. x^n = -(L+U). x^{n-1} + b
\end{equation}
\item {\bf Gauss-Seidel Scheme}
\begin{equation}
 (L+D).x^n = -U.x^{n-1} + b
\end{equation}
\end{itemize}
\par where $D$ is the diagonal part of A, $L$ is the lower triangle of A with 
zeros on the diagonal,  and $U$ is the upper triangle of $A$ with zeros on the
diagonal.
%
In the above examples, using the existing facts at previous level, or newly 
created facts, we are creating ( producing ) new facts, which is the precise
definition of pointwise rule.
%
\subsection { General Steps in an iterative scheme }
Again consider the solving $Ax=b$ described in {\em point-wise rule} section.
All iterative scheme follows the steps
\begin{itemize}
\item Initialize the values of unknown at the start of iterations (i.e. n = 0)
\item Produce new facts for the next level of iteration i.e. (n+1)
\item Check the convergence. If converged, then break the loop.
\item Update values i.e. new facts becomes old facts.
\end{itemize}

\par In Loci,  iterations are performed by set of rules. One for each step 
described earlier.  
%
\begin{figure}[h]
\special{psfile=iter2.eps vscale=55 hscale=50 voffset=-200 hoffset=5}
\vspace{2.70in}\caption { Build, Advance and Collapse Rules constitute iteration Rules}
\label {FigIteration}
\end{figure}
%
\section {Build Rules}
\par Build rules are rules that formulates the initial values for the iteration.
They are identified as build rules because they construct a new foundation level for
the iteration hierarchy. In Loci, a build rule is implemented just like any other
pointwise rule, but with one difference, that is the brace limiter around the
variable, which is initialized. 

\par Why are they called Build rules and not initialization ?  For starting
iteration, Loci creates hierarchy, so in order to start the calculation we have
to build a foundation for the hierarchy, which is at $n=0$. 

\par {\bf Example :}
\begin{verbatim}
1  class Initialization: public pointwise_rule {
2    store<double>          finit ;
3    const_store<double>    noisyData;
4  public:
5    laplaceSmoothing_initial() {
6      name_store("smooth{n=0}",finit) ;
7      name_store("noisyData",noisyData) ;
8
9      input( "noisyData" );
10     output("smooth{n=0}") ;
11    }
12    void calculate(Entity e) {
13      finit[e] = noisyData[e] ;
14    }
15    virtual void compute(const sequence &seq) {
16      do_loop(seq,this ) ;
17    }
18 } ;
\end{verbatim}
\par Notice the line 6 and 10. The $\{ n= 0 \}$ around the fact smooth signifies that
it is a build rule. If there were no braces, then it would have been simply a stationary
rule.

\par {\bf At present Loci has a limitation that iterations can start only from $n=0$,
which means that we cannot restart the calculations from some intermediate stage.} 
%
\section {Advance Rule}
\par Advance rules specify how values changes with the iteration. These rules are 
implemented using pointwise rules. A prototype of advance rule is as follow
\begin{verbatim}
1 class laplaceSmoothing_advance : public pointwise_rule{
2  store<double>         fnew;
3  const_store<double>   fold;
4  const_MapVec<4>       neighConnect;
5 public:
6  laplaceSmoothing_advance() {
7    name_store( "data{n}",  fold );
8    name_store( "data{n+1}",fnew );
9    name_store( "neighConnect", neighConnect);
10   input ("neighConnect->data{n}");
11   output("data{n+1}");
12  }
13  void calculate( Entity e){
14    int    n1, n2, n3, n4;
15    n1      = neighConnect[e][0];
16    n2      = neighConnect[e][1];
17    n3      = neighConnect[e][2];
18    n4      = neighConnect[e][3];
19    fnew[e] = (fold[n1] + fold[n2] + fold[n3] + fold[n4])/4.0;
20  }
21  virtual void compute( const sequence &seq)
22  {
23    do_loop( seq, this );
24  }
25 };
26 register_rule<laplaceSmoothing_advance>
27             register_laplaceSmoothing_advance;
\end{verbatim}

In the above example values are advanced to $(n+1)$th iteration using the
value at $n$th level. In line 7, we specify the facts at $n$th level which
is input to the input and line 8, we specify the output fact for the $n+1)$
th level, which is generated by the application of the rule. 
\section {Collapse Rule}
\par  Collapse rule specify {\em how } iterations are terminated and what values are generated
as a result of the iteration process. The criterion of terminating an iterative process is
always user defined. In Loci, a collapse rule takes input from the current iteration
and generates values at the lower iteration level. The word "collapse" signifies that we 
are breaking the hierarchy of the variable, which was raised during the iterations from 
the stationary time at $n=0$. As a result of this rule, hierachial facts are brought 
down to stationary level, which were promoted by the build rules. After the execution of 
collapse rule, Loci, may delete the iteration fact, therefore, we may not be able to use 
them later.
\par The word {\em how } in collapse rule definition, can sometimes, creates confusion and 
ambiguity in the definition. Let
us clarify it more. This word {\em how }prescribe {\bf only} the  condition to stop the iterations, 
which is just a boolean operation. This rule doesn't requires {\em how} this condition was set to 
1, in fact, the rule, which calculates the condition is a different rule, and is 
implemented as a reductionrule (because all the entities should have the same value of
the condition). 
%
\begin{verbatim}
1 class ResultSmoothing: public pointwise_rule {
2  store<double>        result ;
3  const_store<double>  smooth ;
4  public:
5   ResultSmoothing() {
6    name_store("smooth{n}",smooth) ;
7    name_store("smooth",result) ;
8    input("smooth{n}") ;
9    output("smooth") ;
10   conditional("IterationOver{n}") ;
11  }
12  void calculate(Entity e) {
13    result[e] = smooth[e] ;
14  }
15  virtual void compute(const sequence &seq) {
16    do_loop(seq,this ) ;
17  }
18 } ;
\end{verbatim}
\par Notice the line 10, this signifies that this rule will be invoked only when the
{\em IterationOver${n}$} is true, i.e. when the iterations are over. Notice in the 
line 6, we have specified {\em smooth \{ n \}} which is the variable associated with the
iteration rules, and in line 7 {\em smooth} specifies the stationary level fact. The
collapse rule makes a copy of {\em smooth\{n\}} to {\em smooth} when the iteration are 
terminated. 

\par The collapse rule will be invoked when the conditional fact value is TRUE. It is
a singleton value, and it is up-to user to specify the criteria using {\bf Singleton Rule}.
Let us write a sample program to do this operation.
%
\par {\bf Example :} In solving $Ax=b$ using iterative schemes, we choose to terminate
iteration under the following conditions
\begin{itemize}
\item  The maximum residual $\parallel Ax-b \parallel$ $< \epsilon$.
\item  Iteration counter has reached to the Maximum number of iteration specified by the
       user.
\end{itemize}
\begin{verbatim}
1  class IterationOver_Condition : public singleton_rule {
3    const_param<int>      n, max_iteration ;
4    param<bool>           iterationOver ;
5    const_store<double>   tolerance;
6    const_store<double>   residue;
7  public:
8    IterationOver_Condition() {
9      name_store("$n",n) ;
10      name_store("maxIterations",max_iteration);
11      name_store("tolerance", tolerance);
12      name_store("maxResidue",residue);
13      name_store("IterationOver",iterationOver);
14
15     input("$n,maxIterations");
16       input("tolerance");
17       input("residue");
18
19      output("iterationOverr") ;
20    }
21    virtual void compute(const sequence &seq) {
22      *iterationOver = (*n >= *max_iteration) || ( residue < tolerance);
23    }
24 } ;
\end{verbatim}

\par One thing, which we should emphasize here that facts {\em smooth} and {\em smooth$\{n\}$}
are two totally different facts, one is stationary and the other is bind to iterative
rules. Sometime, at the end of collapse rule, you may want to copy the {\em smooth$\{n\}$} to
a result fact, which could be {\em smooth} also. Let us see how we do it.

\section { Priority Rules }
\par Let us take an example of solving 1D Laplace equation using finite difference
scheme with fixed boundary conditions (i.e. Dirichlet conditions). 
A sequential code in C++ may be as follows

\begin{verbatim}
  u[0]      = 1.0;  // Applying boundary condition at the left.
  u[nmax-1] = 1.0;  // Applying boundary condition at the right

  for( i = 1; i < nmax-1; i++) 
       u[i] = 0.0;  // Initializing the values at internal nodes,

  for( i = 0; i < nmax; i++) 
       uold[i] = u[i];
   
  // Start the iterations.
  for( iter = 0; iter < maxIter; iter++) {
      // Calculate the new values ...
       for( i = 1; i < nmax-1; i++) 
            unew[i] = 0.50*( uold[i-1] + uold[i+1]);

      // Update the values ...
      for( i = 1; i < nmax-1; i++) 
          uold[i] = unew[i];
  }
\end{verbatim}

\par In this program, the boundary conditions remains the same throughout
the computations, so it was unnecessary to copy them for the next iteration.
But the same method will not work in Loci, where each variable name $u$ is
associated with entity $i$ at iteration $n$. In Loci, things are fine only 
at the first iteration, but successive iteration will not have values at 
the boundary, so how do we proceed ?
%
\par Here comes the role of {\em priority rules}. A {\em priority rule} is
very similar to {\em point-wise rules} described earlier. By specifying
priority rules, we can ensure that boundary values are promoted at the next
iteration level, by just copying the values from previous level or updating
them differently than internal nodes. In other words, we are forcing that 
certain entities should have higher priority than the other ones. 
\par {\em In Loci, we can increase the priority of certain rules, but cannot
decrease it}

The following is the program which implements both priority rules and 
normal pointwise rules.

\begin{verbatim}
class laplaceSmoothing_default : public pointwise_rule 
{
  store<double>      fnew;
  const_store<double>      fold;
public:
  laplaceSmoothing_default() {
    name_store( "smooth{n}",  fold );
    name_store( "smooth{n+1}",fnew );
    
    input ("smooth{n}");
    output("smooth{n+1}");
  }
  void calculate( Entity e){
    fnew[e] = fold[e];
  }

  virtual void compute( const sequence &seq)
  {
    do_loop( seq, this );
  }
};

register_rule<laplaceSmoothing_default> register_laplaceSmoothing_default;

class laplaceSmoothing_advance : public pointwise_rule{
  store<double>         fnew;
  const_store<double>   fold;
  const_Map             leftmap, rightmap;
public:
  laplaceSmoothing_advance() {
    name_store( "smooth{n}",  fold );
    name_store( "interior::smooth{n+1}",fnew );
    name_store( "LeftConnect",  leftmap);
    name_store( "RightConnect", rightmap);
    
    input ("LeftConnect->smooth{n}");
    input ("RightConnect->smooth{n}");

    output("interior::smooth{n+1}");
  }
  void calculate( Entity e){
    int    n1, n2, n3, n4;
    n1      = leftmap[e];
    n2      = rightmap[e];
    fnew[e] = (fold[n1] + fold[n2])/2.0;
  }

  virtual void compute( const sequence &seq)
  {
    do_loop( seq, this );
  }
};

register_rule<laplaceSmoothing_advance>
              register_laplaceSmoothing_advance;

\end{verbatim}

\par Notice that priority rules are specified by using interior::smooth{n+1}.
Here the name interior is immaterial, we can choose any other name. Without
the use of :: this program will not even compile, because Loci will notice
two rules for computing the new facts, which is prohibited by Loci. 

{\par \em  Whether the priority rules are executed before the normal rules
or after, it is up-to Loci to decide about it, which is immaterial from users' point of view }

\section {Can we avoid priority rules ? }

In the above example, a priority rule was a must in order to produce the
desired result, but could we avoid priority rule altogether, and if yes,
how ? If we closely examine the above code, a priority rule was required
because we never distinguished between the internal nodes and boundary nodes,
and because of this, we had to provide a priority rules, which applies 
a default behavior to all the entities, before (or after) it apply rules
for the internal nodes. But we could have classified nodes into two 
groups and could have created two pointwise rules one for the internal
nodes, and other for the boundary nodes. So we can get the same results
with on the expense of creating two group. 
\par Which method is better, it depends on the user's liking.

\section{ Stationary Rule}
Consider the ideal gas law for the mixture of thermally perfect gases
\begin{equation}
p = \rho R T
\end{equation}
This equation establishes a relationship of pressure to density, temperature
and mixture gas constant. This relationship is universal, it applied to
any place where these properties are simultaneously available at any 
instant to time. This law can be represented by the rule signature
\begin{equation}
p = \leftarrow \rho,  R , T
\end{equation}
\par This rule signature signifies that a value for the pressure can be
generated from values for density, temperature and density.  A Rule which is 
independent of iteration identifier is called a {\bf Stationary Rule}
\par In reality the scope of stationary rules is much wider than what is
described earlier.  All rules which are not in any iteration could also be
termed as {\em Stationary Rules }
%
\section{ Time Promotion Rule}
As explained in earlier section, Stationary rules are general rules in
space and time, which means that they can be used either as stand-alone
rules or in iteration hierarchy. If these rules are applied with {}, which
signifies the iterations, Loci will automatically promote these rules
in time. A time promoted facts don't require initialization of the values.
%
\section { Understanding operators $\rightarrow$ and $\leftarrow$ }
Consider Loci as a fine grain programming model, where each rule require need to 
know only those facts from the database, which it really requires. When we specify
rules, which iterative over an entities, which have map, then there must be 
some mechanism to access the data associated with the mapped entities. In Loci,
this is done using $\rightarrow$ operator, which is sometimes termed as {\em fetch
operator}

\par When we write "triConnect $\rightarrow$ pos", it means that triConnect is a map (
any kind of map i.e. Map, MapVec or Multimap) and its mapped values will be used
to fetch the values of {\em pos} from the fact database.

As oppose to fetch operator $\rightarrow$, which is just used as to fetch the 
stored data from the database, $\leftarrow$ is an assignment operators, which
means a new facts is created and need to be store in the fact database. 
\par For example, we would like to calculate centroid of a cell which 
requires a map, which stores the neighboring nodes, which in turn store the
coordinates of the nodes. We can specify the rule as
\begin{center}
Centroid $\leftarrow$ CellConnect $\rightarrow$ pos
\end{center}

There is no upper limit of using these indirection operators to assign or 
fetch the data.

The $\rightarrow$ is a powerful operator which allows recursion. A recursive
statements call themselves. For example a simple execution of statement 
$ a \rightarrow b$ is deferred till $b$ can be generated by some rule, the
generation of $b$ is another rule, which is again deferred till we find
one rule which can generate the $b$. Once one $b$ is available, {\bf backtracking}
takes over and we get the final result. In fact, many algorithms are inherently
recursive (even if the user is unaware of them), Loci will generate a correct
sequence if there is one rule, which can generate the base value.

\section { Queries }
Loci is {\bf Goal Oriented } language. At the end of any simulation, you want to
generate or transform some facts. In Loci, {\bf Query} is used to specify the outcome
facts. Loci, will generate a correct code with the supplied facts and rules, if
the query facts can be generated. A used may provide many rules and facts, but if 
they are not needed to generate the query facts, then Loci
will prune those rules and a scheduler will not execute those rule. This is unlike
C/C++ programming, where every procedure is called, whether its execution is 
required or not, to produce the final results.
\section { Memory Management in Loci }
If you notice carefully, when we define rules, which create new facts, we
have not not allocated any memory for the new facts. It is not required
from the user to allocate memory for the new facts, Loci will internally
allocate necessary memory for you. 

\section { Writing programs in Loci } 
Developing new application using Loci is very easy.  The most important 
step in developing Loci program is the identification of entities and
relationship. There are many ways to do this. Once you have decided
judiciously, an application uses the following five steps.
\begin{enumerate}
\item { Specify query variables }
\item { Create facts and store them in facts database }
\item { Create Rules and store them in rules database }
\item { Create and execute schedule}
\item { Query the fact database }
\end{enumerate}

\section { Before you write your own program}
\begin{itemize}
\item Decide about the entities and their relationship with other entities.
\item Specify the queries before you run the program.
\item All entities within the program has unique identifier. It is user's 
responsibility to provide unique numbering.  
\item All reduction operations are broken into two rules, ie. {\em unit\_rule} and 
{\em apply\_rule}
\item Stationary rules don't require brace limiters.
\item Time promotion in Loci is automatic.
\item All iteration require three rules i.e. build, advance and collapse.
\item Currently, Loci doesn't support Polymorphism for the rules, so you 
have to create rules for each datatype.
\end{itemize}

\par When you write rules, consider the followings 
\begin{itemize}
\item  What is the context of the rule, or in other words, over which
entities, the rule will be created. 
\item  For the entities in the rule context, what is the mapped entities.
\item  How the value are accessed. If there are maps involved, the 
       values are accessed using indirection
\end{itemize}

\section { Loci Programs }
\subsection { Program 1 }
\begin{verbatim}
int main(int argc, char *argv[]) 
{
  
  string query = "Data";

  param<int>  n;
  fact_db        facts ;                      // Facts Database
  
  *n = 10;
  facts.create_fact( "N", n);

  entitySet  aset = interval(1,*n);

  entitySet  start;
  store<int> startEntity;

  start += 1;
  startEntity.allocate( start );
  facts.create_fact( "StartEntity", startEntity);

  Map       predecessor;
  predecessor.allocate(aset);

  for( int i = 1; i <= *n; i++)
      predecessor[i] = i-1;

  facts.create_fact( "Predecessor", predecessor);

  rule_db    rdb ;                  // Rule Database
  
  rdb.add_rules(global_rule_list) ;

  executeP schedule = create_execution_schedule(rdb,facts,query ) ;

  if(schedule != 0) schedule->execute(facts) ;

  schedule->Print(cout) ;
  
  Loci::variableSet query_vars( Loci::expression::create(query));

  return 0 ;
}

//********************************************************************

class Recursive_Base : public pointwise_rule {
  const_Map    predecessor;
  store<int>   data;
public:
  Recursive_Base() {
    constraint( "StartEntity" );        // Apply this rule only one entity.
    name_store( "Predecessor", predecessor );
    name_store( "Data",  data );

    input( "Predecessor" );

    output( "Data" );
  }

  void calculate( Entity e) {
      data[e]   = e;
  }

  virtual void compute(const sequence &seq){
    do_loop( seq, this );
  }
};

register_rule<Recursive_Base>  register_Recursive_Base;

//********************************************************************

class ForwardSequence : public pointwise_rule {
  store<int>    data;
  const_Map     predecessor;
public:
  ForwardSequence() {
    name_store( "Predecessor", predecessor );
    name_store( "Data",        data );

    input( "Predecessor->Data" );        // Recursive definition.
    output( "Data" );
  }

  void calculate( Entity e) {
     data[e]   = e;
  }

  virtual void compute(const sequence &seq){
    do_loop( seq, this );
  }
};

register_rule<ForwardSequence>  register_Forward_Sequence;

//********************************************************************
\end{verbatim}

\subsection { Program 2 }

\begin{verbatim}
int main(int argc, char *argv[]) 
{
  
  string query = "Data";

  param<int>  n;
  fact_db        facts ;                      // Facts Database
  
  *n = 10;
  facts.create_fact( "N", n);

  entitySet  aset = interval(1,*n);

  entitySet  start;
  store<int> startEntity;

  start += *n;
  startEntity.allocate( start );
  facts.create_fact( "StartEntity", startEntity);

  Map    successor;
  successor.allocate(aset);

  for( int i = 1; i < *n; i++)
      successor[i] = i+1;

  facts.create_fact( "Successor", successor);

  rule_db    rdb ;                  // Rule Database
  
  rdb.add_rules(global_rule_list) ;

  executeP schedule = create_execution_schedule(rdb,facts,query ) ;

  if(schedule != 0) schedule->execute(facts) ;

  schedule->Print(cout) ;
  
  Loci::variableSet query_vars( Loci::expression::create(query));
  
  return 0 ;
}

//*********************************************************************

class Recursive_Base : public pointwise_rule {
  const_Map    successor;
  store<int>   data;
public:
  Recursive_Base() {
    constraint( "StartEntity" );
    name_store( "Successor", successor );
    name_store( "Data",      data );

    input( "Successor" );

    output( "Data" );
  }

  void calculate( Entity e) {
      data[e]   = e;
  }

  virtual void compute(const sequence &seq){
    do_loop( seq, this );
  }
};

register_rule<Recursive_Base>  register_Recursive_Base;

//********************************************************************

class BackwardSequence : public pointwise_rule {
  store<int>    data;
  const_Map     successor;
public:
  BackwardSequence() {
    name_store( "Successor", successor );
    name_store( "Data",        data );

    input( "Successor->Data" );
    output( "Data" );
  }

  void calculate( Entity e) {
     data[e]   = e;
  }

  virtual void compute(const sequence &seq){
    do_loop( seq, this );
  }
};

register_rule<BackwardSequence>  register_BackwardSequence;

\end{verbatim}

