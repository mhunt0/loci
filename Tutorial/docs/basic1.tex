\chapter{ Basic Concepts }

\section {Interval}
An {\em interval } is a pair of integers which denotes the beginning and the
end of a set of integer values.
\par {\bf Example } interval(-100,100) is a set of number from -100, -99, \dots 0 \dots 99, 100


%
\section{Entity}
\par  An {\em entity} is a "thing" or "object" in the real world that
is distinguishable from all other objects. For example, each person in 
an enterprise is an entity. An entity has a set of properties ( a person
has name, age, sex etc), and the
values for some set of properties may uniquely identify an entity. For
example, the social-security number 677-89-9011 uniquely identifies
one particular person in United States. {\bf In Loci, each entity is given
a unique integer value as an identifier}.
%
\section{Entity Set} 
\par An {entity set } is a set of entities of the same type that share 
the same properties, or attributes. An entity need not be disjoint, which means that 
it can belong to more than one entitySet.  The set of all persons who are
customers at a given bank, for example, can be defined as the entity
set {\em customer}.
%
\par The unique identification of entities in an entity set allows
efficient control and memory management. In Loci, an entity set functionality is provided by 
the class {\em entitySet}.  This class provides basic set operations such as union, 
intersection, and complement by overloading the operators ${\&}$, ${|}$, and ${-}$
respectively.  In fact, all of the bitwise operators are overloaded
such that an {\em entitySet} has the appearance of a large bit string.
%
\begin{figure}[ht]
\special{psfile=entitySet.eps vscale=65 hscale=65 voffset=-250 hoffset=1}
\vspace{3.5in}\caption { An EntitySet is a collection of entities}
\label {FigEntitySet}
\end{figure}
%
\par{\bf Example} Suppose we are given a grid as shown in Figure \ref{FigEntitySet}
At each vertex ( or node), we are given coordinates and some scalar value
(for example density). For this case, every vertex is an entity where
some values have to be stored. 
%
Since Figure \ref{FigEntitySet}A has contiguous vertex identifiers, we can define an
entitySet {\em vertex} using 
\begin{verbatim}
entitySet vertex = interval(1,36);
\end{verbatim}

An entity set need not have contiguous numbering. For example, we can create an entityset
of boundary entities as

\begin{verbatim}
int  numVertex = 20;
int  nodeID[] = { 1,2,3,4,5,6,7,12,13,18,19,24, 25,30,31,32,33,34,35,36}
for( i = 0; i < numVertex; i++)
     vertex  +=  nodeID[i];
\end{verbatim}

Representation of entities with non-contiguous numbering is a general and robust 
way of identifying the entitySet.

\par In an application, there could be many entities such as nodes, cell, 
faces and edges.  {\bf In Loci, entity identification is unique, irrespective
of context in which they are used.}. Therefore, if we assign node entitySet from 0..N,
then cell entitySet will start from $(N+1, N+2......N+M)$ and face entitySet from $(N+M+1,...N+P)$
and so forth.

\par One can iterate over the set of integers stored in the {\em entitySet} by 
using {\em entitySet::const\_iterator}
\par {\bf Example}
\par A = interval(1,10)       // contains an interval from 1 to 10.
\begin{verbatim}
for( entitySet:: const_iterator ei = A.begin(); ei != A.end(); ei++)
     cout << *ei << "   ";
cout << endl;
\end{verbatim}
The member functions {\em begin()} and {\em end()} mimic the semantics of the STL
containers types. {\em A.begin()} points to the first element in the interval while
{\em A.end()} returns a pointer to the location beyond the last element in the 
interval. The de-referencing operator {\bf *()} can be used to return the value of 
the corresponding integer identifier. 

\par There are many operations, such as union, intersection etc can be defined 
over an entitySet. The following program demonstrates the use of entitySet class 
with set operations.

\begin{verbatim}
int main()
{
    entitySet     A,B,C,D,E;

//  Assign set A to interval [1,10], B[5,20]
    A  =  interval(1,10);
    B  =  interval(5,20);

//  Adding 2 to set A ( Note that it is already in A), but there
//  will not be duplication    
    A   +=   2;

//  Remove 5 from A
    A   -=   5;

//  Intersection ( Output: all elements which are common to A and B)
//  In this case (6,7,8,9,10).
    C  =  A & B;

//  Union ( Output: All elements which are both A and B )
//  This case ( 1,2,3,       18,19,20)
    D  =  A | B;

//  Replace A with itself, but remove elements in B;
    E  = A - C;

//  Empty the entity Set
    A  = EMPTY;
}
\end{verbatim}
\par There are many member function with {\em entitySet} which are provided in the
Appendix A.
\section  { Maps }
An {\em entity} has an independent existence, but it is the relationship 
with other entities that makes an entity important and useful. For example,
a bank and a person are totally independent entities, but a relationship between
the bank with the person makes bank more useful and objective. In a database,
such a relationship is defined using {\bf Relationship Set} or {\bf Maps}. 
If we have two entitySets $A$ and $B$ the relationship between two entitySets
could have following options

\begin{itemize}
\item {\bf One to one} An entity in A is associated with at most one 
entity in B, and an entity in B is associated with at most one entity in A.(
See Figure \ref{FigMap1})
%
\item {\bf One to many} An entity in A is associated with any number of 
entities in B. An entity in B, however, can be associated with at most one
entity in A. (See Figure \ref{FigMap1})
%
\item {\bf Many to one} An entity in A is associated with at most one
entity in B. An entity in B, however, can be associated with any number of
entities in A ( See Figure \ref{FigMap2})
%
\item {\bf Many to many} An entity in A is associated with any number of
entities in B, and an entity in B is associated with any number of 
entities in A. ( See Figure \ref{FigMap2} )
\end{itemize}

\begin{figure}[h]
\special{psfile=map1.eps vscale=40 hscale=40 voffset=-150 hoffset=75}
\special{psfile=map2.eps vscale=40 hscale=40 voffset=-150 hoffset=220}
\vspace{2.0in}\caption {(a) One to One. (b) One to many}
\label{FigMap1}
\end{figure}

\begin{figure}[h]
\special{psfile=map3.eps vscale=40 hscale=40 voffset=-150 hoffset=75}
\special{psfile=map4.eps vscale=40 hscale=40 voffset=-150 hoffset=220}
\vspace{2.1in}\caption { (a) Many to one. (b) Many to many.}
\label{FigMap2}
\end{figure}

\par In Loci, three types of maps are provided, which are as follows

\begin{enumerate}
\item {\bf Map}  provides a single relationship.
\item {\bf MapVec $<N>$} provides a constant number of relationship, which are 
known a-priori at the time of compilation for each entity in an entitySet.
\item {\bf multiMap} provides a variable number of relationship for each 
entity in an entitySet.
\end{enumerate}

\par The allocation of {\em Map} and {\em MapVec} is done with the entitySet
directly, while {\em multiMap} require one more intermediate stage. An
array which stores the number of relationship is created, which it 
created using the entitySet, this array is passed to allocate memory
for a multiMap.  
\par A zero valence is allowed,which implies that no relationship exists.
%
\par One important thing about Loci is that it can't create maps by its own.
Loci requires all the relationship be present when it create a schedule. Although
such a restriction is quite severe for adaptive grids, where some new entities
are generated and some old entities dies so relationship are created and
destroyed dynamically. This feature will be explored in the future,
but as of now, Loci strictly requires all relationship at compile time.
%
\par A user may provide more relationship than what is really required to 
create a schedule. Providing redundant relationships do not cause any harm,
except that they may hog memory of your machine. 
%
\par An identification of an entity and its relationship with other entities
plays an important role in the overall performance of the code. There is always
a tradeoff between memory requirement and CPU performance in any application.
Later, we will show with examples, that it is possible to get the same results using
two different entities and their associated maps.

\par In Loci, relationships are bidirectional.  For example. if e1 has relationship
with e2 then e2 will also have relationship with e1. In many traditional programming, 
because of memory constraints, both the relationship are not required to be stored, 
only one is sufficient and other could be derived, but in Loci since maps cannot
be generated, it is important that e1 should contain e2 and vice versa.

\section { Graph }
A graph is a finite set of vertices ( or nodes) connected by links called edges. 
In CFD/FEM applications, every mesh ( structured or unstructured ) could be 
presented by a graph. The degree ( or valence ) of a vertex is defined as the
number of edges that {\em ends} at that vertex.  

\begin{figure}[h]
\special{psfile=step.eps vscale=70 hscale=70 voffset=-350 hoffset=-10}
\vspace{2.0in}\caption { An unstructured grid is used in CFD/FEM simulation }
\label{FigGraph}
\end{figure}

\par In the Figure \ref{FigGraph} we have shown one unstructured grid consists of
many non-overlapping triangles. Such a grid is often used when the shape of the geometry 
is more complex. Such a grid can be viewed as a collection of cell, faces, edges
and nodes entities. In Loci, maps could be used to create relationship among the
entities.  
\begin{itemize}
\item Each {\em cell entity} has relationship with a set of {\em face entities}.
\item Each {\em face entity} has relationship with a set of {\em edge entities}
\item Each {\em edge entity} has relationship with a set of {\em node entities}
\end{itemize}
Such hierachial relationships uniquely specify a given graph,
which we use to simulate a CFD/FEM applications. Depending on the application, 
we may build additional relationship among the entitySet. For example, we may 
create a relationship between a node entity and cell entities, which will give 
us information about cell entities which are neighbors to node entities.

\par At this point, it is important to know that there is an entire different
philosophy of solving PDEs which are based on structured grids. The structured
grids differs from unstructured grid in the way information about neighboring
entities are known. In a structured grid, all the relationship among the
entities can be evaluated implicitly and therefore there is no need to store
them in computer memory. For example, at a grid point $(i,j)$, in a structured
grid, we know that $(i+1,j)$ is the east neighbor, $(i,j+1)$ is the north
neighbor and so on. {\bf Loci, is based on unstructured grid philosophy,
therefore, even for structured grids all the relationship among the entities
must be created and stored in the database.} In other words, in Loci, all 
structured grids calculations must be done in the way unstructured grid
calculations are performed.


\begin{figure}[ht]
\special{psfile=rel1.eps vscale=45 hscale=45 voffset=-200 hoffset=100}
\vspace{2.80in} \caption {Cell-Cell relationship in an unstructured grid}
\special{psfile=rel2.eps vscale=45 hscale=45 voffset=-210 hoffset=100}
\vspace{2.90in} \caption { Cell-Face relationship in an unstructured grid}
\special{psfile=rel3.eps vscale=45 hscale=45 voffset=-220 hoffset=100}
\vspace{3.00in} \caption { Cell-Node relationship in an unstructured grid}
\end{figure}
%
\section {Constraint}
Sometimes, we would like to apply certain operations only to the selected entities, 
in those case we can {\em constraint} identifier to filter out entities.

\begin {center}
B = Z constraint A = Z $\mid $ A $\equiv $ A
\end {center}

\par Where Z is an entitySet of universe consists of all possible integer
supported by machine [-MIN\_INTEGER, MAX\_INTEGER ].

If a rule is applicable to all the possible entities, we can use "universe"
identifier to constraint.

\begin{verbatim}
constraint ("UNIVERSE");
\end{verbatim}

\begin{figure}[h]
\special{psfile=const.eps vscale=65 hscale=65 voffset=-200 hoffset=175}
\vspace*{2.80in}\caption {A constraint could be used for filtering out entities }
\label{FigConstraint}
\end{figure}

\par {\bf Example} In the Figure \ref{FigEntitySet}, suppose we would like to 
apply 5 point stencil only on the internal entities (i.e. vertices) and on the 
boundary entities, we would like to apply one-sided rules. When we define a 
rule, we can use constraint to block boundary cells.

constraint (internalSet);

%
\section { How to use maps in Loci}
\begin{figure}[h]
\special{psfile=maps.eps vscale=80 hscale=80 voffset=-145 hoffset=1}
\vspace{2.1in}\caption { A map is used to specify relationship among
entities }
\label{FigMaps}
\end{figure}
%
Using Figure \ref{FigEntitySet}A, let us assume that for our application,
we need to know all the nodes which are surrounding a given node. Now for
a node entity, the following cases must be considered.
\begin{enumerate}
\item  All the corner vertex have 2 neighboring vertex.
\item  All the boundary vertex (excluding corners) have 3 neighboring vertex.
\item  All the internal vertex (excluding corners) have 4 neighboring vertex.
\end{enumerate}
%
\par We can use {\bf maps} to define the relation between the vertex and
neighbor vertex using either approach.
%
\begin{enumerate}
\item { \bf Using Map }   If we want to create a single relationship with 
each entity, then we can use Map. In this case, we can define four maps
i.e. eastmap, westmap, northmap and southmap for an entity. All entities
which have some entity in the east are included  in the eastmap, all
entities which have north neighbors is included in northmap, and so on.

\begin{verbatim}

entitySet  allnodes = interval(1,36);

// Define east map

entitySet  eastSet;

eastSet -=  6;
eastSet -= 12;
eastSet -= 18;
eastSet -= 24;
eastSet -= 30;
eastSet -= 36;

eastmap.allocate( eastSet );

for( entitySet:: const_iterator ei = eastSet.begin(); ei != eastSet.end(); ei++)
     eastmap[*e1] = *e1 + 1;

// Define West map
entitySet  westSet = allnodes;

westSet -=  1;
westSet -=  7;
westSet -= 13;
westSet -= 19;
westSet -= 25;
westSet -= 31;

westmap.allocate( westSet );

for( entitySet:: const_iterator ei = westSet.begin(); ei != westSet.end(); ei++)
     westmap[*e1] = *e1 - 1;

// Define North  map
entitySet    northSet = allnodes;

northSet -= 31;
northSet -= 32;
northSet -= 33;
northSet -= 34;
northSet -= 35;
northSet -= 36;

northmap.allocate( northSet );

for( entitySet:: const_iterator ei = northSet.begin(); ei != northSet.end(); ei++)
     northmap[*e1] = *e1 + xnodes;

// Define South  map
entitySet    southSet = allnodes;

southSet -= 1;
southSet -= 2;
southSet -= 3;
southSet -= 4;
southSet -= 5;
southSet -= 6;

southmap.allocate( southSet );

for( entitySet:: const_iterator ei = southSet.begin(); ei != southSet.end(); ei++)
     southmap[*e1] = *e1 - xnodes;

\end{verbatim}
%
\item {\bf Using MapVec$<N>$ }  If we define const valence map, then we have to 
create three maps, cornerMap$<2>$, boundaryMap$<3>$ and internalMap$<4>$ of 2,3 and
4 valence respectively.  Using non-contiguous entitySet case.
\begin{verbatim}
entitySet  cornerSet;
MapVec<2>  cornerMap;
int cornerID[] = { 1,6,31,36};

for( i = 0; i < 4; i++)
     cornerSet  +=  cornerID[i];

cornerMap.allocate( cornerSet );

cornerMap[1] = 10;        // right
cornerMap[1] = 11;        // top
.
.
entitySet    boundarySet;
MapVec<3>    boundaryMap;

int boundID[] = {2,3,4,5,7,12,13,18,19,24,25,30,32,33,34,35};
for( i = 0; i < 16; i++)
     boundarySet  +=  boundID[i];

boundaryMap.allocate( boundarySet );

boundaryMap[13][0] = 14; 
boundaryMap[13][1] =  7; 
boundaryMap[13][2] = 19; 
.
.
entitySet internalSet;
int internalID[] = {8,9,10,11,14,15,16,17,20,21,22,23,26,27,28,29};

for( i = 0; i < 16; i++)
     internalSet  +=  internalID[i];

internalMap.allocate( internalSet );
internalMap[16][0] = 17;     // right
internalMap[16][1] = 15;     // left
internalMap[16][2] = 22;     // top
internalMap[16][3] = 10;     // bottom
\end{verbatim}
%
\item {\bf multimap}  Using multimap, we can create a single map to define the
relationship. In this example, note that multimap allocation is two step process,
first we have to create an array which stores the degree of each node and multimap
use this array for the allocation purpose.
%
\begin{verbatim}
store<int>  neighSize(vertex};
neighSize[1]  = 2;
neighSize[6]  = 2;
.
.
neighSize[7]  = 3;
neighSize[30] = 3;
.
.
neighSize[8]  = 4;
neighSize[29] = 4;
.
.
\end{verbatim}
%
\begin{verbatim}
multiMap     neighmap;
neighmap.allocate(neighSize);

neighmap[1][0] = 2;
neighmap[1][1] = 7;
.
.
neighmap[3][0] = 4;
neighmap[3][1] = 2;
neighmap[3][2] = 9;
.
.
neighmap[9][0] = 10;
neighmap[9][1] =  8;
neighmap[9][2] = 15 ;
neighmap[9][3] =  3;
.
.
\end{verbatim}
\end{enumerate}
\subsection{ MapVec or Multimap: which method is better ? }
\par Remember that {\em multiMap} is a generalization of {\em MapVec } and {\em Map}, 
so everything you wish to do with the later could be done with former as well, but
\begin{itemize}
\item  If you know the number of relationship, a-priori, then using {\em mapVec$<N>$} 
will be advantageous, otherwise {\em multimap} is the only choice. 
\item  If your application doesn't is not very specific to number of relationships,
then it might be easier ( but may not be efficient ) to create {\em multiMap}.
\end{itemize}

\section { Sequence }
A sequence is an arrangement of items according to a specified set of rules, for
example, items arranged alphabetically, numerically or chronologically. A sequence
is the way of telling the computer what to do next.

\par Sequence is the core of Loci framework. In conventional programming like
Fortran, C/C++, we spend too much time in arranging the order and checking for
the correctness. Loci, takes away this drudgery from the users and creates and
control all the sequence by itself.

In general, entities are traversed in the order in which they were defined, but
Loci, may consider it necessary to reorder these entities to produce correct
sequence. For example, recursive process require a sequence in a particular
order, which may not be correctly provided by the user. Loci, produces 
correct sequence by analyzing the dependency of each entity with other entities.

\section { Attributes }
An entity is represented by a set of {\em attributes}. Attributes are descriptive
properties possessed by each member of an entity set.  Some possible attributes
of the {\em customer } entity set for a bank are {\em customer-name, 
social-security, customer-street and customer-city }

\par Consider the biological system, in which each living thing is an entity,
but what makes elephants differ from tigers ? Definately, distinct properties
associated with each group makes them distinguishable. 

%
\par Formally, an attribute of an entity set is a function that maps from the entity
set into a domain. Since an entity set may have several attributes, each entity
can be described by a set of( attribute,data value) pairs, one pair for 
each attribute of the entity set. 
%
Beside having distinct properties, entities in an entitySet can have global
properties, which are same for each entity in that set. For an example, 
interest rate is a global parameter, which remains same for each customer
of a bank. 

\par In Loci, {\em store} and {\em parameter} are two classes to assign
attributes of an entity. The {\em store } class stores properties which
are unique to an entity, whereas {\em parameter} class provides attributes
which are global to an entity set.

\subsection{Store}
The {\em store} is a container that allows the association of values
to entities given in an {\em entitySet}.  One can think of the {\em
store} as an array where the bounds are specified by an given
entitySet.  Once the store is constructed, the array is allocated by
use of the {\em allocate() } method. The elements of a {\em store} are 
accessed using the traditional C array operator. One major difference
between build in arrays or STL vector with {\em store }  is that
store don't have contiguous identifier, still they behave like arrays/vectors. 
In store, identifiers set with an entitySet. 

\par Since {\em store} is a template class for datatype, any standard datatype( 
float, double, int, string etc ) are valid datatypes. Beside, these standard datatype
Loci provides two additional datatype which are often require in the numerical simulation
of PDEs.

\par {\bf storeVec } A {\em storeVec} provides a way of allocating vectors. The member 
function {\em allocate()} and {\em initialize()} are similar to those 
defined for the standard store. The size of the {\em storeVec} is
specified at the runtime through the method {\em setVecSize()}.
\par {\bf Example} Suppose for an entity {\em e} we would like to define an array
of size ${n}$. And the values are given $(1.0,2.0,3.0,.....n)$. 
\begin{verbatim}
storeVec<float>  myVector;      // Declaration of store-Vector
myVector.setVecSize(5);         // Allocation of size 5;
myVector[e][0] = 1.0;           // Assignment of values 
myVector[e][1] = 2.0;
myVector[e][2] = 3.0;
myVector[e][3] = 3.0;
myVector[e][4] = 3.0;
\end{verbatim}

\par A {\bf storeMat} provide a way of allocating square matrices. The 
size of matrix is specified at runtime using the {\em setVecSize()}
\par {\bf Example} Suppose for an entity {\em e} we would like to define a matrix
of size ${n \times n}$. And the values are given $(1.0,2.0,3.0,.....n)$. 
%
\begin{verbatim}
storeMat<float>  myMatrix;      // Declaration of store-Vector
myMatrix.setVecSize(3);           // Allocation of Matrix of size 3X3
// First Row
myMatrix[e][0][0] = 1.0;           // Assignment of values 
myMatrix[e][0][1] = 2.0;
myMatrix[e][0][2] = 3.0;

// Second Row
myMatrix[e][1][0] = 4.0;           // Assignment of values 
myMatrix[e][1][1] = 5.0;
myMatrix[e][1][2] = 7.0;

// Third Row
myMatrix[e][2][0] = 7.0;           // Assignment of values 
myMatrix[e][2][1] = 8.0;
myMatrix[e][2][2] = 9.0;
\end{verbatim}

\par {\bf Example} From the previous example, let us assume that at 
each vertex, some scalar( or vector ) data are given. In order to store
the values we define
\begin{verbatim}
store<double>  density
\end{verbatim}
The {\em density } at each vertex is associated with the entity. So
the easiest way to allocate memory is using the entitySet over which this
variable is defined. i.e.
\begin{verbatim}
density.allocate(vertex}
\end{verbatim}

\par In order to protect the data in the database from potentially damaging,
accidental changes, Loci provide data to be accessed in read-only mode. 
%  
\par {\bf const\_store }A {\em const\_store} is also provided when
read only access to an array is required.
%  
\par A {\bf const\_storeVec} is  provided for read-only access to a storeVec is required.
%. 
\par A {\bf const\_storeMat} is provided for read-only access to a storeMat is required

\par Loci is very strict about the intention of user. If the data don't change with
the application of a rule, should always be declared as const. 

\par Notice that  allocation is {\em store} is done using an {\em entitySet}
not using number of elements. The reason is very simple, in Loci we are not
assuming contiguous numbering, and without the use of {\em entitySet} there
is no way by which we could have associated values to each named entity.

\subsection { Some more convenient datatype }
\par Since each data from the store is accessed using entity identifier, sometime
it is useful to provide helper classes, which allows operation with the data. 
The presence of entity identifier may prohibit us from using standard libraries.
Loci has provides some helper datatype, which users may find useful in many
applications.
\begin{itemize}
\item {\bf Scalar} This is a helper class provided with Loci, it is used in conjecture
with store class.

\begin{verbatim}
Scalar<double>    scalar(2.0);
\end{verbatim}

\item {\bf vector2d}
\begin{verbatim}
 vector2d<double>    aVec, bVec, crossProd, eVec;
 double              dotProd;

 aVec.x = 1.0;
 aVec.y = 0.5;

 bVec.x = 0.5;
 bVec.y = 0.8;

 dotProd   = dot(aVec, bVec );      //  dot product of 2 vectors
 crossProd = cross( aVec, bVec );   //  cross product of 2 vectors
 norm      = norm( aVec );          //  norm of a vector
 aVec     *= 0.2;                   //  multiply all elements
 aVec     /= 2.0;                   //  divide all elements
 aVec     += 0.2;                   //  add to all elements
 aVec     -= 0.2;                   //  subtract from all elements
\end{verbatim}

\item {\bf vector3d}
\begin{verbatim}
 vector3d<double>    aVec, bVec, crossProd, eVec;
 vector3d<double>    cVec(1.0, 1.0, 1.0);
 double              dotProd;

 aVec.x = 1.0;
 aVec.y = 0.5;
 aVec.z = 0.9;

 bVec.x = 0.5;
 bVec.y = 0.8;
 bVec.z = 0.2;

 dotProd   = dot(aVec, bVec );      //  dot product of 2 vectors
 crossProd = cross( aVec, bVec );   //  cross product of 2 vectors
 norm      = norm( aVec );          //  norm of a vector
 aVec     *= 0.2;                   //  multiply all elements
 aVec     /= 2.0;                   //  divide all elements
 aVec     += 0.2;                   //  add to all elements
 aVec     -= 0.2;                   //  subtract from all elements
\end{verbatim}
%
\item {\bf Array} This is a general purpose class, which could be used anywhere in
the application, where continuous memory blocks are required.

\begin{verbatim}
Array<double,5>   aArray, bArray;  // Allocate an array of double and size 5
aArray[0]  = 1.0;             
aArray[1]  = 2.0;
aArray[2]  = 3.0;
aArray[3]  = 4.0;
aArray[3]  = 5.0;

bArray     = aArray;

aArray    += bArray;
aArray    -= bArray;
aArray    *= bArray;
aArray    /= bArray;
\end{verbatim}

\item {\bf Mat} This is a helper class which is used in conjecture with the {\bf
storeMat} class. It is simply used as an accessory of the matrix associated
with storeMat. This class doesn't perform memory allocation/deallocation
etc, which are performed by storeMat. But once storeMat is defined, Mat class
could be used to create an object and perform simple operations on it. Its
use as an stand-alone class is limited.

\begin{verbatim}

 double        a[9], b[9];
 Mat<double>   amatrix(a,3), bmatrix(b,3);
 Scalar<double> scalar(2.0);

 amatrix[0][0] = 1.0;
 amatrix[0][1] = 1.0;
 amatrix[0][2] = 1.0;

 amatrix[1][0] = 2.0;
 amatrix[1][1] = 2.0;
 amatrix[1][2] = 2.0;

 amatrix[2][0] = 3.0;
 amatrix[2][1] = 3.0;
 amatrix[2][2] = 3.0;

 bmatrix = amatrix;

 bmatrix += amatrix;
 bmatrix -= amatrix;

 bmatrix  = scalar;
 bmatrix += scalar;
 bmatrix -= scalar;
 bmatrix *= scalar;
 bmatrix /= scalar;
\end{verbatim}
\end{itemize}

\subsection { Array: A new look}
\par In conventional C/C++ languages, an array is an homogeneous allocation
of certain datatype in memory. For example, we allocate an array of double
datatype in C++ as
%
\begin{verbatim}
someArray =  new double[myArraySize];
\end{verbatim}
and access each member of an array using [], where [] requires an unique integer 
identifier of the array. But what is so sacrosanct about using a contiguous
numbering ? Now let us define an array in a more abstract way as follows
%
\begin{equation}
   x = {(i,x_i), i \in Z }
\end{equation}
\par In the above equation the variable $x$ is described by a set of 
ordered pairs where the first entity is the identifier, where the second
entity is the value bound to that entity. Using this notation, the 
continuous nature of an array elements gets blurred.  In Loci, the 
$i$ represents an entity and $x_i$ represent any data associated with
the entity.
%

\subsection{Parameter}
Using parameter class, we can specify attributes to an entity which
remains same for each entity in the entity set.
%
\begin{figure}[hp]
\special{psfile=param.eps vscale=40 hscale=40 voffset=-120 hoffset=50}
\vspace{1.8in}\caption { A parameter is shared by many entities }
\label{FigParameter}
\end{figure}
%
\par {\bf Examples } There are many user defined variable such as {\em maxIteration,
Reynolds number, heat coefficients etc,} which remains same for all entities
throughout the simulation, such variable are stored as parameters.
\par {\bf const\_param } is a variant of parameter type for read-only purpose.
\begin{verbatim}
param<double>  ReynoldsNumber, heatCoefficient;
param<int>     maxIterations;
\end{verbatim}
The value is accessed by using the dereference operator, {\em'*'}.
\par {\bf Example }
\begin{verbatim}
*ReynoldsNumber = 100000;
*maxIterations  = 100;
\end{verbatim}

\par While reading we can use either $ReynoldsNumber[e]$ or $*ReynoldsNumber$ for an entity.
\par {\bf Example }
\begin{verbatim}
a   =  *ReynoldsNumber;
n   =  *maxIterations;
\end{verbatim}
or
\begin{verbatim}
a   =  ReynoldsNumber[e];
n   =  maxIterations[e];
\end{verbatim}
\par Where $e$ is an entity.

\section { Understanding operators $\rightarrow$ and $\leftarrow$ }
Consider Loci as a fine grain programming model, where each rule require need to 
know only those facts from the database, which it really requires. When we specify
rules, which iterative over an entities, which have map, then there must be 
some mechanism to access the data associated with the mapped entities. In Loci,
this is done using $\rightarrow$ operator, which is sometimes termed as {\em fetch
operator}

\par When we write "triConnect $\rightarrow$ pos", it means that triConnect is a map (
any kind of map i.e. Map, MapVec or Multimap) and its mapped values will be used
to fetch the values of {\em pos} from the fact database.

As oppose to fetch operator $\rightarrow$, which is just used as to fetch the 
stored data from the database, $\leftarrow$ is an assignment operators, which
means a new facts is created and need to be store in the fact database. 
\par For example, we would like to calculate centroid of a cell which 
requires a map, which stores the neighboring nodes, which in turn store the
coordinates of the nodes. We can specify the rule as
\begin{center}
Centroid $\leftarrow$ CellConnect $\rightarrow$ pos
\end{center}

There is no upper limit of using these indirection operators to assign or 
fetch the data.

The $\rightarrow$ is a powerful operator which allows recursion. A recursive
statements call themselves. For example a simple execution of statement 
$ a \rightarrow b$ is deferred till $b$ can be generated by some rule, the
generation of $b$ is another rule, which is again deferred till we find
one rule which can generate the $b$. Once one $b$ is available, {\bf backtracking}
takes over and we get the final result. In fact, many algorithms are inherently
recursive (even if the user is unaware of them), Loci will generate a correct
sequence if there is one rule, which can generate the base value.


\section {name\_store}
Every rule work on the facts to change or produce new facts. Rules and
facts are described in the next chapter. The {\em name\_store} specify the 
facts which are required by the rule. Although
no harm will be done, if you specify a fact which is not used to create
a new fact, but we should avoid to make the objective of the rule more
concise and elegant.

\par Another way we can think of class {\em name\_store} is that it opens the
files in a database. The syntax of {\em name\_store} is
\begin{center}
name\_store ("Fact", local\_store\_variable\_name)
\end{center}
where "Fact" is the variable name of the fact which is associated with the database,
and {\em local\_store\_variable\_name} is the locally defined name 
of the fact in a rule. 

\par Some conventions for defining facts name in the database.

\begin{itemize}
\item  It is case sensitive
\item  It is not a string, but a variable like any other variable, therefor
       "Fact-New", "Fact+New" are invalid names.
\item  This variable is different from locally defined variable, therefore 
       it is more elegant and acceptable to provide  name\_store("Fact", Fact)
       both the variables seems to have same name, but they are in different
       context.
\end{itemize}

\section { Queries }
Loci is {\bf Goal Oriented } language. At the end of any simulation, you want to
generate or transform some facts. In Loci, {\bf Query} is used to specify the outcome
facts. Loci, will generate a correct code with the supplied facts and rules, if
the query facts can be generated. A used may provide many rules and facts, but if 
they are not needed to generate the query facts, then Loci
will prune those rules and a scheduler will not execute those rule. This is unlike
C/C++ programming, where every procedure is called, whether its execution is 
required or not, to produce the final results.
