#include <Loci.h>

// Setup Types for initial facts
$type il Map ; // interface left
$type ir Map ; // interface right
$type cl Map ; // cell left
$type cr Map ; // cell right
$type x store<float> ; // node positions

// Derived variables
$type xc store<float> ; // cell center
$type L store<float> ;  // cell length
$type u store<float> ;  // Solution variable
$type ub store<float> ; // solution variable at boundary
$type ux store<float> ; // derivative of u (du/dx)
$type residual store<float> ; // steady state residual
$type uflux store<float> ; // flux of u at interface

$type integrateBoundary(X) store<float> ;

// Input parameters
$type max_iteration param<int> ;  // How many timesteps to take
$type N param<int> ;              // How many nodes
$type nu param<float> ;           // diffusion coefficient


// Timestepping control
$type dt param<float> ; // timestep
$type solution store<float> ; // final value
$type simulation_finished param<bool> ; // check for completion


$rule default(N) {
  $N=50 ;
}

$rule default(nu) {
  $nu = 1.0 ;
}

$rule default(max_iteration) {
  $max_iteration = 100 ;
}

//*******************************************************************
//Initializing values at time= 0 using u(x,0) = f(x). Since "xc" is
//used, it will calculate the values are cell-centers.
//*******************************************************************

float f(float xc) {
  return xc*(1-xc) ;
}

$type u_ic store<float> ;

$rule pointwise(u_ic<-xc) {
  $u_ic = f($xc) ;
}


$type EulerIntegrate(X,Y) store<float> ;
$type X store<float> ;
$type Y store<float> ;
$type Y_ic store<float> ;

$rule pointwise(EulerIntegrate(X,Y){n=0}<-Y_ic) {
  $EulerIntegrate(X,Y){n=0} = $Y_ic ;
}

//*******************************************************************
// When simulation is finished, copy current iteration results to
// solution
//*******************************************************************

$rule pointwise(EulerIntegrate(X,Y)<-EulerIntegrate(X,Y){n}),conditional(simulation_finished{n}) {
  $EulerIntegrate(X,Y) = $EulerIntegrate(X,Y){n} ;
}


//*******************************************************************
// Condition that determines when iteration is complete
//*******************************************************************

$rule singleton(simulation_finished<-$n,max_iteration) {
   $simulation_finished = ($$n >= $max_iteration) ;
}
//-------------------------------------------------------------------
// Objective :  Compute u{n+1} based on explicit euler time integration method
//-------------------------------------------------------------------

$rule pointwise(EulerIntegrate(X,Y){n+1}<-EulerIntegrate(X,Y){n},dt{n},X{n},L) {
  $EulerIntegrate(X,Y){n+1} = $EulerIntegrate(X,Y){n}+$dt{n}*$X{n}/$L ;
}

$rule pointwise(Y<-EulerIntegrate(X,Y)),parametric(EulerIntegrate(X,Y)) {
  $Y = $EulerIntegrate(X,Y) ;
}

$rule pointwise(solution<-EulerIntegrate(residual,u)) {
  $solution = $EulerIntegrate(residual,u) ;
}

$rule pointwise(residual<-integrateBoundary(uflux)) {
  $residual = $integrateBoundary(uflux) ;
}

// $rule pointwise(u{n=0}<-u_ic) {
//   $u{n=0} = $u_ic ;
// }
// //*******************************************************************
// // When simulation is finished, copy current iteration results to
// // solution
// //*******************************************************************

// $rule pointwise(solution<-u{n}),conditional(simulation_finished{n}) {
// 	$solution = $u{n} ;
// }


// //*******************************************************************
// // Condition that determines when iteration is complete
// //*******************************************************************

// $rule singleton(simulation_finished<-$n,max_iteration) {
//    $simulation_finished = ($$n >= $max_iteration) ;
// }
// //-------------------------------------------------------------------
// // Objective :  Compute u{n+1} based on explicit euler time integration method
// //-------------------------------------------------------------------

// $rule pointwise(u{n+1}<-u{n},dt{n},integrateBoundary(uflux){n},L) {
//   $u{n+1} = $u{n}+$dt{n}*$integrateBoundary(uflux){n}/$L ;
// }


$type X store<float> ;

$rule unit(integrateBoundary(X)),constraint(geom_cells) {
  $integrateBoundary(X) = 0 ;
}
$rule apply(cl->integrateBoundary(X)<-X)[Loci::Summation] {
  join($cl->$integrateBoundary(X),$X) ;
}
$rule apply(cr->integrateBoundary(X)<-X)[Loci::Summation] {
  join($cr->$integrateBoundary(X),-$X) ;
}
    

$rule pointwise(uflux<-nu,ux) {
  $uflux = $nu*$ux ;
}

$rule pointwise(L<-integrateBoundary(x)) {
  $L = $integrateBoundary(x) ;
}

//*******************************************************************
// Compute boundary condition at leftmost interface. At left we are
// imposing Neumann Boundary Condition, u_x = -1 ;
//*******************************************************************

$rule pointwise(ux), constraint(left_boundary) {
   $ux = -1 ;
}


//*******************************************************************
// Compute boundary condition at rightmost interface. At right we are
// imposing Dirichlet boundary condition, u=0 ;
//*******************************************************************
$rule pointwise(ub), constraint(right_boundary) {
  $ub = 0 ;
}

//*******************************************************************
// Compute center of cells: Also make sure to compute the centroid of
// only those cells, where left and right interface entities are
// defined.
//*******************************************************************

//$rule pointwise(xc<-(il,ir)->x) {
//  $xc = .5*($il->$x + $ir->$x) ;
//}
$rule unit(xc), constraint(geom_cells) {
  $xc = 0 ;
}
$rule apply(cl->xc <- x)[Loci::Summation] {
  join($cl->$xc,.5*$x) ;
}
$rule apply(cr->xc <- x)[Loci::Summation] {
  join($cr->$xc,.5*$x) ;
}



//*******************************************************************
// Compute gradient of u at all internal interfaces. An internal face
// is a face having left and right cell mapping defined. Since a
// boundary face has only one cell adjacent to it, it willn't calculate
// gradient at those points.
//*******************************************************************

$rule pointwise(ux<-(cl,cr)->(u,xc)) {
  float dx = $cr->$xc - $cl->$xc ;
  float du = $cr->$u  - $cl->$u ;
  $ux = du/dx ;
}
//*******************************************************************
// Compute gradient at boundary
//*******************************************************************

$rule pointwise(ux<-x,ub,cl->(u,xc)) {
  float dx = $x  - $cl->$xc ;
  float du = $ub - $cl->$u ;
  $ux = du/dx ;
}




//*******************************************************************
// Compute maximum stable timestep for simulation.  Use reduction rule
// and calculate timestep as a function of local conditions.  The global
// timestep is the minimum of these local timesteps
//*******************************************************************

$rule unit(dt), constraint(UNIVERSE) {
   $dt = 1e30 ; // largest allowble timestep
}

$rule apply(dt<-dt,(cl,cr)->xc,nu)[Loci::Minimum] {
    float dx = abs($cr->$xc-$cl->$xc) ;
    float local_dt = dx*dx/($nu*2.) ;  

    join($dt,local_dt) ; // Set dt = min(dt,local_dt)
}


