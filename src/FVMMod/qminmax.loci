/** ****************************************************************************
 * @file      qminmax.cc
 * @authors   Ed Luke (MS State)
 *            Raymond Fontenot (CFDRC)
 * @date      LICENSE Date: 12-30-2023
 * @copyright MS State/CFDRC
 * @brief     Cell min/max and related rules for limiters
 * @details   This file is a part of the Loci Framework, a free software.
 * You can redistribute it and/or modify it under the terms of the Lesser
 * GNU General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 *
 * The Loci Framework is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * Lesser GNU General Public License for more details.
 *
 * You should have received a copy of the Lesser GNU General Public License
 * along with the Loci Framework.  If not, see <http://www.gnu.org/licenses>
 ******************************************************************************/
#include <Loci>
#include <Loci.h>
$include "FVM.lh"
$include "FVMMod/limiter.lh"
$include "FVMMod/spatialFilter.lh"


namespace Loci {
$type X store<real>;
$type X_f store<real>;

/** ****************************************************************************
 * @brief Parametric rule for coomputing scalar cell max/mins for non-MLP limiters
 * @retval cellmamins(X)           [-] cell max and min for scalar
 * @param  X                       [-] scalar
 * @param  upper->cr->X            [-] upper face state
 * @param  lower->cl->X            [-] lower face state
 * @param  boundary_map->X_f       [-] boundary state
 ******************************************************************************/
$rule pointwise(cellmaxmins(X)<-X,upper->cr->X,lower->cl->X,boundary_map->X_f),
      constraint(geom_cells)
{
  const real Xcc = $X;
  real qmax = Xcc;
  real qmin = qmax;
  real refsq = Xcc*Xcc;
  int nref = 1.0;

  const int usz = $upper.size();
  nref += usz;
  for(int i=0;i<usz;++i)
  {
    const real Xi = $upper[i]->$cr->$X;
    qmin = min(qmin,Xi);
    qmax = max(qmax,Xi);
    refsq += Xi*Xi;
  }
  const int lsz= $lower.size();
  nref +=lsz;
  for(int i=0;i<lsz;++i)
  {
    const real Xi = $lower[i]->$cl->$X;
    qmin = min(qmin,Xi);
    qmax = max(qmax,Xi);
    refsq += Xi*Xi;
  }
  const int bsz = $boundary_map.size();
  nref += bsz;
  for(int i=0;i<bsz;++i)
  {
    const real Xi = $boundary_map[i]->$X_f;
    qmin = min(qmin,Xi);
    qmax = max(qmax,Xi);
    refsq += Xi*Xi;
  }

  $cellmaxmins(X).norm = sqrt(refsq)/nref + 1e-20;
  $cellmaxmins(X).max = qmax;
  $cellmaxmins(X).min = qmin;
}

/** ****************************************************************************
 * @brief Parametric rule for coomputing scalar cell max/mins for non-MLP limiters
 *        on special stencils
 * @retval cellmamins(X)           [-] cell max and min for scalar
 * @param  X                       [-] scalar
 * @param  cellStencil->X          [-] state at cell stencil cell centers
 * @param  boundary_map->X_f       [-] boundary state
 ******************************************************************************/
$rule pointwise(stencil::cellmaxmins(X)<-X,cellStencil->X,boundary_map->X_f),
     constraint(geom_cells)
{
  const real Xcc = $X;
  real qmax = Xcc;
  real qmin = qmax;
  real refsq = Xcc*Xcc;
  int nref = 1.0;

  const int ssz = $cellStencil.size();
  nref += ssz;
  for(int i=0;i<ssz;++i)
  {
    const real Xi = $cellStencil[i]->$X;
    refsq += Xi*Xi;
    qmin = min(qmin,Xi);
    qmax = max(qmax,Xi);
  }

  const int bsz = $boundary_map.size();
  nref += bsz;
  for(int i=0;i<bsz;++i)
  {
    const real Xi = $boundary_map[i]->$X_f;
    qmin = min(qmin,Xi);
    qmax = max(qmax,Xi);
    refsq += Xi*Xi;
  }

  $cellmaxmins(X).norm = sqrt(refsq)/nref + 1e-20;
  $cellmaxmins(X).max = qmax;
  $cellmaxmins(X).min = qmin;
}

$type X store<vect3d>;
$type X_f store<vect3d>;
/** ****************************************************************************
 * @brief Parametric rule for coomputing vect3d cell max/mins for non-MLP limiters
 * @retval cellmaminv3d(X)         [-] cell max and min for vect3d
 * @param  X                       [-] vect3d state
 * @param  upper->cr->X            [-] upper face state
 * @param  lower->cl->X            [-] lower face state
 * @param  boundary_map->X_f       [-] boundary state
 ******************************************************************************/
$rule pointwise(cellmaxminv3d(X)<-X,upper->cr->X,lower->cl->X,
                boundary_map->X_f),
      constraint(geom_cells)
{
  const vect3d Xcc = $X;
  vect3d qmax = Xcc;
  vect3d qmin = qmax;
  real refsq = dot(Xcc,Xcc);
  real nref = 1;

  const int usz = $upper.size();
  nref += usz;
  for(int i=0;i<usz;++i)
  {
    const vect3d Xi = $upper[i]->$cr->$X;
    refsq += dot(Xi,Xi);
    qmin.x = min(qmin.x,Xi.x);
    qmax.x = max(qmax.x,Xi.x);
    qmin.y = min(qmin.y,Xi.y);
    qmax.y = max(qmax.y,Xi.y);
    qmin.z = min(qmin.z,Xi.z);
    qmax.z = max(qmax.z,Xi.z);
  }

  const int lsz= $lower.size();
  nref += lsz;
  for(int i=0;i<lsz;++i)
  {
    const vect3d Xi = $lower[i]->$cl->$X;
    refsq += dot(Xi,Xi);
    qmin.x = min(qmin.x,Xi.x);
    qmax.x = max(qmax.x,Xi.x);
    qmin.y = min(qmin.y,Xi.y);
    qmax.y = max(qmax.y,Xi.y);
    qmin.z = min(qmin.z,Xi.z);
    qmax.z = max(qmax.z,Xi.z);
  }

  const int bsz = $boundary_map.size();
  nref += bsz;
  for(int i=0;i<bsz;++i)
  {
    const vect3d Xi = $boundary_map[i]->$X_f;
    refsq += dot(Xi,Xi);
    qmin.x = min(qmin.x,Xi.x);
    qmax.x = max(qmax.x,Xi.x);
    qmin.y = min(qmin.y,Xi.y);
    qmax.y = max(qmax.y,Xi.y);
    qmin.z = min(qmin.z,Xi.z);
    qmax.z = max(qmax.z,Xi.z);
  }

  real norm = sqrt(refsq)/nref + 1e-20;
  $cellmaxminv3d(X).norm = norm;
  $cellmaxminv3d(X).max = qmax;
  $cellmaxminv3d(X).min = qmin;
}

/** ****************************************************************************
 * @brief Parametric rule for coomputing vect3d cell max/mins for non-MLP limiters
 *        on special stencils
 * @retval cellmaminv3d(X)         [-] cell max and min for vect3d
 * @param  X                       [-] vect3d state
 * @param  cellStencil->X          [-] state at cell stencil cell centers
 * @param  boundary_map->X_f       [-] boundary state
 ******************************************************************************/
$rule pointwise(stencil::cellmaxminv3d(X)<-X,cellStencil->X,boundary_map->X_f),
      constraint(geom_cells)
 {
  const vect3d Xcc = $X;
  vect3d qmax = Xcc;
  vect3d qmin = qmax;
  real refsq = dot(Xcc,Xcc);
  real nref = 1;

  const int ssz = $cellStencil.size();
  nref += ssz;
  for(int i=0;i<ssz;++i)
  {
    const vect3d Xi = $cellStencil[i]->$X;
    refsq += dot(Xi,Xi);
    qmin.x = min(qmin.x,Xi.x);
    qmax.x = max(qmax.x,Xi.x);
    qmin.y = min(qmin.y,Xi.y);
    qmax.y = max(qmax.y,Xi.y);
    qmin.z = min(qmin.z,Xi.z);
    qmax.z = max(qmax.z,Xi.z);
  }

  const int bsz = $boundary_map.size();
  nref += bsz;
  for(int i=0;i<bsz;++i)
  {
    const vect3d Xi = $boundary_map[i]->$X_f;
    refsq += dot(Xi,Xi);
    qmin.x = min(qmin.x,Xi.x);
    qmax.x = max(qmax.x,Xi.x);
    qmin.y = min(qmin.y,Xi.y);
    qmax.y = max(qmax.y,Xi.y);
    qmin.z = min(qmin.z,Xi.z);
    qmax.z = max(qmax.z,Xi.z);
  }

  real norm = sqrt(refsq)/nref + 1e-20;
  $cellmaxminv3d(X).norm = norm;
  $cellmaxminv3d(X).max = qmax;
  $cellmaxminv3d(X).min = qmin;
}

$type X storeVec<real>;
$type X_f storeVec<real>;
  /** ****************************************************************************
 * @brief Parametric rule for coomputing vector cell max/mins for non-MLP limiters
 * @retval cellmaminv(X)           [-] cell max and min for vector
 * @param  X                       [-] vector state
 * @param  upper->cr->X            [-] upper face state
 * @param  lower->cl->X            [-] lower face state
 * @param  boundary_map->X_f       [-] boundary state
 ******************************************************************************/
$rule pointwise(cellmaxminv(X)<-X,upper->cr->X,lower->cl->X,boundary_map->X_f),
      constraint(geom_cells),prelude
{
  $cellmaxminv(X).setVecSize($X.vecSize());
} compute {
  const int vs = $*X.vecSize();

  for(int j=0;j<vs;++j) {
    const real Xcc = $X[j];
    real qmax = Xcc;
    real qmin = qmax;
    real refsq = Xcc*Xcc;
    int nref = 1;

    const int usz = $upper.size();
    nref += usz;
    for(int i=0;i<usz;++i)
    {
      const real Xi = $upper[i]->$cr->$X[j];
      refsq += Xi*Xi;
      qmin = min(qmin,Xi);
      qmax = max(qmax,Xi);
    }

    const int lsz= $lower.size();
    nref += lsz;
    for(int i=0;i<lsz;++i)
    {
      const real Xi = $lower[i]->$cl->$X[j];
      refsq += Xi*Xi;
      qmin = min(qmin,Xi);
      qmax = max(qmax,Xi);
    }

    const int bsz = $boundary_map.size();
    nref += bsz;
    for(int i=0;i<bsz;++i)
    {
      const real Xi = $boundary_map[i]->$X_f[j];
      refsq += Xi*Xi;
      qmin = min(qmin,Xi);
      qmax = max(qmax,Xi);
    }

    $cellmaxminv(X)[j].max = qmax;
    $cellmaxminv(X)[j].min = qmin;
    $cellmaxminv(X)[j].norm = sqrt(refsq)/nref + 1e-20;
  }
}

/** ****************************************************************************
 * @brief Parametric rule for coomputing vector cell max/mins for non-MLP limiters
 *        on special stencils
 * @retval cellmaminv(X)           [-] cell max and min for vect3d
 * @param  X                       [-] vector state
 * @param  cellStencil->X          [-] state at cell stencil cell centers
 * @param  boundary_map->X_f       [-] boundary state
 ******************************************************************************/
$rule pointwise(stencil::cellmaxminv(X)<-X,cellStencil->X,boundary_map->X_f),
      constraint(geom_cells),prelude
{
  $cellmaxminv(X).setVecSize($X.vecSize());
} compute {
  const int vs = $*X.vecSize();

  for(int j=0;j<vs;++j)
  {
    const real Xcc = $X[j];
    real qmax = Xcc;
    real qmin = qmax;
    real refsq = Xcc*Xcc;
    int nref = 1;

    const int ssz = $cellStencil.size();
    nref += ssz;
    for(int i=0;i<ssz;++i)
    {
      const real Xi = $cellStencil[i]->$X[j];
      refsq += Xi*Xi;
      qmin = min(qmin,Xi);
      qmax = max(qmax,Xi);
    }

    const int bsz = $boundary_map.size();
    nref += bsz;
    for(int i=0;i<bsz;++i)
    {
      const real Xi = $boundary_map[i]->$X_f[j];
      refsq += Xi*Xi;
      qmin = min(qmin,Xi);
      qmax = max(qmax,Xi);
    }

    $cellmaxminv(X)[j].max = qmax;
    $cellmaxminv(X)[j].min = qmin;
    $cellmaxminv(X)[j].norm = sqrt(refsq)/nref + 1e-20;
  }
}

/** ****************************************************************************
 * @brief Compute the Venkatakrishnan geometric factor for limiters
 * @retval venkaFac    [-] Venkatakrishnan factor
 * @param vol          [-] cell volume
 * @param grid_vol     [-] total grid volume
 * @param Kl           [-] Venkatakrishnan factor
 ******************************************************************************/
$rule pointwise(venkaFac<-vol,grid_vol,Kl),
      constraint(geom_cells,Venka_limiter)
{
  $venkaFac = pow($Kl,3) * 6/(M_PI * $grid_vol)*$vol; // (K delta x)^3
}

/** ****************************************************************************
 * @brief Compute the Venkatakrishnan geometric factor for Nishikawa Limiter
 * @retval venkaFac    [-] Venkatakrishnan factor
 * @param vol          [-] cell volume
 * @param grid_vol     [-] total grid volume
 * @param Kl           [-] Venkatakrishnan factor
 * @param nisPow       [-] order of Nishikawa limiter
 ******************************************************************************/
$rule pointwise(venkaFac<-vol,grid_vol,Kl,nisPow),
      constraint(geom_cells,NIS_limiter)
{
  real pp1 = $nisPow + 1.0;
  $venkaFac = pow($Kl,pp1) * pow(6/(M_PI * $grid_vol)*$vol,pp1/3.0); // (K delta X)^p+1
}

$type X store<real>;
$type X_f store<real>;
/** ****************************************************************************
 * @brief Venkatakrishnan grid factor for scalar limiters
 * @retval epsilon2s(X)        [-] Venkatakrishnan grid factor
 * @param  venkaFac            [-] Venkatakrishnan geometric factor
 * @param  cellmaxmins(X)      [-] cell max and min for scalar
 ******************************************************************************/
$rule pointwise(epsilon2s(X)<-venkaFac,cellmaxmins(X)),
      constraint(geom_cells,Venka_limiter)
{
  const real ref = $cellmaxmins(X).norm;
  $epsilon2s(X)  = $venkaFac*ref*ref;
}

/** ****************************************************************************
 * @brief Venkatakrishnan grid factor for Nishikawa scalar limiters
 * @retval epsilon2s(X)        [-] Venkatakrishnan grid factor
 * @param  venkaFac            [-] Venkatakrishnan geometric factor
 * @param  nisPow              [-] order of Nishikawa limiter
 * @param  cellmaxmins(X)      [-] cell max and min for scalar
 ******************************************************************************/
$rule pointwise(epsilon2s(X)<-venkaFac,nisPow,cellmaxmins(X)),
      constraint(geom_cells,NIS_limiter)
{
  const real ref = $cellmaxmins(X).norm;
  $epsilon2s(X)  = $venkaFac*pow(ref,$nisPow);
}

$type X store<vect3d>;
$type X_f store<vect3d>;
/** ****************************************************************************
 * @brief Venkatakrishnan grid factor for vect3d limiters
 * @retval epsilon2v3d(X)        [-] Venkatakrishnan grid factor
 * @param  venkaFac              [-] Venkatakrishnan geometric factor
 * @param  cellmaxminv3d(X)      [-] cell max and min for vect3d
 ******************************************************************************/
$rule pointwise(epsilon2v3d(X)<-venkaFac,cellmaxminv3d(X)),
      constraint(geom_cells,Venka_limiter)
{
  const real ref = $cellmaxminv3d(X).norm;
  $epsilon2v3d(X)  = $venkaFac*ref*ref;
}

/** ****************************************************************************
 * @brief Venkatakrishnan grid factor for Nishikawa vect3d limiters
 * @retval epsilon2v3d(X)        [-] Venkatakrishnan grid factor
 * @param  venkaFac              [-] Venkatakrishnan geometric factor
 * @param  nisPow                [-] order of Nishikawa limiter
 * @param  cellmaxminv3d(X)      [-] cell max and min for vect3d
 ******************************************************************************/
$rule pointwise(epsilon2v3d(X)<-venkaFac,nisPow,cellmaxminv3d(X)),
      constraint(geom_cells,NIS_limiter)
{
  const real ref = $cellmaxminv3d(X).norm;
  $epsilon2v3d(X)  = $venkaFac*pow(ref,$nisPow);
}

$type X storeVec<real>;
$type X_f storeVec<real>;
/** ****************************************************************************
 * @brief Venkatakrishnan grid factor for vector limiters
 * @retval epsilon2v(X)        [-] Venkatakrishnan grid factor
 * @param  X                   [-] state
 * @param  venkaFac            [-] Venkatakrishnan geometric factor
 * @param  cellmaxminv(X)      [-] cell max and min for vector
 ******************************************************************************/
$rule pointwise(epsilon2v(X)<-X,venkaFac,cellmaxminv(X)),
      constraint(geom_cells,Venka_limiter),prelude
{
  $epsilon2v(X).setVecSize($X.vecSize());
}
  compute
{
  const int vs = $*X.vecSize();
  for(int j=0;j<vs;++j)
  {
      const real ref = $cellmaxminv(X)[j].norm;
      $epsilon2v(X)[j] = $venkaFac*ref*ref;
  }
}

/** ****************************************************************************
 * @brief Venkatakrishnan grid factor for Nishikawa vector limiters
 * @retval epsilon2v(X)        [-] Venkatakrishnan grid factor
 * @param  X                   [-] state
 * @param  venkaFac            [-] Venkatakrishnan geometric factor
 * @param  nisPow              [-] order of Nishikawa limiter
 * @param  cellmaxminv(X)      [-] cell max and min for vector
 ******************************************************************************/
$rule pointwise(epsilon2v(X)<-X,venkaFac,nisPow,cellmaxminv(X)),constraint(geom_cells,NIS_limiter),
prelude
{
  $epsilon2v(X).setVecSize($X.vecSize());
}
  compute
{
  const int vs = $*X.vecSize();

  for(int j=0;j<vs;++j)
  {
      const real ref = $cellmaxminv(X)[j].norm;
      $epsilon2v(X)[j] = $venkaFac*pow(ref,$nisPow);
  }
}

/** ****************************************************************************
 * @brief MLP grid factor for vector limiters
 * @retval epsilon2v(X)        [-] MLP grid factor
 * @param  X                   [-] state
 * @param  mlpFac              [-] MLP geometric factor
 * @param  K1                  [-] MLP factor
 * @param  cellmaxminv(X)      [-] cell max and min for vector
 ******************************************************************************/
$rule pointwise(epsilon2v(X)<-X,mlpFac,K1,cellmaxminv(X)),
      constraint(geom_cells,MLPpwv_limiter), prelude
{
  $epsilon2v(X).setVecSize($X.vecSize());
}
  compute
{
  const int vs = $*X.vecSize();
  for(int j=0;j<vs;++j)
  {
    real deltaq = $cellmaxminv(X)[j].max - $cellmaxminv(X)[j].min;
    real deltaq2 = deltaq*deltaq;

    // e^2 = K1/(1+theta)*dq^2, theta = dq/K2*dx^1.5
    real theta = deltaq/$mlpFac;
    $epsilon2v(X)[j] = $K1/(1.0+theta) * deltaq2;
  }
}

}