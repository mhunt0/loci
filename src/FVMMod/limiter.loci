//#############################################################################
//#
//# Copyright 2008-2019, Mississippi State University
//#
//# This file is part of the Loci Framework.
//#
//# The Loci Framework is free software: you can redistribute it and/or modify
//# it under the terms of the Lesser GNU General Public License as published by
//# the Free Software Foundation, either version 3 of the License, or
//# (at your option) any later version.
//#
//# The Loci Framework is distributed in the hope that it will be useful,
//# but WITHOUT ANY WARRANTY; without even the implied warranty of
//# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//# Lesser GNU General Public License for more details.
//#
//# You should have received a copy of the Lesser GNU General Public License
//# along with the Loci Framework.  If not, see <http://www.gnu.org/licenses>
//#
//#############################################################################
#include <Loci.h>
$include "FVM.lh"
$include "FVMMod/limiter.lh"

using std::cerr ;
using std::endl ;

namespace Loci {
  typedef vector3d<real_t> vect3d ;
  typedef tensor3d<real_t> tens3d ;
  typedef real_t real ;

  $rule unit(firstOrderCells),constraint(geom_cells) {
    $firstOrderCells = 0 ;
  }

  $rule apply((cl,cr)->firstOrderCells<-(cl,cr)->vol)[Loci::Maximum],
  constraint((cl,cr)->geom_cells) {
    if(max($cl->$vol,$cr->$vol) > 50.*min($cl->$vol,$cr->$vol)) {
      char tmp = 1 ;
      join($cl->$firstOrderCells,tmp) ;
      join($cr->$firstOrderCells,tmp) ;
    }
  }

  $rule apply(ci->firstOrderCells<-ci->vol)[Loci::Maximum], constraint(ref->firstOrder_BCoption,ci->vol) {
    char tmp = 1 ;
    join($ci->$firstOrderCells,tmp) ;
  }

  $rule apply((cl,cr)->firstOrderCells<-(cl,cr)->cellcenter,facecenter)[Loci::Maximum],constraint((cl,cr)->geom_cells) {
    // maximum angle between line segment connecting cellcenters and line
    // segments that connect cell centers to face centers.
    vector3d<real_t> v1 = $cr->$cellcenter-$cl->$cellcenter ;
    vector3d<real_t> v2 = $facecenter-$cl->$cellcenter ;
    vector3d<real_t> v3 = $cr->$cellcenter-$facecenter ;
    real_t nv1 = max(norm(v1),real_t(1e-20)) ;
    real_t nv2 = max(norm(v2),real_t(1e-20)) ;
    real_t nv3 = max(norm(v3),real_t(1e-20)) ;
    real_t mincosa = min(dot(v1,v2)/(nv1*nv2),dot(v1,v3)/(nv1*nv3)) ;
    if(mincosa < -.866) { // Greater than 150 degrees
      char tmp = 1 ;
      join($cl->$firstOrderCells,tmp) ;
      join($cr->$firstOrderCells,tmp) ;
    }
  }

  $rule default(Kl),comments("This parameter is a smoothness parameter for the venkatakrishnan limiter.  A value of zero will not allow overshoots, while a larger value may allow some overshoots to ensure accuracy in locally smooth regions.  The typical values for this parameter range from .1 to 100") {
    $Kl = 1.0 ;
  }

  $rule default(limiter),comments("Limiter used in face extrapolations.  This function can take the values of 'venkatakrishnan', 'barth', 'none' for second order solutions, and 'zero' for first order solutions") {
    $limiter = "venkatakrishnan" ;
  }

  /** ****************************************************************************
   * @brief Default rule to allow the limiter for vectors to be determined from 
   *        the minimum for the vector such that the vector itself is not 'scaled' nonuniformly
   ******************************************************************************/
  $rule default(vecLimiter),
    comments("Flag to normalize/scale limiters for vector quantities along maximum direction. Default is 0 (not to)")
  {
    $vecLimiter = 0;
  }

  $rule constraint(vecStandLimiter,vecNormLimiter<-vecLimiter)
  {
    $vecStandLimiter = ~EMPTY;
    $vecNormLimiter = EMPTY;
    if ($vecLimiter > 0)
    {
      $vecStandLimiter = EMPTY;
      $vecNormLimiter = ~EMPTY;
    }
  }


  $rule constraint(V_limiter,B_limiter,N_limiter,Z_limiter,NB_limiter,V2_limiter,
                    NISf_limiter,NISc_limiter<-limiter) 
  {
    $V_limiter = EMPTY ;
    $V2_limiter = EMPTY ;
    $B_limiter = EMPTY ;
    $NB_limiter = EMPTY ;
    $N_limiter = EMPTY ;
    $Z_limiter = EMPTY ;
    $NISc_limiter   = EMPTY;
    $NISf_limiter   = EMPTY;
      
    if($limiter == "venkatakrishnan" || $limiter == "V") {
      $V_limiter = ~EMPTY ;
    } else if($limiter == "V2") {
      $V2_limiter = ~EMPTY ;
    } else if($limiter == "barth" || $limiter == "B") {
      $B_limiter = ~EMPTY ;
    } else if($limiter == "nodalbarth" || $limiter == "NB") {
      $NB_limiter = ~EMPTY ;
    }
    else if($limiter == "NISf" || $limiter == "nisf")
    {
      $NISf_limiter = ~EMPTY;
    }
    else if($limiter == "NISc" || $limiter == "nisc")
    {
      $NISc_limiter = ~EMPTY;
    } else if($limiter == "none") {
      $N_limiter = ~EMPTY ;
    } else if($limiter == "zero") {
      $Z_limiter = ~EMPTY ;
    } else {
      cerr << "limiter " << $limiter
	   << " not supported for generalized grids" << endl ;
      cerr << "defaulting to venkatakrishnan limiter" << endl ;
      $V_limiter = ~EMPTY ;
    }
  }

//-------------------------------------------------------------------------------
// Limiter assignment for unlimited solve
//------------------------------------------------------------------------------
  $type S store<real> ;
  $rule pointwise(limiters(S)<-S),constraint(geom_cells,N_limiter) {
    $limiters(S) = 1.0 ;
  }

  $type V3 store<vect3d> ;
  $rule pointwise(limiterv3d(V3)<-V3),constraint(geom_cells,N_limiter) {
    $limiterv3d(V3) = vect3d(1.0,1.0,1.0) ;
  }

  $type V storeVec<real> ;
  $rule pointwise(limiterv(V)<-V),constraint(geom_cells,N_limiter),prelude {
    $limiterv(V).setVecSize($V.vecSize()) ;
  } compute {
    $limiterv(V) = mk_Scalar(1.) ;
  }

//-------------------------------------------------------------------------------
// First order assignement of the limiters
//------------------------------------------------------------------------------
  $rule pointwise(limiters(S)<-S),constraint(geom_cells,Z_limiter) {
    $limiters(S) = 0.0 ;
  }

  $rule pointwise(limiterv3d(V3)<-V3),constraint(geom_cells,Z_limiter) {
    $limiterv3d(V3) = vect3d(0.0,0.0,0.0) ;
  }
    
  $rule pointwise(limiterv(V)<-V),constraint(geom_cells,Z_limiter),prelude {
    $limiterv(V).setVecSize($V.vecSize()) ;
  } compute {
    $limiterv(V) = mk_Scalar(0.) ;
  }

  //==========================================================================
  //
  // Handle Periodic BC's
  //
  //==========================================================================
  $rule pointwise(cr->limiters(S)<-pmap->cl->limiters(S)),constraint(periodicFaces,cl->S) {
    $cr->$limiters(S) = $pmap->$cl->$limiters(S) ;
  }

  $type periodicTransform store<rigid_transform> ;
  $rule pointwise(cr->limiterv3d(V3)<-pmap->cl->limiterv3d(V3),pmap->ref->periodicTransform),constraint(periodicFaces,cl->V3) {
    const rigid_transform &frame = $pmap->$ref->$periodicTransform ;
    $cr->$limiterv3d(V3) = frame.rotate_vec($pmap->$cl->$limiterv3d(V3)) ;
  }

  $rule pointwise(cr->limiterv(V)<-pmap->cl->limiterv(V)),constraint(periodicFaces,cl->V),prelude { } compute {
    int vs = $*limiterv(V).vecSize() ;
    for(int i=0;i<vs;++i)
      $cr->$limiterv(V)[i] = $pmap->$cl->$limiterv(V)[i] ;
  }
}
