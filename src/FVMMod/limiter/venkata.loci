//#############################################################################
//#
//# Copyright 2008-2019, Mississippi State University
//#
//# This file is part of the Loci Framework.
//#
//# The Loci Framework is free software: you can redistribute it and/or modify
//# it under the terms of the Lesser GNU General Public License as published by
//# the Free Software Foundation, either version 3 of the License, or
//# (at your option) any later version.
//#
//# The Loci Framework is distributed in the hope that it will be useful,
//# but WITHOUT ANY WARRANTY; without even the implied warranty of
//# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//# Lesser GNU General Public License for more details.
//#
//# You should have received a copy of the Lesser GNU General Public License
//# along with the Loci Framework.  If not, see <http://www.gnu.org/licenses>
//#
//#############################################################################
#include <Loci.h>
#include <FVMMod/limiter_support.h>
$include "FVM.lh"
$include "FVMMod/limiter.lh"

using std::cerr ;
using std::endl ;

namespace Loci {
  typedef vector3d<real_t> vect3d ;
  typedef tensor3d<real_t> tens3d ;
  typedef real_t real ;

  //==========================================================================
  //
  // Venkatakrishnan Limiter 
  //
  //==========================================================================

  $type S store<real> ;
  $type S_f store<real> ;
  /**
   * @brief Venkatakrishnan limiter, scalars
   * 
   */
  $rule pointwise(limiters(S)<-cellcenter,S,grads(S),firstOrderCells,
                                Kl,vol,grid_vol,
                                upper->cr->S,upper->facecenter,
                                lower->cl->S,lower->facecenter,
                                boundary_map->S_f,boundary_map->facecenter),
      constraint(geom_cells,V_limiter) 
  {
    const real Xcc = $S ;
    const vect3d cctr = $cellcenter ;

    real refsq = Xcc*Xcc ;
    int numrefs = 1 ;
    
    real qmax = Xcc ;
    real qmin = qmax ;
    const vect3d Xgr = $grads(S) ;

    const int usz = $upper.size() ;
    numrefs += usz ;
    for(int i=0;i<usz;++i) {
      const real Xi = $upper[i]->$cr->$S ;
      refsq += Xi*Xi ;
      qmin = min(qmin,Xi) ;
      qmax = max(qmax,Xi) ;
    }
    const int lsz= $lower.size() ;
    numrefs += lsz ;
    for(int i=0;i<lsz;++i) {
      const real Xi = $lower[i]->$cl->$S ;
      refsq += Xi*Xi ;
      qmin = min(qmin,Xi) ;
      qmax = max(qmax,Xi) ;
    }
    const int bsz = $boundary_map.size() ;
    numrefs += bsz ;
    for(int i=0;i<bsz;++i) {
      const real Xi = $boundary_map[i]->$S_f ;
      refsq += Xi*Xi ;
      qmin = min(qmin,Xi) ;
      qmax = max(qmax,Xi) ;
    }      

    const real ref = 1e-20+sqrt(refsq)/numrefs ;
    const real Kl3 = $Kl*$Kl*$Kl*6./(M_PI*$grid_vol) ;
    const real epsilon2 = Kl3*$vol*ref*ref ;
    
    real limi = ($firstOrderCells != 0)?0.0:1.0 ;

    for(int i=0;i<usz;++i) {
      const vect3d drl = $upper[i]->$facecenter - cctr ;
      real qdif = -dot(Xgr,drl) ;
      limi = min(limi,vlimit(Xcc,qmin,qmax,qdif,epsilon2)) ;
    }

    for(int i=0;i<lsz;++i) {
      const vect3d drl = $lower[i]->$facecenter - cctr ;
      real qdif = -dot(Xgr,drl) ;
      limi = min(limi,vlimit(Xcc,qmin,qmax,qdif,epsilon2)) ;
    }
    
    $limiters(S) = realToDouble(limi) ;
  }

  $type V3 store<vect3d> ;
  $type V3_f store<vect3d> ;
  /**
   * @brief Venkatakrishnan limiter, standard vect3d
   * 
   */
  $rule pointwise(limiterv3d(V3)<-cellcenter,V3,gradv3d(V3),firstOrderCells,
                                  Kl,vol,grid_vol,
                                  upper->cr->V3,upper->facecenter,
                                  lower->cl->V3,lower->facecenter,
                                  boundary_map->V3_f,boundary_map->facecenter),
      constraint(geom_cells,V_limiter,vecStandLimiter) 
  {
    const vect3d Xcc = $V3 ;
    real refsq = dot(Xcc,Xcc) ;
    int numrefs = 1 ;
    vect3d qmax = Xcc ;
    vect3d qmin = qmax ;
    const tens3d Xgr = $gradv3d(V3) ;

    const int usz = $upper.size() ;
    numrefs += usz ;
    for(int i=0;i<usz;++i) {
      const vect3d Xi = $upper[i]->$cr->$V3 ;
      refsq += dot(Xi,Xi) ;
      qmin.x = min(qmin.x,Xi.x) ;
      qmax.x = max(qmax.x,Xi.x) ;
      qmin.y = min(qmin.y,Xi.y) ;
      qmax.y = max(qmax.y,Xi.y) ;
      qmin.z = min(qmin.z,Xi.z) ;
      qmax.z = max(qmax.z,Xi.z) ;
    }
    const int lsz= $lower.size() ;
    numrefs += lsz ;
    for(int i=0;i<lsz;++i) {
      const vect3d Xi = $lower[i]->$cl->$V3 ;
      refsq += dot(Xi,Xi) ;
      qmin.x = min(qmin.x,Xi.x) ;
      qmax.x = max(qmax.x,Xi.x) ;
      qmin.y = min(qmin.y,Xi.y) ;
      qmax.y = max(qmax.y,Xi.y) ;
      qmin.z = min(qmin.z,Xi.z) ;
      qmax.z = max(qmax.z,Xi.z) ;
    }
    const int bsz = $boundary_map.size() ;
    numrefs += bsz ;
    for(int i=0;i<bsz;++i) {
      const vect3d Xi = $boundary_map[i]->$V3_f ;
      refsq += dot(Xi,Xi) ;
      qmin.x = min(qmin.x,Xi.x) ;
      qmax.x = max(qmax.x,Xi.x) ;
      qmin.y = min(qmin.y,Xi.y) ;
      qmax.y = max(qmax.y,Xi.y) ;
      qmin.z = min(qmin.z,Xi.z) ;
      qmax.z = max(qmax.z,Xi.z) ;
    }      
    
    const real ref = 1e-20+sqrt(refsq)/numrefs ;
    const real Kl3 = $Kl*$Kl*$Kl*6./(M_PI*$grid_vol) ;
    const real epsilon2 = Kl3*$vol*ref*ref ;

    vect3d limi = ($firstOrderCells != 0)?vect3d(0.,0.,0.):vect3d(1.,1.,1.) ;

    for(int i=0;i<usz;++i) {
      const vect3d drl = $upper[i]->$facecenter - $cellcenter ;
      real qdifx = -dot(Xgr.x,drl) ;
      limi.x = min(limi.x,vlimit(Xcc.x,qmin.x,qmax.x,qdifx,epsilon2)) ;
      real qdify = -dot(Xgr.y,drl) ;
      limi.y = min(limi.y,vlimit(Xcc.y,qmin.y,qmax.y,qdify,epsilon2)) ;
      real qdifz = -dot(Xgr.z,drl) ;
      limi.z = min(limi.z,vlimit(Xcc.z,qmin.z,qmax.z,qdifz,epsilon2)) ;
    }

    for(int i=0;i<lsz;++i) {
      const vect3d drl = $lower[i]->$facecenter - $cellcenter ;
      real qdifx = -dot(Xgr.x,drl) ;
      limi.x = min(limi.x,vlimit(Xcc.x,qmin.x,qmax.x,qdifx,epsilon2)) ;
      real qdify = -dot(Xgr.y,drl) ;
      limi.y = min(limi.y,vlimit(Xcc.y,qmin.y,qmax.y,qdify,epsilon2)) ;
      real qdifz = -dot(Xgr.z,drl) ;
      limi.z = min(limi.z,vlimit(Xcc.z,qmin.z,qmax.z,qdifz,epsilon2)) ;
    }
    
    $limiterv3d(V3) = realToDouble(limi) ;
  }

  /**
   * @brief Venkatakrishnan limiter, standard vect3d
   * 
   */
  $rule pointwise(limiterv3d(V3)<-cellcenter,V3,gradv3d(V3),firstOrderCells,
                                  Kl,vol,grid_vol,
                                  upper->cr->V3,upper->facecenter,
                                  lower->cl->V3,lower->facecenter,
                                  boundary_map->V3_f,boundary_map->facecenter),
      constraint(geom_cells,V_limiter,vecNormLimiter) 
  {
    const vect3d Xcc = $V3 ;
    real refsq = dot(Xcc,Xcc) ;
    int numrefs = 1 ;
    vect3d qmax = Xcc ;
    vect3d qmin = qmax ;
    const tens3d Xgr = $gradv3d(V3) ;

    const int usz = $upper.size() ;
    numrefs += usz ;
    for(int i=0;i<usz;++i) {
      const vect3d Xi = $upper[i]->$cr->$V3 ;
      refsq += dot(Xi,Xi) ;
      qmin.x = min(qmin.x,Xi.x) ;
      qmax.x = max(qmax.x,Xi.x) ;
      qmin.y = min(qmin.y,Xi.y) ;
      qmax.y = max(qmax.y,Xi.y) ;
      qmin.z = min(qmin.z,Xi.z) ;
      qmax.z = max(qmax.z,Xi.z) ;
    }
    const int lsz= $lower.size() ;
    numrefs += lsz ;
    for(int i=0;i<lsz;++i) {
      const vect3d Xi = $lower[i]->$cl->$V3 ;
      refsq += dot(Xi,Xi) ;
      qmin.x = min(qmin.x,Xi.x) ;
      qmax.x = max(qmax.x,Xi.x) ;
      qmin.y = min(qmin.y,Xi.y) ;
      qmax.y = max(qmax.y,Xi.y) ;
      qmin.z = min(qmin.z,Xi.z) ;
      qmax.z = max(qmax.z,Xi.z) ;
    }
    const int bsz = $boundary_map.size() ;
    numrefs += bsz ;
    for(int i=0;i<bsz;++i) {
      const vect3d Xi = $boundary_map[i]->$V3_f ;
      refsq += dot(Xi,Xi) ;
      qmin.x = min(qmin.x,Xi.x) ;
      qmax.x = max(qmax.x,Xi.x) ;
      qmin.y = min(qmin.y,Xi.y) ;
      qmax.y = max(qmax.y,Xi.y) ;
      qmin.z = min(qmin.z,Xi.z) ;
      qmax.z = max(qmax.z,Xi.z) ;
    }      
    
    const real ref = 1e-20+sqrt(refsq)/numrefs ;
    const real Kl3 = $Kl*$Kl*$Kl*6./(M_PI*$grid_vol) ;
    const real epsilon2 = Kl3*$vol*ref*ref ;

    vect3d limi = ($firstOrderCells != 0)?vect3d(0.,0.,0.):vect3d(1.,1.,1.) ;

    for(int i=0;i<usz;++i) {
      const vect3d drl = $upper[i]->$facecenter - $cellcenter ;
      real qdifx = -dot(Xgr.x,drl) ;
      limi.x = min(limi.x,vlimit(Xcc.x,qmin.x,qmax.x,qdifx,epsilon2)) ;
      real qdify = -dot(Xgr.y,drl) ;
      limi.y = min(limi.y,vlimit(Xcc.y,qmin.y,qmax.y,qdify,epsilon2)) ;
      real qdifz = -dot(Xgr.z,drl) ;
      limi.z = min(limi.z,vlimit(Xcc.z,qmin.z,qmax.z,qdifz,epsilon2)) ;
    }

    for(int i=0;i<lsz;++i) {
      const vect3d drl = $lower[i]->$facecenter - $cellcenter ;
      real qdifx = -dot(Xgr.x,drl) ;
      limi.x = min(limi.x,vlimit(Xcc.x,qmin.x,qmax.x,qdifx,epsilon2)) ;
      real qdify = -dot(Xgr.y,drl) ;
      limi.y = min(limi.y,vlimit(Xcc.y,qmin.y,qmax.y,qdify,epsilon2)) ;
      real qdifz = -dot(Xgr.z,drl) ;
      limi.z = min(limi.z,vlimit(Xcc.z,qmin.z,qmax.z,qdifz,epsilon2)) ;
    }
    // Find the direction of maximum limiting
    double limm = realToDouble(min(limi.x,min(limi.y,limi.z)));
    // Zero the sensitivity portion of the limiter
    $limiterv3d(V3) = vect3d(limm,limm,limm);
  }

  $type V storeVec<real> ;
  $type V_f storeVec<real> ;
  /**
   * @brief Venkatakrishnan limiter, standard vector
   * 
   */
  $rule pointwise(limiterv(V)<-cellcenter,V,gradv(V),firstOrderCells,
                                Kl,vol,grid_vol,
                                upper->cr->V,upper->facecenter,
                                lower->cl->V,lower->facecenter,
                                boundary_map->V_f,boundary_map->facecenter),
        constraint(geom_cells,V_limiter,vecStandLimiter),prelude 
  {
    $limiterv(V).setVecSize($V.vecSize()) ;
  } compute {
    const int vs = $*V.vecSize() ;
    real ref = 0.0 ;
    for(int j=0;j<vs;++j)
      ref += fabs($V[j]) ;
    ref = max(ref,real_t(1e-5)) ;
    const real Kl3 = $Kl*$Kl*$Kl*6./(M_PI*$grid_vol) ;
    const real epsilon2 = Kl3*$vol*ref*ref ;
    
    for(int j=0;j<vs;++j) {
      const real Xcc = $V[j] ;
      real qmax = Xcc ;
      real qmin = qmax ;
      const vect3d Xgr = $gradv(V)[j] ;

      const int usz = $upper.size() ;
      for(int i=0;i<usz;++i) {
        const real Xi = $upper[i]->$cr->$V[j] ;
        qmin = min(qmin,Xi) ;
        qmax = max(qmax,Xi) ;
      }
      const int lsz= $lower.size() ;
      for(int i=0;i<lsz;++i) {
        const real Xi = $lower[i]->$cl->$V[j] ;
        qmin = min(qmin,Xi) ;
        qmax = max(qmax,Xi) ;
      }
      const int bsz = $boundary_map.size() ;
      for(int i=0;i<bsz;++i) {
        const real Xi = $boundary_map[i]->$V_f[j] ;
        qmin = min(qmin,Xi) ;
        qmax = max(qmax,Xi) ;
      }      
      
      real limi = ($firstOrderCells != 0)?0.0:1.0 ;

      for(int i=0;i<usz;++i) {
        const vect3d drl = $upper[i]->$facecenter - $cellcenter ;
        real qdif = -dot(Xgr,drl) ;
        limi = min(limi,vlimit(Xcc,qmin,qmax,qdif,epsilon2)) ;
      }
      
      for(int i=0;i<lsz;++i) {
        const vect3d drl = $lower[i]->$facecenter - $cellcenter ;
        real qdif = -dot(Xgr,drl) ;
        limi = min(limi,vlimit(Xcc,qmin,qmax,qdif,epsilon2)) ;
      }
      
      $limiterv(V)[j] = realToDouble(limi) ;
    }
  }
		   
  /**
   * @brief Venkatakrishnan limiter, normalized vector
   */
  $rule pointwise(limiterv(V)<-cellcenter,V,gradv(V),firstOrderCells,
                                Kl,vol,grid_vol,
                                upper->cr->V,upper->facecenter,
                                lower->cl->V,lower->facecenter,
                                boundary_map->V_f,boundary_map->facecenter),
        constraint(geom_cells,V_limiter,vecNormLimiter),prelude 
  {
    $limiterv(V).setVecSize($V.vecSize()) ;
  } compute {
    const int vs = $*V.vecSize() ;
    real ref = 0.0 ;
    double limm = 1.0;
    for(int j=0;j<vs;++j)
      ref += fabs($V[j]) ;
    ref = max(ref,real_t(1e-5)) ;
    const real Kl3 = $Kl*$Kl*$Kl*6./(M_PI*$grid_vol) ;
    const real epsilon2 = Kl3*$vol*ref*ref ;
    
    for(int j=0;j<vs;++j) {
      const real Xcc = $V[j] ;
      real qmax = Xcc ;
      real qmin = qmax ;
      const vect3d Xgr = $gradv(V)[j] ;

      const int usz = $upper.size() ;
      for(int i=0;i<usz;++i) {
        const real Xi = $upper[i]->$cr->$V[j] ;
        qmin = min(qmin,Xi) ;
        qmax = max(qmax,Xi) ;
      }
      const int lsz= $lower.size() ;
      for(int i=0;i<lsz;++i) {
        const real Xi = $lower[i]->$cl->$V[j] ;
        qmin = min(qmin,Xi) ;
        qmax = max(qmax,Xi) ;
      }
      const int bsz = $boundary_map.size() ;
      for(int i=0;i<bsz;++i) {
        const real Xi = $boundary_map[i]->$V_f[j] ;
        qmin = min(qmin,Xi) ;
        qmax = max(qmax,Xi) ;
      }      
      
      real limi = ($firstOrderCells != 0)?0.0:1.0 ;

      for(int i=0;i<usz;++i) {
        const vect3d drl = $upper[i]->$facecenter - $cellcenter ;
        real qdif = -dot(Xgr,drl) ;
        limi = min(limi,vlimit(Xcc,qmin,qmax,qdif,epsilon2)) ;
      }
      
      for(int i=0;i<lsz;++i) {
        const vect3d drl = $lower[i]->$facecenter - $cellcenter ;
        real qdif = -dot(Xgr,drl) ;
        limi = min(limi,vlimit(Xcc,qmin,qmax,qdif,epsilon2)) ;
      }
      // Zero the sensitivity portion of the limiter
      $limiterv(V)[j] = realToDouble(limi) ;
      limm = min(realToDouble(limi),limm);
    }
    // limit vector based on strongest gradient direction
    for(int j=0;j<vs;++j) {
      $limiterv(V)[j] = limm;
    }
  }

  //==========================================================================
  //
  // Venkatakrishnan Limiter2 (Limit to cell centers)
  //
  //==========================================================================
  /**
   * @brief Venkatakrishnan 2 limiter, scalar
   */
  $rule pointwise(limiters(S)<-cellcenter,S,grads(S),firstOrderCells,
                                Kl,vol,grid_vol,
                                upper->cr->(cellcenter,S),
                                lower->cl->(cellcenter,S),
                                boundary_map->S_f,boundary_map->facecenter),
      constraint(geom_cells,V2_limiter) 
  {
    const real Xcc = $S ;
    const vect3d cctr = $cellcenter ;

    real refsq = Xcc*Xcc ;
    int numrefs = 1 ;
    
    real qmax = Xcc ;
    real qmin = qmax ;
    const vect3d Xgr = $grads(S) ;

    const int usz = $upper.size() ;
    numrefs += usz ;
    for(int i=0;i<usz;++i) {
      const real Xi = $upper[i]->$cr->$S ;
      refsq += Xi*Xi ;
      qmin = min(qmin,Xi) ;
      qmax = max(qmax,Xi) ;
    }
    const int lsz= $lower.size() ;
    numrefs += lsz ;
    for(int i=0;i<lsz;++i) {
      const real Xi = $lower[i]->$cl->$S ;
      refsq += Xi*Xi ;
      qmin = min(qmin,Xi) ;
      qmax = max(qmax,Xi) ;
    }
    const int bsz = $boundary_map.size() ;
    numrefs += bsz ;
    for(int i=0;i<bsz;++i) {
      const real Xi = $boundary_map[i]->$S_f ;
      refsq += Xi*Xi ;
      qmin = min(qmin,Xi) ;
      qmax = max(qmax,Xi) ;
    }      

    const real ref = 1e-20+sqrt(refsq)/numrefs ;
    const real Kl3 = $Kl*$Kl*$Kl*6./(M_PI*$grid_vol) ;
    const real epsilon2 = Kl3*$vol*ref*ref ;
    
    real limi = ($firstOrderCells != 0)?0.0:1.0 ;

    for(int i=0;i<usz;++i) {
      const vect3d drl = $upper[i]->$cr->$cellcenter - cctr ;
      real qdif = -dot(Xgr,drl) ;
      limi = min(limi,vlimit(Xcc,qmin,qmax,qdif,epsilon2)) ;
    }

    for(int i=0;i<lsz;++i) {
      const vect3d drl = $lower[i]->$cl->$cellcenter - cctr ;
      real qdif = -dot(Xgr,drl) ;
      limi = min(limi,vlimit(Xcc,qmin,qmax,qdif,epsilon2)) ;
    }
    
    $limiters(S) = realToDouble(limi) ;
  }

  /**
   * @brief Venkatakrishnan 2 limiter, standard vect3d
   */
  $rule pointwise(limiterv3d(V3)<-cellcenter,V3,gradv3d(V3),firstOrderCells,
                                  Kl,vol,grid_vol,
                                  upper->cr->(V3,cellcenter),
                                  lower->cl->(V3,cellcenter),
                                  boundary_map->V3_f,boundary_map->facecenter),
        constraint(geom_cells,V2_limiter,vecStandLimiter) 
  {
    const vect3d Xcc = $V3 ;
    real refsq = dot(Xcc,Xcc) ;
    int numrefs = 1 ;
    vect3d qmax = Xcc ;
    vect3d qmin = qmax ;
    const tens3d Xgr = $gradv3d(V3) ;

    const int usz = $upper.size() ;
    numrefs += usz ;
    for(int i=0;i<usz;++i) {
      const vect3d Xi = $upper[i]->$cr->$V3 ;
      refsq += dot(Xi,Xi) ;
      qmin.x = min(qmin.x,Xi.x) ;
      qmax.x = max(qmax.x,Xi.x) ;
      qmin.y = min(qmin.y,Xi.y) ;
      qmax.y = max(qmax.y,Xi.y) ;
      qmin.z = min(qmin.z,Xi.z) ;
      qmax.z = max(qmax.z,Xi.z) ;
    }
    const int lsz= $lower.size() ;
    numrefs += lsz ;
    for(int i=0;i<lsz;++i) {
      const vect3d Xi = $lower[i]->$cl->$V3 ;
      refsq += dot(Xi,Xi) ;
      qmin.x = min(qmin.x,Xi.x) ;
      qmax.x = max(qmax.x,Xi.x) ;
      qmin.y = min(qmin.y,Xi.y) ;
      qmax.y = max(qmax.y,Xi.y) ;
      qmin.z = min(qmin.z,Xi.z) ;
      qmax.z = max(qmax.z,Xi.z) ;
    }
    const int bsz = $boundary_map.size() ;
    numrefs += bsz ;
    for(int i=0;i<bsz;++i) {
      const vect3d Xi = $boundary_map[i]->$V3_f ;
      refsq += dot(Xi,Xi) ;
      qmin.x = min(qmin.x,Xi.x) ;
      qmax.x = max(qmax.x,Xi.x) ;
      qmin.y = min(qmin.y,Xi.y) ;
      qmax.y = max(qmax.y,Xi.y) ;
      qmin.z = min(qmin.z,Xi.z) ;
      qmax.z = max(qmax.z,Xi.z) ;
    }      
    
    const real ref = 1e-20+sqrt(refsq)/numrefs ;
    const real Kl3 = $Kl*$Kl*$Kl*6./(M_PI*$grid_vol) ;
    const real epsilon2 = Kl3*$vol*ref*ref ;

    vect3d limi = ($firstOrderCells != 0)?vect3d(0.,0.,0.):vect3d(1.,1.,1.) ;

    for(int i=0;i<usz;++i) {
      const vect3d drl = $upper[i]->$cr->$cellcenter - $cellcenter ;
      real qdifx = -dot(Xgr.x,drl) ;
      limi.x = min(limi.x,vlimit(Xcc.x,qmin.x,qmax.x,qdifx,epsilon2)) ;
      real qdify = -dot(Xgr.y,drl) ;
      limi.y = min(limi.y,vlimit(Xcc.y,qmin.y,qmax.y,qdify,epsilon2)) ;
      real qdifz = -dot(Xgr.z,drl) ;
      limi.z = min(limi.z,vlimit(Xcc.z,qmin.z,qmax.z,qdifz,epsilon2)) ;
    }

    for(int i=0;i<lsz;++i) {
      const vect3d drl = $lower[i]->$cl->$cellcenter - $cellcenter ;
      real qdifx = -dot(Xgr.x,drl) ;
      limi.x = min(limi.x,vlimit(Xcc.x,qmin.x,qmax.x,qdifx,epsilon2)) ;
      real qdify = -dot(Xgr.y,drl) ;
      limi.y = min(limi.y,vlimit(Xcc.y,qmin.y,qmax.y,qdify,epsilon2)) ;
      real qdifz = -dot(Xgr.z,drl) ;
      limi.z = min(limi.z,vlimit(Xcc.z,qmin.z,qmax.z,qdifz,epsilon2)) ;
    }
    
    $limiterv3d(V3) = realToDouble(limi) ;
  }

/**
 * @brief Venkatakrishnan 2 limiter, standard vect3d
 */
  $rule pointwise(limiterv3d(V3)<-cellcenter,V3,gradv3d(V3),firstOrderCells,
                                  Kl,vol,grid_vol,
                                  upper->cr->(V3,cellcenter),
                                  lower->cl->(V3,cellcenter),
                                  boundary_map->V3_f,boundary_map->facecenter),
        constraint(geom_cells,V2_limiter,vecNormLimiter) 
  {
    const vect3d Xcc = $V3 ;
    real refsq = dot(Xcc,Xcc) ;
    int numrefs = 1 ;
    vect3d qmax = Xcc ;
    vect3d qmin = qmax ;
    const tens3d Xgr = $gradv3d(V3) ;

    const int usz = $upper.size() ;
    numrefs += usz ;
    for(int i=0;i<usz;++i) {
      const vect3d Xi = $upper[i]->$cr->$V3 ;
      refsq += dot(Xi,Xi) ;
      qmin.x = min(qmin.x,Xi.x) ;
      qmax.x = max(qmax.x,Xi.x) ;
      qmin.y = min(qmin.y,Xi.y) ;
      qmax.y = max(qmax.y,Xi.y) ;
      qmin.z = min(qmin.z,Xi.z) ;
      qmax.z = max(qmax.z,Xi.z) ;
    }
    const int lsz= $lower.size() ;
    numrefs += lsz ;
    for(int i=0;i<lsz;++i) {
      const vect3d Xi = $lower[i]->$cl->$V3 ;
      refsq += dot(Xi,Xi) ;
      qmin.x = min(qmin.x,Xi.x) ;
      qmax.x = max(qmax.x,Xi.x) ;
      qmin.y = min(qmin.y,Xi.y) ;
      qmax.y = max(qmax.y,Xi.y) ;
      qmin.z = min(qmin.z,Xi.z) ;
      qmax.z = max(qmax.z,Xi.z) ;
    }
    const int bsz = $boundary_map.size() ;
    numrefs += bsz ;
    for(int i=0;i<bsz;++i) {
      const vect3d Xi = $boundary_map[i]->$V3_f ;
      refsq += dot(Xi,Xi) ;
      qmin.x = min(qmin.x,Xi.x) ;
      qmax.x = max(qmax.x,Xi.x) ;
      qmin.y = min(qmin.y,Xi.y) ;
      qmax.y = max(qmax.y,Xi.y) ;
      qmin.z = min(qmin.z,Xi.z) ;
      qmax.z = max(qmax.z,Xi.z) ;
    }      
    
    const real ref = 1e-20+sqrt(refsq)/numrefs ;
    const real Kl3 = $Kl*$Kl*$Kl*6./(M_PI*$grid_vol) ;
    const real epsilon2 = Kl3*$vol*ref*ref ;

    vect3d limi = ($firstOrderCells != 0)?vect3d(0.,0.,0.):vect3d(1.,1.,1.) ;

    for(int i=0;i<usz;++i) {
      const vect3d drl = $upper[i]->$cr->$cellcenter - $cellcenter ;
      real qdifx = -dot(Xgr.x,drl) ;
      limi.x = min(limi.x,vlimit(Xcc.x,qmin.x,qmax.x,qdifx,epsilon2)) ;
      real qdify = -dot(Xgr.y,drl) ;
      limi.y = min(limi.y,vlimit(Xcc.y,qmin.y,qmax.y,qdify,epsilon2)) ;
      real qdifz = -dot(Xgr.z,drl) ;
      limi.z = min(limi.z,vlimit(Xcc.z,qmin.z,qmax.z,qdifz,epsilon2)) ;
    }

    for(int i=0;i<lsz;++i) {
      const vect3d drl = $lower[i]->$cl->$cellcenter - $cellcenter ;
      real qdifx = -dot(Xgr.x,drl) ;
      limi.x = min(limi.x,vlimit(Xcc.x,qmin.x,qmax.x,qdifx,epsilon2)) ;
      real qdify = -dot(Xgr.y,drl) ;
      limi.y = min(limi.y,vlimit(Xcc.y,qmin.y,qmax.y,qdify,epsilon2)) ;
      real qdifz = -dot(Xgr.z,drl) ;
      limi.z = min(limi.z,vlimit(Xcc.z,qmin.z,qmax.z,qdifz,epsilon2)) ;
    }

    // Find the direction of maximum limiting
    double limm = realToDouble(min(limi.x,min(limi.y,limi.z)));
    // Zero the sensitivity portion of the limiter
    $limiterv3d(V3) = vect3d(limm,limm,limm);
  }

  /**
   * @brief Venkatakrishnan 2 limiter, standard vector
   * 
   */
  $rule pointwise(limiterv(V)<-cellcenter,V,gradv(V),firstOrderCells,
                                Kl,vol,grid_vol,
                                upper->cr->(V,cellcenter),
                                lower->cl->(V,cellcenter),
                                boundary_map->V_f,boundary_map->facecenter),
        constraint(geom_cells,V2_limiter,standarLimiter),prelude 
  {
    $limiterv(V).setVecSize($V.vecSize()) ;
  } compute {
    const int vs = $*V.vecSize() ;
    real ref = 0.0 ;
    for(int j=0;j<vs;++j)
      ref += fabs($V[j]) ;
    ref = max(ref,real_t(1e-5)) ;
    const real Kl3 = $Kl*$Kl*$Kl*6./(M_PI*$grid_vol) ;
    const real epsilon2 = Kl3*$vol*ref*ref ;
    
    for(int j=0;j<vs;++j) {
      const real Xcc = $V[j] ;
      real qmax = Xcc ;
      real qmin = qmax ;
      const vect3d Xgr = $gradv(V)[j] ;

      const int usz = $upper.size() ;
      for(int i=0;i<usz;++i) {
        const real Xi = $upper[i]->$cr->$V[j] ;
        qmin = min(qmin,Xi) ;
        qmax = max(qmax,Xi) ;
      }
      const int lsz= $lower.size() ;
      for(int i=0;i<lsz;++i) {
        const real Xi = $lower[i]->$cl->$V[j] ;
        qmin = min(qmin,Xi) ;
        qmax = max(qmax,Xi) ;
      }
      const int bsz = $boundary_map.size() ;
      for(int i=0;i<bsz;++i) {
        const real Xi = $boundary_map[i]->$V_f[j] ;
        qmin = min(qmin,Xi) ;
        qmax = max(qmax,Xi) ;
      }      
      
      real limi = ($firstOrderCells != 0)?0.0:1.0 ;

      for(int i=0;i<usz;++i) {
        const vect3d drl = $upper[i]->$cr->$cellcenter - $cellcenter ;
        real qdif = -dot(Xgr,drl) ;
        limi = min(limi,vlimit(Xcc,qmin,qmax,qdif,epsilon2)) ;
      }
      
      for(int i=0;i<lsz;++i) {
        const vect3d drl = $lower[i]->$cl->$cellcenter - $cellcenter ;
        real qdif = -dot(Xgr,drl) ;
        limi = min(limi,vlimit(Xcc,qmin,qmax,qdif,epsilon2)) ;
      }
      
      $limiterv(V)[j] = realToDouble(limi) ;
    }
  }

   /**
   * @brief Venkatakrishnan 2 limiter, normalized vector
   * 
   */
  $rule pointwise(limiterv(V)<-cellcenter,V,gradv(V),firstOrderCells,
                                Kl,vol,grid_vol,
                                upper->cr->(V,cellcenter),
                                lower->cl->(V,cellcenter),
                                boundary_map->V_f,boundary_map->facecenter),
        constraint(geom_cells,V2_limiter,vecNormLimiter),prelude 
  {
    $limiterv(V).setVecSize($V.vecSize()) ;
  } compute {
    const int vs = $*V.vecSize() ;
    real ref = 0.0 ;
    double limm = 1.0;
    for(int j=0;j<vs;++j)
      ref += fabs($V[j]) ;
    ref = max(ref,real_t(1e-5)) ;
    const real Kl3 = $Kl*$Kl*$Kl*6./(M_PI*$grid_vol) ;
    const real epsilon2 = Kl3*$vol*ref*ref ;
    
    for(int j=0;j<vs;++j) {
      const real Xcc = $V[j] ;
      real qmax = Xcc ;
      real qmin = qmax ;
      const vect3d Xgr = $gradv(V)[j] ;

      const int usz = $upper.size() ;
      for(int i=0;i<usz;++i) {
        const real Xi = $upper[i]->$cr->$V[j] ;
        qmin = min(qmin,Xi) ;
        qmax = max(qmax,Xi) ;
      }
      const int lsz= $lower.size() ;
      for(int i=0;i<lsz;++i) {
        const real Xi = $lower[i]->$cl->$V[j] ;
        qmin = min(qmin,Xi) ;
        qmax = max(qmax,Xi) ;
      }
      const int bsz = $boundary_map.size() ;
      for(int i=0;i<bsz;++i) {
        const real Xi = $boundary_map[i]->$V_f[j] ;
        qmin = min(qmin,Xi) ;
        qmax = max(qmax,Xi) ;
      }      
      
      real limi = ($firstOrderCells != 0)?0.0:1.0 ;

      for(int i=0;i<usz;++i) {
        const vect3d drl = $upper[i]->$cr->$cellcenter - $cellcenter ;
        real qdif = -dot(Xgr,drl) ;
        limi = min(limi,vlimit(Xcc,qmin,qmax,qdif,epsilon2)) ;
      }
      
      for(int i=0;i<lsz;++i) {
        const vect3d drl = $lower[i]->$cl->$cellcenter - $cellcenter ;
        real qdif = -dot(Xgr,drl) ;
        limi = min(limi,vlimit(Xcc,qmin,qmax,qdif,epsilon2)) ;
      }
      // Zero the sensitivity portion of the limiter
      $limiterv(V)[j] = realToDouble(limi) ;
      limm = min(realToDouble(limi),limm);
    }
    // limit vector based on strongest gradient direction
    for(int j=0;j<vs;++j) {
      $limiterv(V)[j] = limm;
    }
  }

  //-------------------------------------------------------------------
  // alternate stencil version

  $type cellStencil multiMap ;
/**
 * @brief Venkatakrishnan limiter, scalar, alternate stencil
 */
  $rule pointwise(stencil::limiters(S)<-cellcenter,S,grads(S),firstOrderCells,
                                        Kl,vol,grid_vol,
                                        cellStencil->(cellcenter,S),
                                        boundary_map->S_f,boundary_map->facecenter),
        constraint(geom_cells,V2_limiter) {
    const real Xcc = $S ;
    const vect3d cctr = $cellcenter ;

    real refsq = Xcc*Xcc ;
    int numrefs = 1 ;
    
    real qmax = Xcc ;
    real qmin = qmax ;
    const vect3d Xgr = $grads(S) ;

    const int ssz = $cellStencil.size() ;
    numrefs += ssz ;
    for(int i=0;i<ssz;++i) {
      const real Xi = $cellStencil[i]->$S ;
      refsq += Xi*Xi ;
      qmin = min(qmin,Xi) ;
      qmax = max(qmax,Xi) ;
    }
    const int bsz = $boundary_map.size() ;
    numrefs += bsz ;
    for(int i=0;i<bsz;++i) {
      const real Xi = $boundary_map[i]->$S_f ;
      refsq += Xi*Xi ;
      qmin = min(qmin,Xi) ;
      qmax = max(qmax,Xi) ;
    }      

    const real ref = 1e-20+sqrt(refsq)/numrefs ;
    const real Kl3 = $Kl*$Kl*$Kl*6./(M_PI*$grid_vol) ;
    const real epsilon2 = Kl3*$vol*ref*ref ;
    
    real limi = ($firstOrderCells != 0)?0.0:1.0 ;

    for(int i=0;i<ssz;++i) {
      const vect3d drl = $cellStencil[i]->$cellcenter - cctr ;
      real qdif = -dot(Xgr,drl) ;
      limi = min(limi,vlimit(Xcc,qmin,qmax,qdif,epsilon2)) ;
    }

    $limiters(S) = realToDouble(limi) ;
  }

/**
 * @brief Venkatakrishnan limiter, standard vect3d, alternate stencil
 */
  $rule pointwise(stencil::limiterv3d(V3)<-cellcenter,V3,gradv3d(V3),firstOrderCells,
                                            Kl,vol,grid_vol,
                                            cellStencil->(V3,cellcenter),
                                            boundary_map->V3_f,boundary_map->facecenter),
        constraint(geom_cells,V2_limiter,vecStandLimiter) 
  {
    const vect3d Xcc = $V3 ;
    real refsq = dot(Xcc,Xcc) ;
    int numrefs = 1 ;
    vect3d qmax = Xcc ;
    vect3d qmin = qmax ;
    const tens3d Xgr = $gradv3d(V3) ;

    const int ssz = $cellStencil.size() ;
    numrefs += ssz ;
    for(int i=0;i<ssz;++i) {
      const vect3d Xi = $cellStencil[i]->$V3 ;
      refsq += dot(Xi,Xi) ;
      qmin.x = min(qmin.x,Xi.x) ;
      qmax.x = max(qmax.x,Xi.x) ;
      qmin.y = min(qmin.y,Xi.y) ;
      qmax.y = max(qmax.y,Xi.y) ;
      qmin.z = min(qmin.z,Xi.z) ;
      qmax.z = max(qmax.z,Xi.z) ;
    }
    const int bsz = $boundary_map.size() ;
    numrefs += bsz ;
    for(int i=0;i<bsz;++i) {
      const vect3d Xi = $boundary_map[i]->$V3_f ;
      refsq += dot(Xi,Xi) ;
      qmin.x = min(qmin.x,Xi.x) ;
      qmax.x = max(qmax.x,Xi.x) ;
      qmin.y = min(qmin.y,Xi.y) ;
      qmax.y = max(qmax.y,Xi.y) ;
      qmin.z = min(qmin.z,Xi.z) ;
      qmax.z = max(qmax.z,Xi.z) ;
    }      
    
    const real ref = 1e-20+sqrt(refsq)/numrefs ;
    const real Kl3 = $Kl*$Kl*$Kl*6./(M_PI*$grid_vol) ;
    const real epsilon2 = Kl3*$vol*ref*ref ;

    vect3d limi = ($firstOrderCells != 0)?vect3d(0.,0.,0.):vect3d(1.,1.,1.) ;

    for(int i=0;i<ssz;++i) {
      const vect3d drl = $cellStencil[i]->$cellcenter - $cellcenter ;
      real qdifx = -dot(Xgr.x,drl) ;
      limi.x = min(limi.x,vlimit(Xcc.x,qmin.x,qmax.x,qdifx,epsilon2)) ;
      real qdify = -dot(Xgr.y,drl) ;
      limi.y = min(limi.y,vlimit(Xcc.y,qmin.y,qmax.y,qdify,epsilon2)) ;
      real qdifz = -dot(Xgr.z,drl) ;
      limi.z = min(limi.z,vlimit(Xcc.z,qmin.z,qmax.z,qdifz,epsilon2)) ;
    }

    $limiterv3d(V3) = realToDouble(limi) ;
  }

  /**
 * @brief Venkatakrishnan limiter, normalized vect3d, alternate stencil
 */
$rule pointwise(stencil::limiterv3d(V3)<-cellcenter,V3,gradv3d(V3),firstOrderCells,
                                          Kl,vol,grid_vol,
                                          cellStencil->(V3,cellcenter),
                                          boundary_map->V3_f,boundary_map->facecenter),
      constraint(geom_cells,V2_limiter,vecNormLimiter) 
{
  const vect3d Xcc = $V3 ;
  real refsq = dot(Xcc,Xcc) ;
  int numrefs = 1 ;
  vect3d qmax = Xcc ;
  vect3d qmin = qmax ;
  const tens3d Xgr = $gradv3d(V3) ;

  const int ssz = $cellStencil.size() ;
  numrefs += ssz ;
  for(int i=0;i<ssz;++i) {
    const vect3d Xi = $cellStencil[i]->$V3 ;
    refsq += dot(Xi,Xi) ;
    qmin.x = min(qmin.x,Xi.x) ;
    qmax.x = max(qmax.x,Xi.x) ;
    qmin.y = min(qmin.y,Xi.y) ;
    qmax.y = max(qmax.y,Xi.y) ;
    qmin.z = min(qmin.z,Xi.z) ;
    qmax.z = max(qmax.z,Xi.z) ;
  }
  const int bsz = $boundary_map.size() ;
  numrefs += bsz ;
  for(int i=0;i<bsz;++i) {
    const vect3d Xi = $boundary_map[i]->$V3_f ;
    refsq += dot(Xi,Xi) ;
    qmin.x = min(qmin.x,Xi.x) ;
    qmax.x = max(qmax.x,Xi.x) ;
    qmin.y = min(qmin.y,Xi.y) ;
    qmax.y = max(qmax.y,Xi.y) ;
    qmin.z = min(qmin.z,Xi.z) ;
    qmax.z = max(qmax.z,Xi.z) ;
  }      

  const real ref = 1e-20+sqrt(refsq)/numrefs ;
  const real Kl3 = $Kl*$Kl*$Kl*6./(M_PI*$grid_vol) ;
  const real epsilon2 = Kl3*$vol*ref*ref ;

  vect3d limi = ($firstOrderCells != 0)?vect3d(0.,0.,0.):vect3d(1.,1.,1.) ;

  for(int i=0;i<ssz;++i) {
    const vect3d drl = $cellStencil[i]->$cellcenter - $cellcenter ;
    real qdifx = -dot(Xgr.x,drl) ;
    limi.x = min(limi.x,vlimit(Xcc.x,qmin.x,qmax.x,qdifx,epsilon2)) ;
    real qdify = -dot(Xgr.y,drl) ;
    limi.y = min(limi.y,vlimit(Xcc.y,qmin.y,qmax.y,qdify,epsilon2)) ;
    real qdifz = -dot(Xgr.z,drl) ;
    limi.z = min(limi.z,vlimit(Xcc.z,qmin.z,qmax.z,qdifz,epsilon2)) ;
  }

  // Find the direction of maximum limiting
  double limm = realToDouble(min(limi.x,min(limi.y,limi.z)));
  // Zero the sensitivity portion of the limiter
  $limiterv3d(V3) = vect3d(limm,limm,limm);
}

/**
 * @brief Venkatakrishnan limiter, standard vector, alternate stencil
 */  
  $rule pointwise(stencil::limiterv(V)<-cellcenter,V,gradv(V),firstOrderCells,
                                        Kl,vol,grid_vol,
                                        cellStencil->(V,cellcenter),
                                        boundary_map->V_f,boundary_map->facecenter),
        constraint(geom_cells,V2_limiter,vecStandLimiter),prelude 
  {
    $limiterv(V).setVecSize($V.vecSize()) ;
  } compute {
    const int vs = $*V.vecSize() ;
    real ref = 0.0 ;
    for(int j=0;j<vs;++j)
      ref += fabs($V[j]) ;
    ref = max(ref,real_t(1e-5)) ;
    const real Kl3 = $Kl*$Kl*$Kl*6./(M_PI*$grid_vol) ;
    const real epsilon2 = Kl3*$vol*ref*ref ;
    
    for(int j=0;j<vs;++j) {
      const real Xcc = $V[j] ;
      real qmax = Xcc ;
      real qmin = qmax ;
      const vect3d Xgr = $gradv(V)[j] ;

      const int ssz = $cellStencil.size() ;
      for(int i=0;i<ssz;++i) {
        const real Xi = $cellStencil[i]->$V[j] ;
        qmin = min(qmin,Xi) ;
        qmax = max(qmax,Xi) ;
      }
      const int bsz = $boundary_map.size() ;
      for(int i=0;i<bsz;++i) {
        const real Xi = $boundary_map[i]->$V_f[j] ;
        qmin = min(qmin,Xi) ;
        qmax = max(qmax,Xi) ;
      }      
      
      real limi = ($firstOrderCells != 0)?0.0:1.0 ;

      for(int i=0;i<ssz;++i) {
        const vect3d drl = $cellStencil[i]->$cellcenter - $cellcenter ;
        real qdif = -dot(Xgr,drl) ;
        limi = min(limi,vlimit(Xcc,qmin,qmax,qdif,epsilon2)) ;
      }
      
      $limiterv(V)[j] = realToDouble(limi) ;
    }
  }

/**
 * @brief Venkatakrishnan limiter, normalized vector, alternate stencil
 */  
  $rule pointwise(stencil::limiterv(V)<-cellcenter,V,gradv(V),firstOrderCells,
                                        Kl,vol,grid_vol,
                                        cellStencil->(V,cellcenter),
                                        boundary_map->V_f,boundary_map->facecenter),
        constraint(geom_cells,V2_limiter,vecNormLimiter),prelude 
  {
    $limiterv(V).setVecSize($V.vecSize()) ;
  } compute {
    const int vs = $*V.vecSize() ;
    real ref = 0.0 ;
    double limm = 1.0;
    for(int j=0;j<vs;++j)
      ref += fabs($V[j]) ;
    ref = max(ref,real_t(1e-5)) ;
    const real Kl3 = $Kl*$Kl*$Kl*6./(M_PI*$grid_vol) ;
    const real epsilon2 = Kl3*$vol*ref*ref ;
    
    for(int j=0;j<vs;++j) {
      const real Xcc = $V[j] ;
      real qmax = Xcc ;
      real qmin = qmax ;
      const vect3d Xgr = $gradv(V)[j] ;

      const int ssz = $cellStencil.size() ;
      for(int i=0;i<ssz;++i) {
        const real Xi = $cellStencil[i]->$V[j] ;
        qmin = min(qmin,Xi) ;
        qmax = max(qmax,Xi) ;
      }
      const int bsz = $boundary_map.size() ;
      for(int i=0;i<bsz;++i) {
        const real Xi = $boundary_map[i]->$V_f[j] ;
        qmin = min(qmin,Xi) ;
        qmax = max(qmax,Xi) ;
      }      
      
      real limi = ($firstOrderCells != 0)?0.0:1.0 ;

      for(int i=0;i<ssz;++i) {
        const vect3d drl = $cellStencil[i]->$cellcenter - $cellcenter ;
        real qdif = -dot(Xgr,drl) ;
        limi = min(limi,vlimit(Xcc,qmin,qmax,qdif,epsilon2)) ;
      }
      // Zero the sensitivity portion of the limiter
      $limiterv(V)[j] = realToDouble(limi) ;
      limm = min(realToDouble(limi),limm);
    }
    // limit vector based on strongest gradient direction
    for(int j=0;j<vs;++j) {
      $limiterv(V)[j] = limm;
    }
  }
}
