#include "sched_tools.h"

using std::map ;
using std::vector ;
using std::set ;
using std::list ;

using std::pair ;
using std::make_pair ;

namespace Loci {

    // Create variable types in fact database
  // This is a necessary precursor to binding rules to the database
  void set_var_types(fact_db &facts, const digraph &dg) {

    // Get all the variables and rules represented in the graph
    variableSet all_vars = extract_vars(dg.get_all_vertices()) ;
    ruleSet     all_rules = extract_rules(dg.get_all_vertices()) ;

    // extract the qualified rules, these are rules that are
    // automatically generated by the system.  Since these rules
    // cannot provide type information directly, they are
    // singled out so that they can be handled as a separate case.
    ruleSet qualified_rules ;
    for(ruleSet::const_iterator ri=all_rules.begin();ri!=all_rules.end();++ri) {
      if(ri->type() == rule::INTERNAL)
        qualified_rules += *ri ;
    }

    // We need the transpose of the graph in order to find the rules that
    // generate a particular variable
    digraph dgt = dg.transpose() ;
  
    vector<pair<variable,variable> > rename_vars ;

    // Loop through the variables and type them when there is an appropriate
    // rule specification.  Deal with typing rules that rename their targets
    // separately
    for(variableSet::const_iterator
          vi=all_vars.begin();vi!=all_vars.end();++vi) {

      // only deal with rules given to the system by the user
      ruleSet rs = extract_rules(dgt[(*vi).ident()] - qualified_rules) ;
      if(rs == EMPTY) {
        continue ;
      }
      // storage for rename specification if one is found
      pair<variable,variable> rename_pair ;
      bool rename = false ;

      // Check all rules generating this variable, if the rules specify
      // renaming a variable for the target, then by default the target
      // will be an identical type to that of the previous variable.
      for(ruleSet::const_iterator ri=rs.begin();ri!=rs.end();++ri) {
        set<vmap_info>::const_iterator vmsi ;
        for(vmsi=ri->get_info().desc.targets.begin();
            vmsi!=ri->get_info().desc.targets.end(); ++vmsi)
          if(vmsi->assign.size() != 0) 
            for(int i=0;i<vmsi->assign.size();++i) {
              variable new_name = vmsi->assign[i].first ;
            
              if(new_name == *vi) {
                variable old_name = vmsi->assign[i].second ;
                if(rename && old_name != rename_pair.second) {
                  cerr << "rule " << *ri << endl 
                       << " is not consistent with other rules w/respect to "
                       << "renaming." << endl ;
                  exit(-1) ;
                }

                rename_pair = make_pair(new_name,old_name) ;
                rename = true ;
              }
            }
      }

      // If a rename variable was found, save this information for later
      // use and continue ;
      if(rename) {
        rename_vars.push_back(rename_pair) ;
        continue ;
      }

      // Otherwise pick the first rule in the set of rules that generates it
      // and query the rule for the type of variable *vi.  Set the variable
      // type appropriately in the fact database.

      rule pick = *rs.begin() ;
      const rule_impl::info &info = pick.get_info().desc ;
      storeRepP st = pick.get_info().rule_impl->get_store(*vi) ;
      if(st->RepType() == PARAMETER) 
        st->allocate(EMPTY) ;
      facts.set_variable_type(*vi,st) ;
    
    }

    // We now have to deal with internally generated rules that do operations
    // such as promoting variables from one time level to another,
    // generalizing a variable from a specific time to general time
    // (e.g. q{n}<-q{n=0}) and rules that create a priority relationship
    // from priority variables (e.g. qf<-degenerate::qf).
    // In addition we will deal with variables that may be renamed.
    // To do this, we must tell the fact database that variables are
    // synonyms (meaning that the two variable names are completely identical)
    // and variables that are aliases (meaning that the variable is exclusive
    // by name).  Since these variables have to be defined from
    // variables that are already typed and that these rules may
    // become chained, we need to make sure that we proceed in the
    // proper order.  We do this by creating a subgraph of these
    // internal rules, then we perform a topological sort on this
    // sub-graph to determine the order of typing

    // This is the internal rule graph
    digraph irg ;
    // place all promote, generalize, and priority rules into irg
    for(ruleSet::const_iterator
          ri = qualified_rules.begin() ; ri != qualified_rules.end();++ri) {
      if(ri->get_info().qualifier() == "promote" ||
         ri->get_info().qualifier() == "generalize" ||
         ri->get_info().qualifier() == "priority") {
        FATAL((ri->sources()).size()!=1)  ;
        FATAL((ri->targets()).size()!=1) ;
        variable source = *((ri->sources()).begin()) ;
        variable target = *((ri->targets()).begin()) ;
        irg.add_edge((*ri).ident(),target.ident()) ;
        irg.add_edge(source.ident(),(*ri).ident()) ;
      } else if(ri->get_info().qualifier() == "looping") {
        // create the iteration variable type
        time_ident tl = ri->source_time() ;
        variable v(tl) ;
        param<int> timevar ;
        storeRepP st = timevar.Rep() ;
        facts.set_variable_type(v,st) ;
      }
    }

    // Also add rules to represent renaming relationships
    for(int i=0;i<rename_vars.size();++i) {
      variable new_var = rename_vars[i].first ;
      variable old_var = rename_vars[i].second ;
    
      rule rr = make_rename_rule(new_var,old_var) ;
      irg.add_edge(old_var.ident(),rr.ident()) ;
      irg.add_edge(rr.ident(),new_var.ident()) ;
    }  

    // Perform a topological sort on the interal rule graph
    vector<digraph::vertexSet> components =
      component_sort(irg).get_components() ;

    for(int i=0;i<components.size();++i) {
      // Note, recursion should not occur among the internal rules
      FATAL(components[i].size()!=1) ;
      ruleSet rs = extract_rules(components[i]) ;
      // Note: components may be rules or variables, thus this check
      if(rs != EMPTY) {
        rule r = *rs.begin() ;
        if(r.sources().size() != 1) 
          cerr << "rule = " << r << endl ;
        FATAL(r.sources().size() != 1) ;
        FATAL(r.targets().size() != 1) ;
        // get source and target variables
        variable s = (*(r.sources().begin())) ;
        variable t = (*(r.targets().begin())) ;
        // A rename rule uses alias, while all others use synonym relationships
        if(r.get_info().qualifier() == "rename")
          facts.alias_variable(s,t) ;
        else {
          facts.synonym_variable(s,t) ;
        }
      }
    }

    // Check to make sure there are no type conflicts, loop over all
    // rules that are not internally generated.
    bool type_error = false ;
    ruleSet::const_iterator ri ;
    ruleSet rs = all_rules ;
    rs -= qualified_rules ;
    variableSet typed_vars = facts.get_typed_variables() ;
    
    for(ri=rs.begin();ri!=rs.end();++ri) {
      variableSet varcheck ;
      const rule_impl::info &finfo = ri->get_info().desc ;

      // Collect all variables for which are actually read or written in the class
      set<vmap_info>::const_iterator i ;
      for(i=finfo.sources.begin();i!=finfo.sources.end();++i) {
        for(int j=0;j<i->mapping.size();++j)
          varcheck += i->mapping[j] ;
        varcheck += i->var ;
      }
      for(i=finfo.targets.begin();i!=finfo.targets.end();++i) {
        for(int j=0;j<i->mapping.size();++j)
          varcheck += i->mapping[j] ;
        varcheck += i->var ;
        for(int k=0;k<i->assign.size();++k) {
          varcheck -= i->assign[k].first ;
          varcheck += i->assign[k].second ;
        }
      }

      variableSet::const_iterator vi ;
      for(vi = varcheck.begin();vi!=varcheck.end();++vi) {
        storeRepP rule_type = ri->get_rule_implP()->get_store(*vi)->getRep() ;
        if(typed_vars.inSet(*vi)) {
          storeRepP fact_type = facts.get_variable(*vi)->getRep() ;
          if(typeid(*rule_type) != typeid(*fact_type)) {
            cerr << "variable type mismatch for variable " << *vi << " in rule "
                 << *ri << endl ;
            cerr << "fact database has type " << typeid(*fact_type).name() << endl ;
            cerr << "rule has type " << typeid(*rule_type).name() << endl ;
            type_error = true ;
          }
        } else {
          facts.set_variable_type(*vi,rule_type) ;
          typed_vars += *vi ;
        }
      }
    }
    if(type_error)
      exit(-1) ;
  }


}
