#include <Loci.h>
#include <interpolate.h>
#include "FVMOverset/overset.h"
#include <Tools/tools.h>
#include <iostream>
#include <fstream>
#include <string>
using std::string ;
using std::endl ;
using std::cout ;
using std::cerr ;
using std::ifstream ;
using std::ios ;
#include <vector>
using std::vector ;
#include <map>
using std::map ;
#include <set>
using std::set ;


$include "FVM.lh"
$include "FVMOverset/overset.lh"

//#define MEMORY_DEBUG


#ifdef MEMORY_DEBUG
#include <malloc.h>

#endif
namespace {
#ifdef MEMORY_DEBUG
  void memSpace(string s) {
    using Loci::debugout ;
    debugout << s <<":" << endl;
    
    struct mallinfo info = mallinfo() ;
    int mem_alloc_local
      = (((info.hblkhd+512)>>10) + // mmap allocation in Kbytes
         ((info.uordblks+512)>>10)) ; // sbrk allocation in Kbytes
    int mem_req_local = mem_alloc_local + ((info.fordblks+512)>>10) ;
    int mem_alloc_global = 0 ;
    int mem_req_global = 0 ;
    MPI_Allreduce(&mem_alloc_local,&mem_alloc_global,1,MPI_INT,MPI_SUM,
                  MPI_COMM_WORLD) ;
    MPI_Allreduce(&mem_req_local,&mem_req_global,1,MPI_INT,MPI_SUM,
                  MPI_COMM_WORLD) ;
    int mem_alloc_max = 0 ;
    int mem_req_max = 0 ;
    MPI_Allreduce(&mem_alloc_local,&mem_alloc_max,1,MPI_INT,MPI_MAX,
                  MPI_COMM_WORLD) ;
    MPI_Allreduce(&mem_req_local,&mem_req_max,1,MPI_INT,MPI_MAX,
                  MPI_COMM_WORLD) ;

    debugout << "   alloc=" << ((mem_alloc_global+512)>>10) <<"Mb"
             << ",imb="
             << floor(((double(Loci::MPI_processes)*double(mem_alloc_max))/
                       double(mem_alloc_global)-1.)*100.) << "%" 
             << ",sys=" << ((mem_req_global+512)>>10) << "Mb"
             << ",imb="
             << floor(((double(Loci::MPI_processes)*double(mem_req_max))/
                       double(mem_req_global)-1.)*100.) << "%" 
             << ",local=" << ((mem_alloc_local+512)>>10) << "Mb" << endl ;

    debugout.flush() ;
  }

  string i2s(int i) {
    char buf[512] ;
    bzero(buf,512) ;
    snprintf(buf,511,"%d",i) ;
    return string(buf) ;
  }
#endif
}

#undef MEMORY_PROFILE
#ifdef MEMORY_DEBUG
#define MEMORY_PROFILE(X) memSpace(string(# X) +";" + string(__FILE__) + ";"+i2s(__LINE__))
#else
#define MEMORY_PROFILE(X)
#endif

namespace Loci {
  void fillInterpolationPoints(interpolate_points &ip,entitySet dom,
			       const_store<vector3d<real_t> > &pnts,
			       const_store<byte_t> &iblank) {
    int r = Loci::MPI_rank ;
    int p = Loci::MPI_processes ;
    int sz = dom.size() ;
    
    vector<int> dist_sizes(p,0) ;
    MPI_Allgather(&sz,1,MPI_INT,&dist_sizes[0],1,MPI_INT,MPI_COMM_WORLD) ;
    vector<int> offsets(p+1,0) ;
    for(int i=1;i<p+1;++i)
      offsets[i] = offsets[i-1]+dist_sizes[i-1] ;
    ip.distribution = offsets ;
    entitySet mydom ;
    if(sz == 0)
      mydom = EMPTY ;
    else
      mydom = interval(offsets[r],offsets[r]+sz-1) ;

    MEMORY_PROFILE(before_pos) ;
    ip.pos.allocate(mydom) ;
    ip.posid.allocate(mydom) ;
    MEMORY_PROFILE(after_pos) ;
    
    int ncnt = offsets[r] ;
    FORALL(dom,i) {
      ip.pos[ncnt] = pnts[i] ;
      ip.posid[ncnt] = i ;
      ncnt++ ;
    } ENDFORALL ;

    // Create kd_tree
    MEMORY_PROFILE(before_tree) ;
    //    using namespace Loci::kdTree ;
    coord3df zero(0,0,0) ;
    vector<coord3df > pts(mydom.size(),zero) ;
    vector<int> pt_id(mydom.size(),0) ;
    MEMORY_PROFILE(before_pack) ;

    int cnt = 0 ;
    FORALL(mydom,ii) {
      pt_id[cnt] = ii ;
      if(iblank[ip.posid[ii]] == 3)
	pt_id[cnt] = std::numeric_limits<int>::max() ;
      pts[cnt][0] = realToFloat(ip.pos[ii].x) ;
      pts[cnt][1] = realToFloat(ip.pos[ii].y) ;
      pts[cnt][2] = realToFloat(ip.pos[ii].z) ;
      cnt++ ;
    } ENDFORALL ;

    ip.kd = new Loci::kdTree::KDTree<float>(pts,pt_id) ;
    MEMORY_PROFILE(compute_end) ;
  }

  $type interpolatePoints(PNTS,MASK) blackbox<interpolate_points> ;
  $type PNTS store<vector3d<real_t> > ;
  $type MASK store<byte_t> ;
  
  $type ovc_check param<bool> ;

  $rule blackbox(interpolatePoints(PNTS,MASK)<-MASK,PNTS,ovc_check),
  option(disable_threading), prelude {
    MEMORY_PROFILE(compute_start) ;
    //    int r = Loci::MPI_rank ;
    int p = Loci::MPI_processes ;
    entitySet odom = $PNTS.domain()&$MASK.domain() ;

    if(p > 1)
      odom &= Loci::exec_current_fact_db->get_distribute_info()->my_entities ;
    
    // Remove any iblanked cells from the interpolation stencil.
    entitySet dom = EMPTY ;
    FORALL(odom,ii) {
      // Only zero iblanks donate to interpolation
      if($MASK[ii] == 0)
        dom += ii ;
      // 3 iblanks included to block interpolation across gaps
      if(*$ovc_check && $MASK[ii] == 3)
	dom += ii ;
      
    } ENDFORALL ;

    if($interpolatePoints(PNTS,MASK)->kd != 0)
      delete $interpolatePoints(PNTS,MASK)->kd ;
    $interpolatePoints(PNTS,MASK)->kd = 0 ;
    fillInterpolationPoints(*$interpolatePoints(PNTS,MASK),dom,$PNTS,$MASK) ;
  } ;
    

  typedef vector3d<float> coord3df ;
  

  ////////////////////////////////////////////////////////////////////////////
  //
  // Helpers for estimating stencil sizes
  //
  ////////////////////////////////////////////////////////////////////////////
  

  // donor cells are at the edge of a hole cut region.  They define the target
  // sizes for stencil searching
  $type donorCell store<Loci::byte_t> ;

  $rule unit(donorCell),constraint(geom_cells) {
    $donorCell = 0 ;
  }

  $type interface_BC Constraint ;

  $rule apply(ci->donorCell<-ci->iblank)[Loci::Maximum],constraint(interface_BC) {

    Loci::byte_t val = 1 ;
    if($ci->$iblank == 0)
      join($ci->$donorCell,val);
  }

  $rule apply((cl,cr)->donorCell<-(cl,cr)->iblank)[Loci::Maximum],constraint((cl,cr)->geom_cells) {
    if(($cl->$iblank & $cr->$iblank) == 0 &&
       ($cl->$iblank | $cr->$iblank) != 0) {
      Loci::byte_t val = 1 ;
      join($cl->$donorCell,val) ;
      join($cr->$donorCell,val) ;
    }
  }


  // CellSize2 is the square of the maximum edge length of a cell
  $type cellSize2 store<float> ;

  $rule unit(cellSize2),constraint(geom_cells) {
    $cellSize2 = 0 ;
  }

  $rule apply((cl,cr)->cellSize2<-face2node->pos)[Loci::Maximum],constraint((cl,cr)->geom_cells) {
    int sz = $face2node.size() ;
    vector3d<real_t>  vd = $face2node[0]->$pos-$face2node[sz-1]->$pos ;
    real_t d2 = dot(vd,vd) ;
    for(int i=1;i<sz;++i) {
      vd = $face2node[i-1]->$pos-$face2node[i]->$pos ;
      max(d2,dot(vd,vd)) ;
    }
    join($cl->$cellSize2,realToFloat(d2)) ;
    join($cr->$cellSize2,realToFloat(d2)) ;
  }
  // StencilSize2 is a global size estimate computed as part of the hole
  // cutting part.

  $type stencilSize2 param<double> ;
  $type stencilSizer blackbox<StencilSizer> ;

  $rule blackbox(stencilSizer<-cellcenter,cellSize2,donorCell,stencilSize2),
  option(disable_threading),prelude {
    using Loci::vpair ;
    using Loci::ORBSort ;

#ifdef REPORT_TIMES
    Loci::stopWatch s ;
    s.start() ;
#endif
    int p = Loci::MPI_processes ;
    entitySet dom = $cellcenter.domain() & $cellSize2.domain() ;
    if(p > 1)
      dom &= Loci::exec_current_fact_db->get_distribute_info()->my_entities ;
    
    double mxstencil = 10.*sqrt(*$stencilSize2) ;
    
    int cnt = 0 ;
    // Count donor cells
    FORALL(dom,cc) {
      if($donorCell[cc] != 0)
        cnt++ ;
    } ENDFORALL ;
    
    vector<vpair> points(cnt) ;
    cnt = 0 ;
    // Collect points and stencil sizes
    FORALL(dom,cc) {
      if($donorCell[cc] != 0) {
        points[cnt].first = realToFloat($cellcenter[cc]) ;
        double size_norm = mxstencil/sqrt(max($cellSize2[cc],1e-30f)) ;
        int size_i = max(int(min(2e9,size_norm)),1) ;
        points[cnt].second = size_i ;
        cnt++ ;
      }
    } ENDFORALL ;
    

    Loci::balanceDistribution(points,MPI_COMM_WORLD) ;
    
    // Sort points using ORB method
    ORBSort(points,MPI_COMM_WORLD) ;

    cnt = points.size() ;

    // Divide this processor points into a set of bounding boxes and
    // reduce them to a subset of point-to-spacing values
    // Estimate the division depth by finding log base 4 of the number
    // of processors
    int div=6 ;
    int ptmp  = p/4 ;
    while(ptmp>0) {
      div=max(div-1,3) ; // Always divide into at least 8 parts per processor
      ptmp=ptmp/4 ;
    }
    
    // The minimum grouping size for the stencil estimate.  This will ensure
    // that a region is fairly represented.
    int minGroupSize = 50 ;
    vector<vpair> results ;
    collectGroups(results,points,0,cnt,div,minGroupSize) ;

    // Now collect all of these points onto all of the processors
    vector<int> rcounts(p,0) ;
    int tsz = results.size() ;
    MPI_Allgather(&tsz,1,MPI_INT,&rcounts[0],1,MPI_INT,MPI_COMM_WORLD) ;
    
    int rsize = rcounts[0] ;
    for(int i=1;i<p;++i)
      rsize += rcounts[i] ;
    
    vector<vpair> recvdata(rsize) ;

    // Adjust counts to account for bytes in vpair
    for(int i=0;i<p;++i)
      rcounts[i] = rcounts[i] * sizeof(vpair) ;
    // Compute displacement array
    vector<int> rdispls(p,0) ;
    rdispls[0] = 0 ;
    for(int i=1;i<p;++i)
      rdispls[i] = rdispls[i-1]+rcounts[i-1] ;
    
    MPI_Allgatherv((void *)&results[0],sizeof(vpair)*tsz,MPI_BYTE,
                   (void *)&recvdata[0],&rcounts[0],&rdispls[0],MPI_BYTE,
                   MPI_COMM_WORLD) ;
    vector<int> pt_id(rsize,0);
    coord3df pt0(0.0f,0.0f,0.0f) ;
    vector<coord3df > pts(rsize,pt0) ;
    for(int i=0;i<rsize;++i) {
      pt_id[i] = recvdata[i].second ;
      coord3df pt(recvdata[i].first.x,
                  recvdata[i].first.y,
                  recvdata[i].first.z) ;
      pts[i] = pt ;
    }
    $stencilSizer->kd = new Loci::kdTree::KDTree<float>(pts,pt_id) ;
    $stencilSizer->ref_size = mxstencil ;
#ifdef REPORT_TIMES
    Loci::debugout << "time to build stencilSizer: " << s.stop() << endl ;
#endif
  } ;
  

  $rule unit(interpolateFaceStencil), constraint(UNIVERSE),option(disable_threading),prelude {} ;
  

  $rule apply(interpolateFaceStencil<-interpolatePoints(cellcenter,iblank),stencilSize2,interpolateMinStencilSize,stencilSizer,facecenter,area,ci->cellcenter,ci->iblank)[Loci::NullOp] , option(disable_threading), prelude {
    
//    using namespace kdTree ;
    MEMORY_PROFILE(compute_start) ;
    using Loci::debugout ;

#ifdef REPORT_TIMES
    Loci::stopWatch s ;
    s.start() ;
    MPI_Barrier(MPI_COMM_WORLD) ;
    //    Loci::debugout << "time to sync: " << s.stop() << endl ;
    s.start() ;
#endif    

    entitySet odom = entitySet(seq) ;
    entitySet dom ;
    int xclude = 0 ;
    FORALL(odom,fc) {
      if($iblank[$ci[fc]] > 2) {
        xclude++ ;
      } else
        dom += fc ;
    } ENDFORALL ;

    // Decompose points into a set of bounding boxes
    int sz = dom.size() ;
    vector<Loci::kdTree::KDTree<float>::coord_info> pbox(sz) ;
    vector<vector3d<real_t> > ndelta(sz) ;
    int cnt =0 ;
    double delta_stencil = 0 ;
    FORALL(dom,fc) {
      const vector3d<real_t>  fcenter = $facecenter[fc] ;
      pbox[cnt].coords[0] = realToFloat(fcenter.x) ;
      pbox[cnt].coords[1] = realToFloat(fcenter.y) ;
      pbox[cnt].coords[2] = realToFloat(fcenter.z) ;
      delta_stencil = max(delta_stencil,
                          double($stencilSizer->getSpacing(pbox[cnt].coords))) ;
      pbox[cnt].id = fc ;
      cnt++ ;
    } ENDFORALL ;
    //    Loci::debugout << "cnt = " << cnt << "xclude = " <<xclude << endl;
    //    real delta_stencil  = sqrt(*stencilSize2*2) ;
    //    delta_stencil *=  1.1 ; // double search depth to make sure to find a point
    //    delta_stencil *=  4.1 ; // double search depth to make sure to find a point
#ifdef VERBOSE
    Loci::debugout << "face delta = " << delta_stencil << endl ;
#endif
    delta_stencil *= 4.0 ; // add margin for error
    
    // This call breaks the coordinate points into a set of bounding
    // boxes

    // Compute how big the decomposition chunks should be
    int tsz = 0 ;
    MPI_Allreduce(&sz,&tsz,1,MPI_INT,MPI_SUM,MPI_COMM_WORLD) ;

    // split boxes until each box has no more then split_lim points
    int p = Loci::MPI_processes ;
    int split_lim = max(256,tsz/(p)) ;
#ifdef VERBOSE
    Loci::debugout << "face split_lim = " << split_lim << endl ;
#endif
    // Get bounding boxes
    vector<bound_info> boxes ;
    getBoundingBoxes(pbox,boxes,4,delta_stencil*8.0,split_lim) ;
#ifdef VERBOSE
    Loci::debugout << "found " << boxes.size() << " bounding boxes:" << endl ;
    Loci::debugout << "pbox.size() = " << pbox.size() << endl ;
#endif

    for(size_t i=0;i<pbox.size();++i) {
      int fc = pbox[i].id ;
      vector3d<real_t>  fcenter = $facecenter[fc] ;
        
      vector3d<real_t>  n = $area[fc].n ;
      // compute local stencil distance as either the normal projected
      // distance from this side of the face to the interior cell, or
      // to the closest projected point found from the other side,
      // whichever is largest
      real_t locdist = norm(fcenter-$cellcenter[$ci[fc]]) ;
      ndelta[i] = n*locdist ;
    }

    // Adjust bounding boxes by stencil size
    for(size_t i=0;i<boxes.size();++i) {
      float spacing = 0  ;
      for(int j=boxes[i].start;j<=boxes[i].stop;++j)
        spacing = max(spacing,$stencilSizer->getSpacing(pbox[j].coords)) ;
      spacing *= 6.2 ;
      spacing += *$interpolateMinStencilSize ;
      Loci::debugout << "boxes[" << i << "], spacing =" << spacing
                     << ", size = " << boxes[i].stop-boxes[i].start+1
                     << ", start = " << boxes[i].start
                     << endl ;
      boxes[i].bnd.minc[0] -= spacing ;
      boxes[i].bnd.minc[1] -= spacing ;
      boxes[i].bnd.minc[2] -= spacing ;
      boxes[i].bnd.maxc[0] += spacing ;
      boxes[i].bnd.maxc[1] += spacing ;
      boxes[i].bnd.maxc[2] += spacing ;
    }

#ifdef REPORT_TIMES
    Loci::debugout << "time to find bounding boxes: " << s.stop() << endl ;
    s.start() ;
#endif    

    // Now distribute the bounding boxes to all processors
    vector<int> box_sp,box_tp,b_sizes,send_block_id,recv_block_id ;
    
    boundingBoxDistribution(box_sp,box_tp,b_sizes,send_block_id,recv_block_id,
                            boxes,MPI_COMM_WORLD) ;


    // ------------------------------------------------------------------------
    // receive search points
    vector<vector<Loci::kdTree::KDTree<float>::coord_info>  > loc_pbox ;
    communicateBoxPoints(loc_pbox,box_sp,box_tp,b_sizes,
                         send_block_id,recv_block_id,pbox,boxes,
                         MPI_COMM_WORLD) ;
    vector<vector<vector3d<real_t> > > loc_ndelta ;
    communicateBoxPoints(loc_ndelta,box_sp,box_tp,b_sizes,
                         send_block_id,recv_block_id,ndelta,boxes,
                         MPI_COMM_WORLD) ;
    
#ifdef REPORT_TIMES
    Loci::debugout << "face time recv box search points: " << s.stop() << endl ;
    s.start() ;
#endif    
    //-------------------------------------------------------------------------
    // recieve target points

    // First collect bounding box information for each block
    vector<bound_info> boxes_g ;
    allGatherVec(boxes_g,boxes,MPI_COMM_WORLD) ;


#ifdef REPORT_TIMES
    Loci::debugout << "time allGatherVec boxes: " << s.stop() << endl ;
    s.start() ;
#endif
//    using namespace Loci::kdTree ;
    const interpolate_points *interp_pnts = &(*$interpolatePoints(cellcenter,iblank)) ;
    vector<vector<Loci::kdTree::KDTree<float>::coord_info>  > recv_targets ;
    recieveTargetPoints(recv_targets,interp_pnts->kd,
                        boxes_g,box_sp,box_tp,b_sizes,
                        send_block_id,recv_block_id,
                        MPI_COMM_WORLD) ;

#ifdef REPORT_TIMES
    Loci::debugout << "time to receive target points: " << s.stop() << endl ;
    s.start() ;
#endif
    // Now we build the stencils
    vector< vector<Array<int,4> > >    stencil_block(recv_block_id.size()) ;
    vector< vector<Array<real_t,4> > >   weights_block(recv_block_id.size()) ;

    int st_error = 0 ;
    int st_warnings = 0 ;
    // After sending, we can compute stencils for each block.
    for(size_t i=0;i<recv_block_id.size();++i) {
      int bk = recv_block_id[i] ;
      int ssz = loc_pbox[i].size() ; // Search points for block bk

      store<vector3d<real_t> > loc ;
      store<int> ids ;
      int tsz = recv_targets[bk].size() ;
      entitySet locdom = interval(0,tsz-1) ;
      loc.allocate(locdom) ;
      ids.allocate(locdom) ;
      for(int ii=0;ii<tsz;++ii) {
	loc[ii].x = recv_targets[bk][ii].coords[0] ;
	loc[ii].y = recv_targets[bk][ii].coords[1] ;
	loc[ii].z = recv_targets[bk][ii].coords[2] ;
	ids[ii] = recv_targets[bk][ii].id ;
	recv_targets[bk][ii].id = ii ;
      }

      Loci::kdTree::KDTree<float> stree(recv_targets[bk]) ;
#ifdef VERBOSE
      Loci::debugout << "bk=" << bk << ",bksz=" << tsz<< endl ;
#endif

      vector<Array<int,4> > tmp1(ssz*2) ;
      vector<Array<real_t,4> > tmp2(ssz*2) ;
      stencil_block[i].swap(tmp1) ;
      weights_block[i].swap(tmp2) ;
      for(int j=0;j<ssz;++j) {
        delta_stencil =max(delta_stencil,
                           $stencilSizer->getSpacing(loc_pbox[i][j].coords)*6.2) ;
      }
                           ;
      for(int j=0;j<ssz;++j) {

        
	vector3d<real_t>  fcenter(loc_pbox[i][j].coords[0],
                       loc_pbox[i][j].coords[1],
                       loc_pbox[i][j].coords[2]) ;
        real_t dnorm = norm(loc_ndelta[i][j]) ;
        real_t dval = dnorm ;
        vector3d<real_t>  n = (1./dnorm)*loc_ndelta[i][j] ;
        int xnd = - 1;
        {
          bool invalid_stencil=true ;
          vector<int> neighbors = get_stencil(stree,fcenter,delta_stencil*2) ;
          real_t mdist = 1e33 ;
          real_t mind = 1e33 ;
          for(size_t k=0;k<neighbors.size();++k) {
            int nd = neighbors[k] ;

            if(nd > 0) {
              vector3d<real_t>  pt = loc[nd] ;
              real_t dp = dot(pt-fcenter,n) ;
              if(dp > 0) {
                invalid_stencil = false ;
                real_t d = norm(pt-fcenter) ;
                if(d < mind) {
                  mind = d ;
                  xnd = nd ;
                  mdist = min(mdist,dp) ;
                }
              }
            }
          }
          
          if(invalid_stencil) {
            Loci::kdTree::KDTree<float>::bounds box ;
            coord3df ccenter =realToFloat(fcenter) ;

            for(int i=0;i<3;++i) {
              box.minc[i] = ccenter[i] ;
              box.maxc[i] = ccenter[i] ;
              if(n.x > -1e-9)
                box.maxc[0] += 1e30 ;
              if(n.x < 1e-9)
                box.minc[0] -= 1e30 ;
              if(n.y > -1e-9)
                box.maxc[1] += 1e30 ;
              if(n.y < 1e-9)
                box.minc[1] -= 1e30 ;
              if(n.z > -1e-9)
                box.maxc[2] += 1e30 ;
              if(n.z < 1e-9)
                box.minc[2] -= 1e30 ;
            }
            int id = stree.find_closest_box(ccenter,box) ;
            if(id >=0 && id != std::numeric_limits<int>::max()) {
              vector3d<real_t>  pt = loc[id] ;
              invalid_stencil = false ;
              real_t d = norm(pt-fcenter) ;
              mind = d ;
              xnd = id ;
              mdist = min(mdist,d) ;
            }

            if(invalid_stencil) {
              Loci::debugout << "Warning: invalid face stencil!" << endl ;
            }
          }
          if(!invalid_stencil)
            dval = max(dnorm,mdist) ;
        }

        real_t locdist = dval*1.05 ; // Saftey factor to ensure proper upwinding

        vector3d<real_t>  prr = fcenter+n*(locdist*3.) ;
        vector3d<real_t>  pr  = fcenter+n*locdist ;
        // right stencil
        {
          vector<int> ntmp = get_stencil(stree,pr,delta_stencil*2.0) ;
          vector<int> neighbors ;
          for(size_t k=0;k<ntmp.size();++k) {
            //            if(dot(n,loc[ntmp[k]]-fcenter) > 0)
              neighbors.push_back(ntmp[k]) ;
          }
          // compute stencil weights
          vector<real_t> w  ;
          stencil_weights(w,neighbors,loc,pr) ;

          real_t w_tot = 0 ;
          for(size_t k=0;k<neighbors.size();++k) {
            if(dot(n,loc[neighbors[k]]-fcenter) < 0)
              w_tot += w[k] ;
          }
          if(w_tot > .5) { // Too much downwind bias
            w_tot = 0 ;
            for(size_t k=0;k<neighbors.size();++k) {
              if(dot(n,loc[neighbors[k]]-fcenter) < 0)
                w[k] = 0 ;
              w_tot += w[k] ;
            }
            if(w_tot != 0) {
              real_t rw_tot = 1./w_tot ;
              for(size_t k=0;k<neighbors.size();++k) 
                w[k] = w[k]*rw_tot ;
            }
          }

          w_tot = 0 ;
          for(size_t k=0;k<w.size();++k)
            w_tot += w[k] ;
          if(w_tot <= .5) {
            w.clear() ;
            neighbors.clear() ;
            if(xnd >= 0) {
              neighbors.push_back(xnd) ;
              w.push_back(1.0) ;
            } else {
              coord3df ccenter = realToFloat(fcenter) ; ;
              neighbors.push_back(stree.find_closest(ccenter)) ;
              if(neighbors[0]<0 || neighbors[0] == std::numeric_limits<int>::max())
                neighbors[0] = 0 ;
              w.push_back(0.0) ;
              st_error++ ;
              Loci::debugout << "face degenerate, delta = " << delta_stencil << endl ;
            }
          }
            
              
          if(w.size() < 3) {
            st_warnings++ ;
            Loci::debugout << "face cr suboptimal stencil, delta = " << delta_stencil << endl ;
          }
          Array<int,4> st ;
          Array<real_t,4> wt ;
          int nsz = neighbors.size() ;

          if(nsz > 0) {
            for(int k=0;k<nsz;++k) {
              st[k] = ids[neighbors[k]] ;
              wt[k] = w[k] ;
            }
            for(int k=nsz;k<4;++k) {
              st[k] = st[nsz-1] ;
              wt[k] = 0 ;
            }
          } else {
            for(int k=0;k<4;++k) {
              st[k] = 0 ;
              wt[k] = 0 ;
            }
          }
          
          stencil_block[i][j*2+1] = st ;
          weights_block[i][j*2+1] = wt ;
        }

        // right right stencil
        {
          vector<int> neighbors = get_stencil(stree,prr,delta_stencil*2.0) ;
	  
          if(neighbors.size() < 1) 
            st_error++ ;
          if(neighbors.size() < 1)
            Loci::debugout << "face degenerate, delta = " << delta_stencil << endl ;


          // compute stencil weights
          vector<real_t> w  ;
          stencil_weights(w,neighbors,loc,prr) ;


          real_t w_tot = 0 ;
          for(size_t k=0;k<neighbors.size();++k) {
            if(dot(n,loc[neighbors[k]]-fcenter) < 0)
              w_tot += w[k] ;
          }
          if(w_tot > .5) { // Too much downwind bias
            w_tot = 0 ;
            for(size_t k=0;k<neighbors.size();++k) {
              if(dot(n,loc[neighbors[k]]-fcenter) < 0)
                w[k] = 0 ;
              w_tot += w[k] ;
            }
            if(w_tot == 0) 
              st_warnings++ ;
            else  {
              real_t rw_tot = 1./w_tot ;
              for(size_t k=0;k<neighbors.size();++k) 
                w[k] = w[k]*rw_tot ;
            }
          }
            
          if(w.size() < 3) {
            st_warnings++ ;
            Loci::debugout << "face suboptimal stencil, delta = " << delta_stencil << endl ;
          }

          Array<int,4> st ;
          Array<real_t,4> wt ;
          int nsz = neighbors.size() ;

          // If degenerate, then switch to first order
          w_tot = 0 ;
          for(size_t k=0;k<w.size();++k)
            w_tot += w[k] ;
          if(w_tot <= .5) {
            st = stencil_block[i][j*2+1] ;
            wt = weights_block[i][j*2+1] ;
          } else {
            if(nsz > 0) {
              for(int k=0;k<nsz;++k) {
                st[k] = ids[neighbors[k]] ;
                wt[k] = w[k] ;
              }
              for(int k=nsz;k<4;++k) {
                st[k] = st[nsz-1] ;
                wt[k] = 0 ;
              }
            } else {
              for(int k=0;k<4;++k) {
                st[k] = 0 ;
                wt[k] = 0 ;
              }
            }
          }
          stencil_block[i][j*2+0] = st ;
          weights_block[i][j*2+0] = wt ;
        }
      }
#ifdef VERBOSE
      Loci::debugout << endl ;
#endif

    }

#ifdef VERBOSE
    Loci::debugout << "st_error = " << st_error << endl ;
#endif
    
    int tot = 0 ;
    MPI_Allreduce(&st_error,&tot,1,MPI_INT,MPI_SUM,MPI_COMM_WORLD) ;
    if(tot != 0) {
      if(Loci::MPI_rank == 0) {
        cerr << "STENCIL ERROR:  Degenerate interface stencil formed, aborting" << endl ;
        //        Loci::Abort() ;
      }
    }
    
    MPI_Allreduce(&st_warnings,&tot,1,MPI_INT,MPI_SUM,MPI_COMM_WORLD) ;
    if(Loci::MPI_rank == 0 && tot != 0) {
      cerr << "Warning: Suboptimal interface stencil in reconstruction: " << tot << endl ;
    }
      
#ifdef REPORT_TIMES
    Loci::debugout << "time to generate stencils: " << s.stop() << endl ;
    s.start() ;
#endif    
    // Then we send the stencils back.
    {
      
      vector<Array<int,4> > stencil_rcv ;
      returnBlockData(stencil_rcv,stencil_block,2,boxes,
                      box_sp,box_tp,b_sizes,send_block_id,recv_block_id,
                      MPI_COMM_WORLD) ;

      int stsz = stencil_rcv.size() ;
      vector<int> stmp(stsz*4) ;
      for(int i=0;i<stsz;++i) {
	for(int j=0;j<4;++j) {
	  stmp[i*4+j] = stencil_rcv[i][j] ;
        }
      }
      
      std::sort(stmp.begin(),stmp.end()) ;
      
      vector<int>::const_iterator se = std::unique(stmp.begin(),stmp.end()) ;

      int nids = se-stmp.begin() ;
      store<int> ids ;
      entitySet locdom = interval(0,nids-1) ;
      ids.allocate(locdom) ;

      map<int,int> rmap ;
      cnt = 0 ;
      for(vector<int>::const_iterator ii=stmp.begin();ii!=se;++ii) {
	ids[cnt] = *ii ;
	rmap[*ii] = cnt ;
	cnt++ ;
      }

      for(int i=0;i<stsz;++i)
	for(int j=0;j<4;++j) {
	  int srcv = stencil_rcv[i][j] ;
	  map<int,int>::const_iterator mi = rmap.find(srcv) ;
	  stencil_rcv[i][j] = (mi==rmap.end())?0:mi->second ;
	  //rmap[stencil_rcv[i][j]] ;
	}
      vector<int> send_info, req_sizes, snd_sizes, access ;
      
      
      getCommSchedFromStencil(send_info,req_sizes,snd_sizes, access,
			      stencil_rcv,ids,interp_pnts->distribution) ;
      
      for(size_t i=0;i<send_info.size();++i)
	send_info[i] = interp_pnts->posid[send_info[i]] ;
      remapStencil(stencil_rcv,access, ids) ;

      Map slookup ;
      slookup.allocate(dom) ;
      for(size_t i=0;i<pbox.size();++i)
	slookup[pbox[i].id] = i ;

      $interpolateFaceStencil->stencils.swap(stencil_rcv) ;
      $interpolateFaceStencil->send_info.swap(send_info) ;
      $interpolateFaceStencil->snd_sizes.swap(snd_sizes) ;
      $interpolateFaceStencil->req_sizes.swap(req_sizes) ;
      $interpolateFaceStencil->slookup = slookup.Rep() ;
    }

    // Send weights
    vector<Array<real_t,4> > weight_rcv ;
    //    returnBlockData(weight_rcv,weights_block,3,boxes,
    returnBlockData(weight_rcv,weights_block,2,boxes,
                    box_sp,box_tp,b_sizes,send_block_id,recv_block_id,
                    MPI_COMM_WORLD) ;
    
    $interpolateFaceStencil->weights.swap(weight_rcv) ;

    // put stencil blocks into place, renumber to local numbering and set ids
    // send weights

    // generate stencil communication schedule


#ifdef REPORT_TIMES
    Loci::debugout << "time in Face code find stencil: " << s.stop() << endl ;
    s.start() ;
#endif
#ifdef REPORT_TIMES
    MPI_Barrier(MPI_COMM_WORLD) ;
    Loci::debugout << "time to sync: " << s.stop() << endl ;
    s.start() ;
#endif    
    MEMORY_PROFILE(compute_end) ;
    return ;
  } ;


  $type X store<real_t> ;
  // Please note this is where we might want to use an access map
  $rule pointwise(interpolateFace(X)<-interpolateFaceStencil,ci->(X,iblank)),option(disable_threading), prelude {
    MEMORY_PROFILE(compute_start) ;
    entitySet odom = entitySet(seq) ;
    entitySet dom ;
    FORALL(odom,fc) {
      if($iblank[$ci[fc]] > 2) {
	$interpolateFace(X)[fc] = $X[$ci[fc]] ;
      } else
	dom += fc ;
    } ENDFORALL ;
      
    Map slookup ;
    slookup = $interpolateFaceStencil->slookup ;
    store<real_t> Xstencil ;
    sendStencilData(Xstencil,$X,
		    $interpolateFaceStencil->send_info,
		    $interpolateFaceStencil->req_sizes,
		    $interpolateFaceStencil->snd_sizes)  ;
    const vector<Array<real_t,4> > &weights = $interpolateFaceStencil->weights ;
    const vector<Array<int,4> > &stencils = $interpolateFaceStencil->stencils ;

    FORALL(dom,fc) {
      int cnt = slookup[fc]*2 ;
      int cll = cnt+0 ;
      int cl =  cnt+1 ;

      real_t vll = 0 ;
      for(int j=0;j<4;++j) {
	vll += weights[cll][j]*Xstencil[stencils[cll][j]] ;
      }
      real_t vl = 0 ;
      for(int j=0;j<4;++j) {
	vl += weights[cl][j]*Xstencil[stencils[cl][j]] ;
      }
      real_t vr = 0 ;
      vr = $X[$ci[fc]] ;
      real_t dv = (vl-vll) ;
      if(dv < 0.)
	dv += -1e-30 ;
      else
	dv += 1e-30 ;

      // Use Van Albada limiter to estimate second order upwind
      // extrapolation to the face
      const real_t r = max<real_t>(0.0,(vr-vl)/dv) ;
      const real_t lim = (r+r*r)/(1.+r*r) ;
      $interpolateFace(X)[fc] = vl + 0.5*lim*(vl-vll) ;

    } ENDFORALL ;
    MEMORY_PROFILE(compute_end) ;
  } ;

  $type X store<vector3d<real_t> > ;
  
  // Please note this is where we might want to use an access map
  $rule pointwise(interpolateFace_v3d(X)<-interpolateFaceStencil,ci->(X,iblank)),option(disable_threading), prelude {
      MEMORY_PROFILE(compute_start) ;
      entitySet odom = entitySet(seq) ;
      entitySet dom ;
      FORALL(odom,fc) {
        if($iblank[$ci[fc]] > 2) {
          $interpolateFace_v3d(X)[fc] = $X[$ci[fc]] ;
        } else
          dom += fc ;
      } ENDFORALL ;
      
      Map slookup ;
      slookup = $interpolateFaceStencil->slookup ;
      store<vector3d<real_t> > Xstencil ;
      sendStencilData(Xstencil,$X,
                      $interpolateFaceStencil->send_info,
                      $interpolateFaceStencil->req_sizes,
                      $interpolateFaceStencil->snd_sizes)  ;
      const vector<Array<real_t,4> > &weights 
	= $interpolateFaceStencil->weights ;
      const vector<Array<int,4> > &stencils 
	= $interpolateFaceStencil->stencils ;

      FORALL(dom,fc) {
        int cnt = slookup[fc]*2 ;

        int cll = cnt+0 ;
        int cl =  cnt+1 ;

        vector3d<real_t>  vll = vector3d<real_t> (0,0,0) ;
        for(int j=0;j<4;++j) {
          vll += weights[cll][j]*Xstencil[stencils[cll][j]] ;
        }
        vector3d<real_t>  vl = vector3d<real_t> (0,0,0) ;
        for(int j=0;j<4;++j) {
          vl += weights[cl][j]*Xstencil[stencils[cl][j]] ;
        }
        vector3d<real_t>  vr = vector3d<real_t> (0,0,0) ;
        vr = $X[$ci[fc]] ;
        vector3d<real_t>  dv = (vl-vll) ;
        if(dv.x < 0.)
          dv.x += -1e-30 ;
        else
          dv.x += 1e-30 ;

        if(dv.y < 0.)
          dv.y += -1e-30 ;
        else
          dv.y += 1e-30 ;

        if(dv.z < 0.)
          dv.z += -1e-30 ;
        else
          dv.z += 1e-30 ;

        // Use Van Albada limiter to estimate second order upwind
        // extrapolation to the face
        const real_t rx = (vr.x-vl.x)/dv.x ;
        const real_t limx= (rx+rx*rx)/(1.+rx*rx) ;
        $interpolateFace_v3d(X)[fc].x = vl.x + 0.5*limx*(vl.x-vll.x) ;
        const real_t ry = (vr.y-vl.y)/dv.y ;
        const real_t limy= (ry+ry*ry)/(1.+ry*ry) ;
        $interpolateFace_v3d(X)[fc].y = vl.y + 0.5*limy*(vl.y-vll.y) ;
        const real_t rz = (vr.z-vl.z)/dv.z ;
        const real_t limz= (rz+rz*rz)/(1.+rz*rz) ;
        $interpolateFace_v3d(X)[fc].z = vl.z + 0.5*limz*(vl.z-vll.z) ;
      } ENDFORALL ;
      MEMORY_PROFILE(compute_end) ;
  } ;

  $type X storeVec<real_t> ;  
  $rule pointwise(interpolateFace_vec(X)<-ci->(X,iblank),interpolateFaceStencil),
    option(disable_threading),prelude {
    MEMORY_PROFILE(compute_start) ;
    const int vs = $X.vecSize() ;
    $interpolateFace_vec(X).setVecSize($X.vecSize()) ;
    entitySet odom = entitySet(seq) ;
    entitySet dom ;
    FORALL(odom,fc) {
      if($iblank[$ci[fc]] > 2) {
	$interpolateFace_vec(X)[fc] = $X[$ci[fc]] ;
      } else
	dom += fc ;
    } ENDFORALL ;
      
    if(vs == 1) {
      FORALL(dom,fc) {
	$interpolateFace_vec(X)[fc][0] = 1.0 ;
      } ENDFORALL ;
      return ;
    }
    
    Map slookup ;
    slookup = $interpolateFaceStencil->slookup ;
    storeVec<real_t> Xstencil ;
    sendStencilData(Xstencil,$X,
		    $interpolateFaceStencil->send_info,
		    $interpolateFaceStencil->req_sizes,
		    $interpolateFaceStencil->snd_sizes)  ;
    const vector<Array<real_t,4> > &weights 
      = $interpolateFaceStencil->weights ;
    const vector<Array<int,4> > &stencils 
      = $interpolateFaceStencil->stencils ;

    FORALL(dom,fc) {
      int cnt = slookup[fc]*2 ;
      int cll = cnt+0 ;
      int cl =  cnt+1 ;

      for(int i=0;i<vs;++i) {
	
	real_t vll = 0 ;
	for(int j=0;j<4;++j) 
	  vll += weights[cll][j]*Xstencil[stencils[cll][j]][i] ;
	  
	real_t vl = 0 ;
	for(int j=0;j<4;++j) 
	  vl += weights[cl][j]*Xstencil[stencils[cl][j]][i] ;
	  
	real_t vr = 0 ;
	vr = $X[$ci[fc]][i] ;
          
	real_t dv = (vl-vll) ;
	if(dv < 0.)
	  dv += -1e-30 ;
	else
	  dv += 1e-30 ;
          
	// Use Van Albada limiter to estimate second order upwind
	// extrapolation to the face
	const real_t r = (vr-vl)/dv ;
	const real_t lim = (r+r*r)/(1.+r*r) ;
	// Limit mixture fractions should be between 0 and 1
	$interpolateFace_vec(X)[fc][i] = min<real_t>(max<real_t>(vl + 0.5*lim*(vl-vll),0.0),1.0) ;
      }
    } ENDFORALL ;
    MEMORY_PROFILE(compute_end) ;
  } ;


  $type interpolateConnectCell store<int> ;

  $rule pointwise(interpolateConnectCell<-interpolateFaceStencil,ci->iblank),
  option(disable_threading), prelude {
    entitySet odom = entitySet(seq) ;
    entitySet dom ;
    FORALL(odom,fc) {
      if($iblank[$ci[fc]] > 2) {
	$interpolateConnectCell[fc] = -1 ;
      } else
	dom += fc ;
    } ENDFORALL ;
      
    Map slookup ;
    slookup = $interpolateFaceStencil->slookup ;
    entitySet sendSet ;
    for(size_t i=0;i<$interpolateFaceStencil->send_info.size();++i) {
      sendSet += $interpolateFaceStencil->send_info[i] ;
    }
      
    store<int> sendIds ;
    sendIds.allocate(sendSet) ;
    for(size_t i=0;i<$interpolateFaceStencil->send_info.size();++i) {
      int id = $interpolateFaceStencil->send_info[i] ;
      sendIds[id] = id ;
    }
    if(Loci::MPI_processes > 1) {
      Map l2g ;
      l2g = Loci::exec_current_fact_db->get_distribute_info()->l2g.Rep() ;
      FORALL(sendSet,ii) {
	sendIds[ii] = l2g[ii] ;
      } ENDFORALL ;
    }
    store<int> Ids ;
    const_store<int> sendIdsc ;
    sendIdsc = sendIds.Rep();
    sendStencilData(Ids,sendIdsc,
		    $interpolateFaceStencil->send_info,
		    $interpolateFaceStencil->req_sizes,
		    $interpolateFaceStencil->snd_sizes)  ;

    const vector<Array<real_t,4> > &weights = $interpolateFaceStencil->weights ;
    const vector<Array<int,4> > &stencils = $interpolateFaceStencil->stencils ;
    store<int> ids ;

    FORALL(dom,fc) {
      int cnt = slookup[fc]*2 ;
      int cl =  cnt ;
      
      real_t w=-1 ;
      $interpolateConnectCell[fc] = -1 ;
      for(int i=0;i<4;++i)
	if(weights[cl][i] > w) {
	  w = weights[cl][i] ;
	  $interpolateConnectCell[fc] = Ids[stencils[cl][i]] ;
	}
      
    } ENDFORALL ;
  } ;


  $type interpolateCellStencil blackbox<stencil_info> ;

  $rule unit(interpolateCellStencil),constraint(UNIVERSE,iblank),
  option(disable_threading),prelude { } ;


  $rule apply(interpolateCellStencil<-interpolatePoints(cellcenter,iblank),stencilSize2,cellcenter,iblank,stencilSizer,interpolateMinStencilSize)[Loci::NullOp],option(disable_threading), prelude {

//    using namespace Loci::kdTree ;
    MEMORY_PROFILE(compute_start) ;
    using Loci::debugout ;

    MEMORY_PROFILE(buildcellstencil) ;
#ifdef REPORT_TIMES
    Loci::stopWatch s ;
    s.start() ;
    MPI_Barrier(MPI_COMM_WORLD) ;
    //    Loci::debugout << "time to sync: " << s.stop() << endl ;
    s.start() ;
#endif
    entitySet odom = entitySet(seq) ;
    entitySet dom = EMPTY ;
    FORALL(odom,ii) {
      if($iblank[ii] == 2)
        dom += ii ;
    } ENDFORALL ;


    // Decompose points into a set of bounding boxes
    int sz = dom.size() ;
    vector<Loci::kdTree::KDTree<float>::coord_info> pbox(sz) ;
    int cnt =0 ;
    double delta_stencil = 0 ;
    FORALL(dom,cc) {
      pbox[cnt].coords[0] = realToFloat($cellcenter[cc].x) ;
      pbox[cnt].coords[1] = realToFloat($cellcenter[cc].y) ;
      pbox[cnt].coords[2] = realToFloat($cellcenter[cc].z) ;
      delta_stencil = max(delta_stencil,
                          double($stencilSizer->getSpacing(pbox[cnt].coords))) ;
      pbox[cnt].id = cc ;
      cnt++ ;
    } ENDFORALL ;

    //    real
    //    delta_stencil  = sqrt(*stencilSize2*2.) ;
#ifdef VERBOSE
    Loci::debugout << "delta = " << delta_stencil << endl ;
#endif
    delta_stencil *=  4.1 ; // double search depth to make sure to find a point

    // This call breaks the coordinate points into a set of bounding
    // boxes

    // Compute how big the decomposition chunks should be
    int tsz = 0 ;
    MPI_Allreduce(&sz,&tsz,1,MPI_INT,MPI_SUM,MPI_COMM_WORLD) ;
    MEMORY_PROFILE(pre_split_boxes) ;
    // split boxes until each box has no more then split_lim points
    int p = Loci::MPI_processes ;
    int split_lim = max(256,tsz/(p)) ;
#ifdef VERBOSE
    Loci::debugout << "split_lim = " << split_lim << endl ;
#endif
    // Get bounding boxes
    vector<bound_info> boxes ;
    debugout << "getBoundingBoxes, pbox.size() =" << pbox.size() << endl ;
    if(pbox.size() < 2) {
      debugout << "small pbox" << endl ;
    }
    getBoundingBoxes(pbox,boxes,4,delta_stencil*8.0,split_lim) ;
#ifdef VERBOSE
    Loci::debugout << "found " << boxes.size() << " bounding boxes:" << endl ;
#endif


    // Adjust bounding boxes by stencil size
    for(size_t i=0;i<boxes.size();++i) {
      float spacing = 0  ;
      for(int j=boxes[i].start;j<=boxes[i].stop;++j)
        spacing = max(spacing,$stencilSizer->getSpacing(pbox[j].coords)) ;
      spacing *= 5.1 ;
      spacing += *$interpolateMinStencilSize ;
      Loci::debugout << "spacing for box " << i << " is " << spacing
                     << ", boxes.size="<< boxes[i].stop-boxes[i].start+1
                     << endl ;
      boxes[i].bnd.minc[0] -= spacing ;
      boxes[i].bnd.minc[1] -= spacing ;
      boxes[i].bnd.minc[2] -= spacing ;
      boxes[i].bnd.maxc[0] += spacing ;
      boxes[i].bnd.maxc[1] += spacing ;
      boxes[i].bnd.maxc[2] += spacing ;
    }

#ifdef REPORT_TIMES
    Loci::debugout << "time to find bounding boxes: " << s.stop() << endl ;
    s.start() ;
#endif    

    // Now distribute the bounding boxes to all processors
    vector<int> box_sp,box_tp,b_sizes,send_block_id,recv_block_id ;
    
    boundingBoxDistribution(box_sp,box_tp,b_sizes,send_block_id,recv_block_id,
                            boxes,MPI_COMM_WORLD) ;
    MEMORY_PROFILE(post_distribution) ;

    // ------------------------------------------------------------------------
    // receive search points
    vector<vector<Loci::kdTree::KDTree<float>::coord_info>  > loc_pbox ;
    communicateBoxPoints(loc_pbox,box_sp,box_tp,b_sizes,
                         send_block_id,recv_block_id,pbox,boxes,
                         MPI_COMM_WORLD) ;

#ifdef REPORT_TIMES
    Loci::debugout << "time recv box search points: " << s.stop() << endl ;
    s.start() ;
#endif    

    MEMORY_PROFILE(post_commBoxPoints) ;
    //-------------------------------------------------------------------------
    // recieve target points

    // First collect bounding box information for each block
    vector<bound_info> boxes_g ;
    allGatherVec(boxes_g,boxes,MPI_COMM_WORLD) ;

#ifdef REPORT_TIMES
    Loci::debugout << "time allGatherVec boxes: " << s.stop() << endl ;
    s.start() ;
#endif
    const interpolate_points *interp_pnts = &(*$interpolatePoints(cellcenter,iblank)) ;
    
    vector<vector<Loci::kdTree::KDTree<float>::coord_info>  > recv_targets ;
    recieveTargetPoints(recv_targets,interp_pnts->kd,
                        boxes_g,box_sp,box_tp,b_sizes,
                        send_block_id,recv_block_id,
                        MPI_COMM_WORLD) ;

    MEMORY_PROFILE(recv_targetPnts) ;
#ifdef REPORT_TIMES
    Loci::debugout << "time to receive target points: " << s.stop() << endl ;
    s.start() ;
#endif

    // Now we build the stencils
    vector< vector<Array<int,4> > >    stencil_block(recv_block_id.size()) ;
    vector< vector<Array<real_t,4> > > weights_block(recv_block_id.size()) ;

    int st_error = 0 ;
    int st_warning = 0 ;
    
    MEMORY_PROFILE(pre_build_stencils) ;
    // After sending, we can compute stencils for each block.
    for(size_t i=0;i<recv_block_id.size();++i) {
      int bk = recv_block_id[i] ;
      int ssz = loc_pbox[i].size() ; // Search points for block bk

      store<vector3d<real_t> > loc ;
      store<int> ids ;
      int tsz = recv_targets[bk].size() ;
      entitySet locdom = interval(0,tsz-1) ;
      loc.allocate(locdom) ;
      ids.allocate(locdom) ;

      int defaultid = 0 ;
      for(int ii=0;ii<tsz;++ii) {
	defaultid = ii ;
	if(recv_targets[bk][ii].id != std::numeric_limits<int>::max())
	  break ;
      }

      for(int ii=0;ii<tsz;++ii) {
	loc[ii].x = recv_targets[bk][ii].coords[0] ;
	loc[ii].y = recv_targets[bk][ii].coords[1] ;
	loc[ii].z = recv_targets[bk][ii].coords[2] ;
	ids[ii] = recv_targets[bk][ii].id ;
	if(ids[ii] != std::numeric_limits<int>::max())
	  recv_targets[bk][ii].id = ii ;
      }

      Loci::kdTree::KDTree<float> stree(recv_targets[bk]) ;
#ifdef VERBOSE
      Loci::debugout << "bk=" << bk <<  ",tsz=" << tsz << endl ;
#endif

      vector<Array<int,4> > tmp1(ssz) ;
      vector<Array<real_t,4> > tmp2(ssz) ;
      stencil_block[i].swap(tmp1) ;
      weights_block[i].swap(tmp2) ;
      delta_stencil = 0 ;
      for(int j=0;j<ssz;++j) {
        delta_stencil = max(delta_stencil,
                            double($stencilSizer->getSpacing(loc_pbox[i][j].coords)));
      }

      delta_stencil *= 5.1 ;
      for(int j=0;j<ssz;++j) {
	vector3d<real_t>  pnt(loc_pbox[i][j].coords[0],
		   loc_pbox[i][j].coords[1],
		   loc_pbox[i][j].coords[2]) ;
        
	vector<int> neighbors = get_stencil(stree,pnt,delta_stencil) ;

        if(neighbors.size() < 1) {
          real_t scale = 2.0 ;
          do {
            neighbors = get_stencil(stree,pnt,delta_stencil*scale) ;
            scale = scale * 2.0 ;
          } while (neighbors.size() < 1 && scale < 10.0) ;
        }
        if(neighbors.size() < 1) 
          st_error++ ;
        if(neighbors.size() < 1)
          Loci::debugout << "degenerate neighbors, delta=" << delta_stencil
                         << ",loc="<< pnt
                         << ",tsz="<< tsz
                         << ",ssz="<< ssz
                         << endl ;
        
          
	// compute stencil weights
	vector<real_t> w  ;
	stencil_weights(w,neighbors,loc,pnt) ;
        if(neighbors.size() ==0) {
          neighbors.push_back(stree.find_closest(loc_pbox[i][j].coords)) ;
          if(neighbors[0] < 0 ||
	     neighbors[0] == std::numeric_limits<int>::max())
            neighbors[0] = defaultid ;
          w.push_back(0.0) ;
        }
        if(w.size() < 3) {
          st_warning++ ;
          Loci::debugout << "suboptimal stencil, delta = " << delta_stencil << endl ;
        }
	int bsz = w.size() ;
	for(int k=0;k<bsz;++k) {
	  if(ids[neighbors[k]] == std::numeric_limits<int>::max()) {
	      cerr << "neighbors[" << k
		   << "] = " << neighbors[k] << endl ;
	  }
	  stencil_block[i][j][k] = ids[neighbors[k]] ;
	  weights_block[i][j][k] = w[k] ;
	}
	for(int k=bsz;k<4;++k) {
	  stencil_block[i][j][k] = (bsz > 0)?ids[neighbors[bsz-1]]:0 ;
	  weights_block[i][j][k] = 0.0 ;
	}
#ifdef VERBOSE
	Loci::debugout << ' ' << neighbors.size() ;
#endif
	
      }
#ifdef VERBOSE
      Loci::debugout << endl ;
#endif

    }

    int tot = 0 ;
    MPI_Allreduce(&st_error,&tot,1,MPI_INT,MPI_SUM,MPI_COMM_WORLD) ;
    if(Loci::MPI_rank == 0 && tot != 0) {
      cerr << "STENCIL ERROR:  Degenerate stencil formed" << endl ;
      //      Loci::Abort() ;
    }
    MPI_Allreduce(&st_warning,&tot,1,MPI_INT,MPI_SUM,MPI_COMM_WORLD) ;
    if(Loci::MPI_rank == 0 && tot != 0) {
      cerr << "Warning: Suboptimal stencil in reconstruction: " << tot << endl ;
    }
      
      

    MEMORY_PROFILE(post_stencil_compute) ;
#ifdef REPORT_TIMES
    Loci::debugout << "time to generate stencils: " << s.stop() << endl ;
    s.start() ;
#endif    
    // Then we send the stencils back.
    {
      vector<Array<int,4> > stencil_rcv ;
      returnBlockData(stencil_rcv,stencil_block,1,boxes,
                      box_sp,box_tp,b_sizes,send_block_id,recv_block_id,
                      MPI_COMM_WORLD) ;

      MEMORY_PROFILE(recv_stencil) ;
      int stsz = stencil_rcv.size() ;
      vector<int> stmp(stsz*4) ;
      for(int i=0;i<stsz;++i)
	for(int j=0;j<4;++j)
	  stmp[i*4+j] = stencil_rcv[i][j] ;
      
      std::sort(stmp.begin(),stmp.end()) ;
      vector<int>::const_iterator se = std::unique(stmp.begin(),stmp.end()) ;

      int nids = se-stmp.begin() ;
      store<int> ids ;
      entitySet locdom = interval(0,nids-1) ;
      ids.allocate(locdom) ;

      map<int,int> rmap ;
      int cnt = 0 ;

      for(vector<int>::const_iterator ii=stmp.begin();ii!=se;++ii) {
	ids[cnt] = *ii ;
	if(*ii == std::numeric_limits<int>::max()) {
	  rmap[*ii] = *ii ;
	  cerr << "stencil includes max" << endl ;
	} else 
	  rmap[*ii] = cnt ;
	cnt++ ;
      }

      for(int i=0;i<stsz;++i)
	for(int j=0;j<4;++j)
	  stencil_rcv[i][j] = rmap[stencil_rcv[i][j]] ;
      
      vector<int> send_info, req_sizes, snd_sizes, access ;
      

      getCommSchedFromStencil(send_info,req_sizes,snd_sizes, access,
			      stencil_rcv,ids,interp_pnts->distribution) ;
      
      for(size_t i=0;i<send_info.size();++i)
	send_info[i] = interp_pnts->posid[send_info[i]] ;
      remapStencil(stencil_rcv,access, ids) ;

      Map slookup ;
      slookup.allocate(dom) ;
      for(size_t i=0;i<pbox.size();++i)
	slookup[pbox[i].id] = i ;
      
      $interpolateCellStencil->stencils.swap(stencil_rcv) ;
      $interpolateCellStencil->send_info.swap(send_info) ;
      $interpolateCellStencil->snd_sizes.swap(snd_sizes) ;
      $interpolateCellStencil->req_sizes.swap(req_sizes) ;
      $interpolateCellStencil->slookup = slookup.Rep() ;
    }

    // Send weights
    vector<Array<real_t,4> > weight_rcv ;
    returnBlockData(weight_rcv,weights_block,1,boxes,
                    box_sp,box_tp,b_sizes,send_block_id,recv_block_id,
                    MPI_COMM_WORLD) ;
    
    $interpolateCellStencil->weights.swap(weight_rcv) ;

    // put stencil blocks into place, renumber to local numbering and set ids
    // send weights

    // generate stencil communication schedule


#ifdef REPORT_TIMES
    Loci::debugout << "time in new code find stencil: " << s.stop() << endl ;
    s.start() ;
    MPI_Barrier(MPI_COMM_WORLD) ;
    Loci::debugout << "time to sync: " << s.stop() << endl ;
    s.start() ;
#endif    
    MEMORY_PROFILE(compute_start) ;

  } ;

  $type Xin store<real_t> ;
  $type Xout store<real_t> ;

  $rule pointwise(iblank::Xout<-iblank,Xin,upper->cr->(iblank,Xin),lower->cl->(iblank,Xin),(upper,lower)->area,interpolateCellStencil),inplace(iblank::Xout|Xin),constraint(Xin,iblank,componentGeometry,geom_cells),parametric(scalarInterpolateToBlankedCells(Xout,Xin)),option(disable_threading),prelude {
    MEMORY_PROFILE(compute_start) ;
    entitySet odom = entitySet(seq) ;
    entitySet dom = EMPTY ;
    store<byte_t> tst ;
    tst.allocate(odom) ;
    FORALL(odom,ii) {
      if($iblank[ii] == 2)
	dom += ii ;
      tst[ii] = 0 ;
    } ENDFORALL ;
      
    Map slookup ;
    slookup = $interpolateCellStencil->slookup ;
    store<real_t> qstencil ;
    const_store<real_t> X_c ;
    X_c.setRep($Xin.Rep()) ;
    sendStencilData(qstencil,X_c,
		    $interpolateCellStencil->send_info,
		    $interpolateCellStencil->req_sizes,
		    $interpolateCellStencil->snd_sizes)  ;
    const vector<Array<real_t,4> > &weights = $interpolateCellStencil->weights ;
    const vector<Array<int,4> > &stencils = $interpolateCellStencil->stencils ;

    FORALL(dom,cc) {
      // lookup cell number
      int cnt = slookup[cc] ;
      
      int co = cnt ;
      
      real_t wtot = weights[co][0]+weights[co][1]+weights[co][2]+weights[co][3] ;
      if(wtot > 0.0) {
	// Weighted sum interpolation
	real_t v = 0 ;
	for(int j=0;j<4;++j) 
	  v += weights[co][j]*qstencil[stencils[co][j]] ;
	$iblank::Xout[cc] = v ;
      } else
	tst[cc] = 1 ;
    } ENDFORALL ;

    // Now for all non-participating cells, average appropriately
    FORALL(odom,ii) {
      if($iblank[ii] == 3 || tst[ii] == 1) {
	real_t qpsum ;
	int usz = $upper[ii].size() ;
	int lsz = $lower[ii].size() ;
	int imin = 3 ;
	for(int i=0;i<usz;++i) {
	  int ib = $iblank[$cr[$upper[ii][i]]] ;
	  imin = min(imin,ib) ;
	}
	for(int i=0;i<lsz;++i) {
	  int ib = $iblank[$cl[$lower[ii][i]]] ;
	  imin = min(imin,ib) ;
	}
	qpsum = 0 ;
	real_t sum = 0 ;
	
	for(int i=0;i<usz;++i) {
	  int crc = $cr[$upper[ii][i]] ;
	  int ib = $iblank[crc] ;
	  if(ib == imin) {
	    real_t w = $area[$upper[ii][i]].sada ;
	    sum += w ;
	    qpsum += w*$Xin[crc] ;
	  }
	}
	for(int i=0;i<lsz;++i) {
	  int clc = $cl[$lower[ii][i]] ;
	  int ib = $iblank[clc] ;
	  if(ib == imin) {
	    real_t w = $area[$lower[ii][i]].sada ;
	    sum += w ;
	    qpsum += w*$Xin[clc] ;
	  }
	}

	if(sum > 0.0) {
	  real_t rsum = 1./sum ;
	  $iblank::Xout[ii] = qpsum*rsum ;
	}
      }
    } ENDFORALL ;

    MEMORY_PROFILE(compute_end) ;

  } ;

  $type Xin store<vector3d<real_t> > ;
  $type Xout store<vector3d<real_t> > ;
  $rule pointwise(iblank::Xout<-iblank,Xin,upper->cr->(iblank,Xin),lower->cl->(iblank,Xin),(upper,lower)->area,interpolateCellStencil),inplace(iblank::Xout|Xin),constraint(Xin,iblank,componentGeometry,geom_cells),parametric(v3dInterpolateToBlankedCells(Xout,Xin)),option(disable_threading), prelude {
    MEMORY_PROFILE(compute_start) ;
    entitySet odom = entitySet(seq) ;
    entitySet dom = EMPTY ;
    store<byte_t> tst ;
    tst.allocate(odom) ;
    FORALL(odom,ii) {
      if($iblank[ii] == 2)
	dom += ii ;
      tst[ii] = 0 ;
    } ENDFORALL ;
      
    Map slookup ;
    slookup = $interpolateCellStencil->slookup ;
    store<vector3d<real_t> > qstencil ;
    const_store<vector3d<real_t> > X_c ;
    X_c.setRep($Xin.Rep()) ;
    sendStencilData(qstencil,X_c,
		    $interpolateCellStencil->send_info,
		    $interpolateCellStencil->req_sizes,
		    $interpolateCellStencil->snd_sizes)  ;
    const vector<Array<real_t,4> > &weights = $interpolateCellStencil->weights ;
    const vector<Array<int,4> > &stencils = $interpolateCellStencil->stencils ;

    FORALL(dom,cc) {
      // lookup cell number
      int cnt = slookup[cc] ;
      
      int co = cnt ;
      real_t wtot = weights[co][0]+weights[co][1]+weights[co][2]+weights[co][3] ;
      // Weighted sum interpolation
      if(wtot > 0.0) {
	vector3d<real_t>  v = vector3d<real_t> (0,0,0) ;
	for(int j=0;j<4;++j) 
	  v += weights[co][j]*qstencil[stencils[co][j]] ;
	$iblank::Xout[cc] = v ;
      } else
	tst[cc] = 1 ;
    } ENDFORALL ;

    // Now for all non-participating cells, average appropriately
    FORALL(odom,ii) {
      if($iblank[ii] == 3 || tst[ii] == 1) {
	vector3d<real_t>  qpsum ;
	int usz = $upper[ii].size() ;
	int lsz = $lower[ii].size() ;
	int imin = 3 ;
	for(int i=0;i<usz;++i) {
	  int ib = $iblank[$cr[$upper[ii][i]]] ;
	  imin = min(imin,ib) ;
	}
	for(int i=0;i<lsz;++i) {
	  int ib = $iblank[$cl[$lower[ii][i]]] ;
	  imin = min(imin,ib) ;
	}
	qpsum = vector3d<real_t>(0,0,0) ;
	real_t sum = 0 ;
	for(int i=0;i<usz;++i) {
	  int crc = $cr[$upper[ii][i]] ;
	  int ib = $iblank[crc] ;
	  if(ib == imin) {
	    real_t w = $area[$upper[ii][i]].sada ;
	    sum += w ;
	    qpsum += w*$Xin[crc] ;
	  }
	}
	for(int i=0;i<lsz;++i) {
	  int clc = $cl[$lower[ii][i]] ;
	  int ib = $iblank[clc] ;
	  if(ib == imin) {
	    real_t w = $area[$lower[ii][i]].sada ;
	    sum += w ;
	    qpsum += w*$Xin[clc] ;
	  }
	}
	if(sum > 0.0) {
	  real_t rsum = 1./sum ;
	  $iblank::Xout[ii] = qpsum*rsum ;
	}
      }
    } ENDFORALL ;

    MEMORY_PROFILE(compute_end) ;

  } ;

  $type Xin storeVec<real_t> ;
  $type Xout storeVec<real_t> ;

  $rule pointwise(iblank::Xout<-iblank,Xin,upper->cr->(iblank,Xin),lower->cl->(iblank,Xin),(upper,lower)->area,interpolateCellStencil),inplace(iblank::Xout|Xin),constraint(Xin,iblank,componentGeometry,geom_cells),parametric(vecInterpolateToBlankedCells(Xout,Xin)),option(disable_threading),prelude {
    MEMORY_PROFILE(compute_start) ;
    const int vs = $Xin.vecSize() ;
    entitySet odom = entitySet(seq) ;
    entitySet dom = EMPTY ;
    store<byte_t> tst ;
    tst.allocate(odom) ;
    FORALL(odom,ii) {
      if($iblank[ii] == 2)
	dom += ii ;
      tst[ii] = 0 ;
    } ENDFORALL ;
      
    Map slookup ;
    slookup = $interpolateCellStencil->slookup ;
    storeVec<real_t> qstencil ;
    const_storeVec<real_t> X_c ;
    X_c.setRep($Xin.Rep()) ;

    sendStencilData(qstencil,X_c,
		    $interpolateCellStencil->send_info,
		    $interpolateCellStencil->req_sizes,
		    $interpolateCellStencil->snd_sizes)  ;
    const vector<Array<real_t,4> > &weights = $interpolateCellStencil->weights ;
    const vector<Array<int,4> > &stencils = $interpolateCellStencil->stencils ;

    
    FORALL(dom,cc) {
      // lookup cell number
      int cnt = slookup[cc] ;
      
      int co = cnt ;
      
      real_t wtot = weights[co][0]+weights[co][1]+weights[co][2]+weights[co][3] ;

      // Weighted sum interpolation
      if(wtot > 0.0) {
	for(int iv=0;iv<vs;++iv) {
	  real_t v = 0 ;
	  for(int j=0;j<4;++j) 
	    v += weights[co][j]*qstencil[stencils[co][j]][iv] ;
	  $iblank::Xout[cc][iv] = v ;
	}
      } else {
	tst[cc] = 1 ;
      }
    } ENDFORALL ;

    // Now for all non-participating cells, average appropriately
    
    vector<real_t> qpsum(vs) ;
    FORALL(odom,ii) {
      if($iblank[ii] == 3 || tst[ii] == 1) {
	int usz = $upper[ii].size() ;
	int lsz = $lower[ii].size() ;
	int imin = 3 ;
	for(int i=0;i<usz;++i) {
	  int ib = $iblank[$cr[$upper[ii][i]]] ;
	  imin = min(imin,ib) ;
	}
	for(int i=0;i<lsz;++i) {
	  int ib = $iblank[$cl[$lower[ii][i]]] ;
	  imin = min(imin,ib) ;
	}
	for(int iv=0;iv<vs;++iv)
	  qpsum[iv] = 0 ;
	real_t sum = 0 ;

	for(int i=0;i<usz;++i) {
	  int crc = $cr[$upper[ii][i]] ;
	  int ib = $iblank[crc] ;
	  if(ib == imin) {
	    real_t w = $area[$upper[ii][i]].sada ;
	    sum += w ;
	    for(int iv=0;iv<vs;++iv)
	      qpsum[iv] += w*$Xin[crc][iv] ;
	  }
	}
	for(int i=0;i<lsz;++i) {
	  int clc = $cl[$lower[ii][i]] ;
	  int ib = $iblank[clc] ;
	  if(ib == imin) {
	    real_t w = $area[$lower[ii][i]].sada ;
	    sum += w ;
	    for(int iv=0;iv<vs;++iv)
	      qpsum[iv] += w*$Xin[clc][iv] ;
	  }
	}

	if(sum > 0.0) {
	  real_t rsum = 1./sum ;
	  for(int iv=0;iv<vs;++iv)
	    $iblank::Xout[ii][iv] = qpsum[iv]*rsum ;
	}
      }
    } ENDFORALL ;

    MEMORY_PROFILE(compute_end) ;

  } ;

  $type iblankCell store<int> ;

  $rule pointwise(iblankCell<-interpolateCellStencil,iblank,
		  upper->cr->(iblank), lower->cl->(iblank),
		  (upper,lower)->area), constraint(iblank,componentGeometry),
  option(disable_threading),
  prelude {
    MEMORY_PROFILE(compute_start) ;
    entitySet odom = entitySet(seq) ;
    entitySet dom = EMPTY ;
    store<int> gcell ;
    gcell.allocate(odom) ;
    if(Loci::MPI_processes > 1) {
      Map l2g ;
      l2g = Loci::exec_current_fact_db->get_distribute_info()->l2g.Rep() ;
      FORALL(odom,ii) {
	gcell[ii] = l2g[ii] ;
      } ENDFORALL ;
    } else {
      FORALL(odom,ii) {
	gcell[ii] = ii ;
      } ENDFORALL ;
    }
      
    FORALL(odom,ii) {
      $iblankCell[ii] = 0 ;
      if($iblank[ii] == 2)
	dom += ii ;
    } ENDFORALL ;

    Map slookup ;
    slookup = $interpolateCellStencil->slookup ;
    store<int> cstencil ;
    const_store<int> gcell_c ;
    gcell_c.setRep(gcell.Rep()) ;
    sendStencilData(cstencil,gcell_c,
		    $interpolateCellStencil->send_info,
		    $interpolateCellStencil->req_sizes,
		    $interpolateCellStencil->snd_sizes)  ;
    const vector<Array<real_t,4> > &weights = $interpolateCellStencil->weights ;
    const vector<Array<int,4> > &stencils = $interpolateCellStencil->stencils ;
      
      
    FORALL(dom,cc) {
      // lookup cell number
      int cnt = slookup[cc] ;
      int co = cnt ;
      
      // Weighted sum interpolation
      real_t w=-1 ;
      for(int j=0;j<4;++j)
	if(weights[co][j] > w) {
	  w = weights[co][j] ;
	  $iblankCell[cc] = cstencil[stencils[co][j]] ;
	}
    } ENDFORALL ;
    
    MEMORY_PROFILE(compute_end) ;
  } ;

  $type firstOrderCells store<char> ;
  $type oversetCollisionCheck Constraint ;

  $rule apply((cl,cr)->firstOrderCells<-(cl,cr)->iblank)[Loci::Maximum],
  constraint((cl,cr)->geom_cells,oversetCollisionCheck) {
    if(max($cl->$iblank,$cr->$iblank) > 2) {
      char tmp = 1 ;
      join($cl->$firstOrderCells,tmp) ;
      join($cr->$firstOrderCells,tmp) ;
    }
  }
  
}
