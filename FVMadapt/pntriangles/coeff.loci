#include <Loci.h>
$include "FVM.lh"
#include <vector>
#include "coeff.h"

using std::vector ;
using std::ifstream ;
using std::ios ;
using std::cerr ;
using std::endl ;
using std::cout ;

// $type area store<Loci::Area>;
// $type pos store<vect3d>;
// $type face2node multiMap;
// //compute the area of each boundary face
// $rule pointwise(barea<-face2node->pos), constraint(geometry_BC) {
//   if($face2node.size() != 3){
//     cerr <<"WARNING: non-triangle face exists in geomtry_BC" << endl;
//     Loci::Abort();
//   }
//   vect3d P1 = $face2node[0]->$pos;		
//   vect3d P2 = $face2node[1]->$pos;;	
//   vect3d P3 = $face2node[2]->$pos; 
//   vect3d a = 0.5*cross((P2-P1), (P3-P1));	
//   $barea.sada = norm(a);
//   $barea.n = a/$barea.sada;
// }

// //compute the total area of each boundary nodes
// $type nodeArea store<double>  ;
// $rule unit(nodeArea),constraint(boundary_nodes) {
//   $nodeArea = 0 ;
// }
// $rule apply(face2node->nodeArea<-barea)[Loci::Summation],constraint(geometry_BC) {
//   int sz = $face2node.size() ;
//   for(int i=0;i<sz;++i)
//     join($face2node[i]->$nodeArea,$barea.sada) ;
// }

// //compute the weighted average norm of each node
// $type nodeNorm store<vector3d<double> > ;
// $rule unit(nodeNorm),constraint(boundary_nodes) {
//   $nodeNorm = vector3d<double>(0,0,0) ;
// }
// $rule apply(face2node->nodeNorm<-face2node->nodeArea,barea)[Loci::Summation],constraint(geometry_BC) {
//   int sz = $face2node.size() ;
//   for(int i=0;i<sz;++i) {
//     double weight = $barea.sada/$face2node[i]->$nodeArea ;
//     join($face2node[i]->$nodeNorm,weight*$barea.n) ;
//   }
// }


$type burnNodeArea store<double>  ;

$rule unit(burnNodeArea),constraint(boundary_nodes) {
  $burnNodeArea = 0 ;
}

$rule apply(face2node->burnNodeArea<-area)[Loci::Summation],constraint(geometry_BC) {
  int sz = $face2node.size() ;
  for(int i=0;i<sz;++i)
    join($face2node[i]->$burnNodeArea,$area.sada) ;
}

// $rule unit(burnrate),constraint(boundary_nodes) {
//   $burnrate = 0 ;
// }

// $rule apply(face2node->burnrate<-face2node->burnNodeArea,area,burnrate_f)[Loci::Summation],constraint(geometry_BC) {
//   int sz = $face2node.size() ;
//   for(int i=0;i<sz;++i) {
//     double weight = $area.sada/$face2node[i]->$burnNodeArea ;
//     join($face2node[i]->$burnrate,weight*$burnrate_f) ;
//   }
// }

$type burnnorm store<vector3d<double> > ;

$rule unit(burnnorm),constraint(pos) {
  $burnnorm = vector3d<double>(0,0,0) ;
}

$rule apply(face2node->burnnorm<-face2node->burnNodeArea,area)[Loci::Summation],constraint(geometry_BC) {
  int sz = $face2node.size() ;
  for(int i=0;i<sz;++i) {
    double weight = $area.sada/$face2node[i]->$burnNodeArea ;
    join($face2node[i]->$burnnorm,weight*$area.n) ;
  }
}

$type symmetryvec store<vector3d<double> > ;

$rule unit(symmetryvec),constraint(pos) {
  $symmetryvec = vector3d<double>(0,0,0) ;
}

$rule apply(face2node->symmetryvec<-area)[Loci::Summation],constraint(symmetry_BC) {
  int sz = $face2node.size() ;
  vector3d<double> av = $area.sada*$area.n ;
  for(int i=0;i<sz;++i) {
    join($face2node[i]->$symmetryvec,av) ;
  }
}

$type nodeNorm store<vector3d<double> > ;

$rule pointwise(nodeNorm<-burnnorm,symmetryvec) {
  vector3d<double> bdir = $burnnorm ;
  double snorm = norm($symmetryvec) ;
  if(snorm > 1e-33) {
    vector3d<double> svec = $symmetryvec ;
    svec *= 1./snorm ;
    bdir -= svec*dot(bdir,svec) ;
  }
  bdir *= 1./norm(bdir) ;
  $nodeNorm = bdir;
}


//compute the geometry of each boundary face
$type geom store<std::vector<Loci::GeomCoeff> > ;
$rule pointwise(geom<-face2node->(nodeNorm,pos)), constraint(geometry_BC) {
  vect3d P1 = $face2node[0]->$pos;
  vect3d N1 = $face2node[0]->$nodeNorm;
  $geom.clear();
  for( int i = 1; i <=($face2node.size()-2); i++){ 
  	
    vect3d P2 = $face2node[i]->$pos;;	
    vect3d P3 = $face2node[i+1]->$pos;

   
    vect3d N2 = $face2node[i]->$nodeNorm;
    vect3d N3 = $face2node[i+1]->$nodeNorm;

    Loci::GeomCoeff g;
    
    g.b300 = P1;
    g.b030 = P2;
    g.b003 = P3;
    double w12 = dot((P2-P1), N1);
    double w21 = dot((P1-P2), N2);
    double w23 = dot((P3-P2), N2);
    double w32 = dot((P2-P3), N3);
    double w31 = dot((P1-P3), N3);
    double w13 = dot((P3-P1), N1);
    g.b210 = (2.0*P1 + P2 - w12*N1)/3.0;
    g.b120 = (2.0*P2 + P1 - w21*N2)/3.0;
    g.b021 = (2.0*P2 + P3 - w23*N2)/3.0;
    g.b012 = (2.0*P3 + P2 - w32*N3)/3.0;
    g.b102 = (2.0*P3 + P1 - w31*N3)/3.0;
    g.b201 = (2.0*P1 + P3 - w13*N1)/3.0;
    vect3d E = (g.b210 + g.b120 + g.b021 + g.b012 + g.b102 + g.b201)/6.0;
    vect3d V = (P1 + P2 + P3)/3.0;
    g.b111 = E + 0.5 *(E-V);
    $geom.push_back(g);
  }
 //  cout << "face2node: " <<endl;
//   for(int i = 0; i < $face2node.size(); i++) cout << $face2node[i]->$pos << endl;
//   cout << " geom :  " <<$geom.size() << endl;
//   for(int i = 0; i < $geom.size(); i++) {
//     cout << $geom[i].b300 << endl;
//     cout << $geom[i].b030 << endl;
//     cout << $geom[i].b003 << endl;
//   }
//   cout << endl << endl;
}


