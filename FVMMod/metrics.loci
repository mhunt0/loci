#include <Loci.h>
#include <Tools/tools.h>

$include "FVM.lh"

namespace Loci {
  const real_t EPSILON=1e-33 ;
  $type centroid param<std::string> ;
  $type exactCentroid Constraint ;
  
  $rule default(centroid),
    comments("Determines how centroids are computed.  'wireframe' assumes the mass is located at the surface of the cell.  'exact' uses an exact centroid computation assuming mass is distributed through the cell volume.") {
      $centroid = "wireframe" ;
  }

  $rule constraint(exactCentroid<-centroid) {
    $exactCentroid = EMPTY ;
    if($centroid == "exact") 
      $exactCentroid = $*centroid.domain() ;
  } 

  $rule pointwise(area<-face2node->pos,facecenter) {
     const vector3d<real_t> center = $facecenter ;
     const Entity *first = $face2node.begin() ;
     const Entity *last = ($face2node.end()-1) ;
     vector3d<real_t> sum(cross(last->$pos-center,first->$pos-center)) ;
     for(const Entity * ni=$face2node.begin()+1;ni!=($face2node.end());ni++) {
       const Entity *np = ni-1 ;
       sum = sum + cross(np->$pos-center,ni->$pos-center) ;
     }
     $area.n = sum ;
     const real_t sada = sqrt(dot(sum,sum)) ;
     $area.n *= 1./(sada+EPSILON) ;  //normalized normal vector of the face
     $area.sada = 0.5*sada ;  //area of the face
  }

#define STRONG_CHECK

  $rule pointwise(vol<-cellcenter,(upper,lower,boundary_map)->(area,facecenter)) {
    real_t sum = 0.0 ;
    vector3d<real_t> dv ;
    for(const Entity* nf=$upper.begin();nf!=$upper.end();++nf) {
      dv = nf->$facecenter - $cellcenter ;
      sum = sum + nf->$area.sada*(dot(dv,nf->$area.n)) ;
#ifdef STRONG_CHECK
      if(dot(dv,nf->$area.n) < 0)
        Loci::debugout << "warning, non-convex cell" << _e_ << endl ;
#endif
    }
    for(const Entity* nf=$lower.begin();nf!=$lower.end();++nf) {
      dv = nf->$facecenter - $cellcenter ;
      sum = sum - nf->$area.sada*(dot(dv,nf->$area.n)) ;
#ifdef STRONG_CHECK
      if(dot(dv,nf->$area.n) > 0)
        Loci::debugout << "warning, non-convex cell " << _e_ << endl ;
#endif
    }
    for(const Entity* nf=$boundary_map.begin();nf!=$boundary_map.end();++nf) {
      dv = nf->$facecenter - $cellcenter ;
      sum = sum + nf->$area.sada*(dot(dv,nf->$area.n)) ;
#ifdef STRONG_CHECK
      if(dot(dv,nf->$area.n) < 0)
        Loci::debugout << "warning, non-convex cell " << _e_ << endl ;
#endif
    }
    $vol = sum/3.0 ;
    if(sum <= 0.0) {
      cerr << Loci::MPI_rank << "  Zero or negative volume in grid cell " << _e_ << endl ;
      for(const Entity* nf=$upper.begin();nf!=$upper.end();++nf) {
	Loci::debugout << "upper facecenter [" << *nf << " ] =  "
                       << nf->$facecenter << endl ;
	Loci::debugout << "upper area [" << *nf << " ] =  "
                       << nf->$area << endl ;
      }
      for(const Entity * nf=$lower.begin();nf!=$lower.end();++nf) {
	Loci::debugout << "lower facecenter [" << *nf << " ] =  "
                       << nf->$facecenter << endl ;
	Loci::debugout << "lower area [" << *nf << " ] =  "
                       << nf->$area << endl ;
      }
      for(const Entity* nf=$boundary_map.begin();nf!=$boundary_map.end();++nf) {
	Loci::debugout << "BM facecenter [" << *nf << " ] =  "
                       << nf->$facecenter << endl ;
	Loci::debugout << "BM area [" << *nf << " ] =  "
                       << nf->$area << endl ;
      }
      Loci::debugout << " cellcenter [" << _e_ << " ] =  "
                     << $cellcenter << endl ;
      Loci::debugout << " volume[ " << _e_ << " ] = "
                     << $vol << endl ;
      
      exit(-1) ;
    }
  }
  

  // Compute total grid volume
  $rule unit(grid_vol),constraint(vol) {
    $grid_vol = 0 ;
  }

  $rule apply(grid_vol<-vol)[Loci::Summation], constraint(geom_cells) {
    join($grid_vol,$vol) ;
  }

  $rule pointwise(at), constraint(area) {
    $at = 0 ;
  }
        
  //The following class gives the two perpendicular vectors in the face to 
  //form the orthogonal coordinates of the face along with the normal vector
  $rule pointwise(ln,mn<-area) {
    // find vectors orthogonal to axn,ayn,azn

    vector3d<real_t> l ; // vect3d defined in sciTypes.h
    const vector3d<real_t> &an = $area.n ; 
    //an.x, an.y, an.z are the x,y, and z components of an
    // Attempt to minimize cancellation error when finding orthogonal vector.
    // Find the coordinate direction which is largest and base orthognality
    // on that direction. (The three following cases are for x largest,
    // then y largest, and finally z largest.
    if(abs(an.x)>abs(an.y) && abs(an.x)>abs(an.z)) {
      if(abs(an.y)>abs(an.z)) {
        l.y = an.y ;
        l.z = -an.x ;
      } else {
        l.y = -an.x ;
        l.z = an.z ;
      }
      l.x = -(l.y*an.y+l.z*an.z)/an.x ;
    } else if(abs(an.y)>abs(an.x) && abs(an.y)>abs(an.z)) {
      if(abs(an.x)>abs(an.z)) {
        l.x = an.x ;
        l.z = -an.y ;
      } else {
        l.x = -an.y ;
        l.z = an.z ;
      }
      l.y = -(l.x*an.x+l.z*an.z)/an.y ;
    } else {
      if(abs(an.x)>abs(an.y)) {
        l.x = an.x ;
        l.y = -an.z ;
      } else {
        l.x = -an.z ;
        l.y = an.y ;
      }
      l.z = -(l.x*an.x+l.y*an.y)/an.z ;
    }

    warn(dot(l,l) < EPSILON) ; // Sanity check (should never happen)
    const real_t lsr = 1./sqrt(dot(l,l)) ;
    l *= lsr ;  //normalize the vector
    warn(dot(an,l) > 1e-9) ; // Sanity check, l and an should be orthogonal 
    
    $ln = l ;
    $mn = cross(l,an) ;
  }


  $rule pointwise(facecenter<-face2node->pos) {
    vector3d<real_t> nodesum(0.0,0.0,0.0) ;
    real_t lensum = 0 ;
    warn($face2node.begin() == $face2node.end() ||
         $face2node.begin()+1 == $face2node.end()) ;
    for(const Entity *id=$face2node.begin();id+1!=$face2node.end();++id) {
      const Entity *nd = id+1 ;
      vector3d<real_t> edge_loc = 0.5*(id->$pos + nd->$pos) ;
      vector3d<real_t> edge_vec = id->$pos - nd->$pos ;
      real_t len = sqrt(dot(edge_vec,edge_vec)) ;
      nodesum += len*edge_loc ;
      lensum += len ;
    }
    const Entity *id = $face2node.begin() ;
    const Entity *idend = $face2node.end() - 1 ;
    vector3d<real_t> edge_loc = 0.5*(id->$pos + idend->$pos) ;
    vector3d<real_t> edge_vec = id->$pos - idend->$pos ;
    real_t len = sqrt(dot(edge_vec,edge_vec)) ;
    nodesum += len*edge_loc ;
    lensum += len ;
    
    $facecenter = nodesum/lensum ;
  }

  $rule pointwise(cellcenter<-(upper,lower,boundary_map)->(facecenter,area)) {
    vector3d<real_t> nodesum(0.0,0.0,0.0) ;
    real_t areasum = 0 ;
    for(const Entity *id=$upper.begin();id!=$upper.end();++id) {
      nodesum += id->$area.sada*id->$facecenter ;
      areasum += id->$area.sada ;
    }
    for(const Entity *id=$lower.begin();id!=$lower.end();++id) {
      nodesum += id->$area.sada*id->$facecenter ;
      areasum += id->$area.sada ;
    }
    for(const Entity *id=$boundary_map.begin();id!=$boundary_map.end();++id) {
      nodesum += id->$area.sada*id->$facecenter ;
      areasum += id->$area.sada ;
    }
    $cellcenter = nodesum/areasum ;
  }

  /* chem::get_aw_facecenter : pointwise_rule
   *	Computes the area-weighted face centroid by:
   *		- generating triangular facets from pairs of adjacent
   *		  vertices and the edge-length-weighted face
   *		  centroid,
   *		- computing the cross product of the vectors formed from
   *		  the two interior edges of the facet,
   *		- computing the area and midpoint of each edge,
   *		- performing the edge-length-weighted average of the
   *		  edge centers.
   */
  $rule pointwise(truecentroid::facecenter<-face2node->pos)
    ,constraint(exactCentroid,face2node->pos) {
    // Compute wireframe centroid for face
    vector3d<real_t> nodesum(0.0,0.0,0.0) ;
    real_t lensum = 0 ;
    warn($face2node.begin() == $face2node.end() ||
         $face2node.begin()+1 == $face2node.end()) ;
    for(const Entity *id=$face2node.begin();id+1!=$face2node.end();++id) {
      const Entity *nd = id+1 ;
      vector3d<real_t> edge_loc = 0.5*(id->$pos + nd->$pos) ;
      vector3d<real_t> edge_vec = id->$pos - nd->$pos ;
      real_t len = sqrt(dot(edge_vec,edge_vec)) ;
      nodesum += len*edge_loc ;
      lensum += len ;
    }
    const Entity *id = $face2node.begin() ;
    const Entity *idend = $face2node.end() - 1 ;
    vector3d<real_t> edge_loc = 0.5*(id->$pos + idend->$pos) ;
    vector3d<real_t> edge_vec = id->$pos - idend->$pos ;
    real_t len = sqrt(dot(edge_vec,edge_vec)) ;
    nodesum += len*edge_loc ;
    lensum += len ;
    
    vector3d<real_t> tmpcenter = nodesum/lensum ;
    
    // compute centroid using triangles formed by wireframe centroid
    vector3d<real_t> centroidsum(0.0,0.0,0.0) ;
    real_t facearea = 0 ;
    for(const Entity *id=$face2node.begin();id+1!=$face2node.end();++id) {
      const Entity *nd = id+1 ;
      const vector3d<real_t> t_centroid = (id->$pos + nd->$pos + tmpcenter)/3.0 ;
      const real_t t_area = 0.5*norm(cross(id->$pos-tmpcenter,
                                         nd->$pos-tmpcenter)) ;
      centroidsum += t_area*t_centroid ;
      facearea += t_area ;
    }
    const vector3d<real_t> t_centroid = (id->$pos + idend->$pos + tmpcenter)/3.0 ;
    const real_t t_area = 0.5*norm(cross(id->$pos-tmpcenter,
                                       idend->$pos-tmpcenter)) ;
    centroidsum += t_area*t_centroid ;
    facearea += t_area ;
    
    $facecenter = centroidsum/facearea ;
  }

#ifdef NOTUSED
  /* chem::get_vw_cellcenter : pointwise_rule
   *	Computes the centroid of a cell using a center-of-mass-type calculation:
   *		- Determine a temporary cell center by performing an average
   *		  of the centers of the faces.
   *		- Decompose the cell into tetrahedra with vertices specified
   *		  by the temporary cell center, the centers of each face, and
   *		  the two endpoints for all of the edges of the faces.
   *		- Compute the centroid and volume of each tetrahedron
   *		- Perform the volume weighted average of the tetrahedra
   *		  centroids
   */



  $rule pointwise(truecentroid::cellcenter<-(upper,lower,boundary_map)->facecenter,(upper,lower,boundary_map)->face2node->pos),constraint(geom_cells,exactCentroid) {
    const int num_faces = ($upper.size()+$lower.size()+$boundary_map.size()) ;
    tmp_array<Entity> facemap(num_faces) ;
    tmp_array<real> direction(num_faces) ;
      
    int count = 0;
    for(const Entity * f=$upper.begin(); f!=$upper.end(); ++f) {
      facemap[count] = *f ;
      direction[count++] = 1.0 ;
    }
    for(const Entity * f=$lower.begin(); f!=$lower.end(); ++f) {
      facemap[count] = *f ;
      direction[count++] = -1.0 ;
    }
    for(const int * f=$boundary_map.begin();
        f!=$boundary_map.end(); ++f) {
      facemap[count] = *f ;
      direction[count++] = 1.0 ;
    }

    vector3d<real_t> tmpcenter = vector3d<real_t>(0,0,0) ;
    for(int i=0;i<num_faces;++i) {
      const Entity *f = &facemap[i] ;
      tmpcenter += f->$facecenter ;
    }
    tmpcenter *= 1.0/real(num_faces) ;

    vector3d<real_t> cellcentroid = vector3d<real_t>(0,0,0) ;
    real_t cellvolume = 0.0;
    for(int i=0;i<num_faces;++i) {
      const Entity *f = &facemap[i] ;

      vector3d<real_t> fcentroid = vector3d<real_t>(0,0,0) ;
      real_t fvol = 0 ;
      
      int nfnode = f->$face2node.size() ;
      const vector3d<real_t> v3 = f->$facecenter-tmpcenter ;
      const vector3d<real_t> p3p4 = f->$facecenter+tmpcenter ;
      for(int j=0;j<nfnode;++j) {
        const vector3d<real_t> p1 = f->$face2node[j]->$pos ;
        const vector3d<real_t> p2 = f->$face2node[(j+1)==nfnode?0:j+1]->$pos ;
        const vector3d<real_t> v1 = (p1-tmpcenter) ;
        const vector3d<real_t> v2 = (p2-tmpcenter) ;
        const real_t v = dot(cross(v1,v2),v3) ; // six times volume
        const vector3d<real_t> x = ((p1+p2)+p3p4) ;// 4 times center
        fcentroid += v*x ;
        fvol += v ;
      }

      cellvolume += fvol*direction[i] ;
      cellcentroid += fcentroid*direction[i] ;
    }
    $cellcenter = cellcentroid/(4.*cellvolume);
  }

#endif
  
  $type max_fpc param<int> ;

  $rule unit(max_fpc),constraint(lower,upper,boundary_map) {
    $max_fpc = 0 ;
  } 

  $rule apply(max_fpc<-lower,upper,boundary_map)[Loci::Maximum] {
    const int nfaces = $upper.size() +$lower.size()+$boundary_map.size() ;
    join($max_fpc,nfaces) ;
  }
}
