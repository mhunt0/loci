#define DEBUG
#include <Loci.h>
$include "FVM.lh"
#include <vector>
using std::vector ;
#include <algorithm>
using std::sort ;
using std::unique ;

namespace Loci {
  $type frinkNodalMax(X) store<real_t> ;
  $type frinkNodalMin(X) store<real_t> ;
  $type X store<real_t> ;
  $type X_f store<real_t> ;

  using std::max ;
  using std::min ;
  using std::cout ;
  
  $rule unit(frinkNodalMax(X)), constraint(pos) {
    $frinkNodalMax(X) = std::numeric_limits<real_t>::min() ;
  }
  $rule apply(face2node->frinkNodalMax(X)<-cl->X)[Loci::Maximum] {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$frinkNodalMax(X),$cl->$X) ;
  }
  $rule apply(face2node->frinkNodalMax(X)<-cr->X)[Loci::Maximum] {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$frinkNodalMax(X),$cr->$X) ;
  }
  $rule apply(face2node->frinkNodalMax(X)<-X_f)[Loci::Maximum],constraint(ci->X) {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$frinkNodalMax(X),$X_f) ;
  }

  $rule unit(frinkNodalMin(X)), constraint(pos) {
    $frinkNodalMin(X) = std::numeric_limits<real_t>::max() ;
  }
  $rule apply(face2node->frinkNodalMin(X)<-cl->X)[Loci::Minimum] {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$frinkNodalMin(X),$cl->$X) ;
  }
  $rule apply(face2node->frinkNodalMin(X)<-cr->X)[Loci::Minimum] {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$frinkNodalMin(X),$cr->$X) ;
  }
  $rule apply(face2node->frinkNodalMin(X)<-X_f)[Loci::Minimum],constraint(ci->X) {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$frinkNodalMin(X),$X_f) ;
  }

  $type frinkNodalv3dMax(X) store<vector3d<real_t> > ;
  $type frinkNodalv3dMin(X) store<vector3d<real_t> > ;
  $type X store<vector3d<real_t> > ;
  $type X_f store<vector3d<real_t> > ;

  inline vector3d<real_t> max(const vector3d<real_t> &v1,
                              const vector3d<real_t> &v2) {
    return vector3d<real_t>(std::max(v1.x,v2.x),
                            std::max(v1.y,v2.y),
                            std::max(v1.z,v2.z)) ;
  }

  inline vector3d<real_t> min(const vector3d<real_t> &v1,
                              const vector3d<real_t> &v2) {
    return vector3d<real_t>(std::min(v1.x,v2.x),
                            std::min(v1.y,v2.y),
                            std::min(v1.z,v2.z)) ;
  }
  

  $rule unit(frinkNodalv3dMax(X)), constraint(pos) {
    const real_t mn = std::numeric_limits<real_t>::min() ;
    $frinkNodalv3dMax(X) = vector3d<real_t>(mn,mn,mn) ;
  }
  $rule apply(face2node->frinkNodalv3dMax(X)<-cl->X)[Loci::Maximum] {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$frinkNodalv3dMax(X),$cl->$X) ;
  }
  $rule apply(face2node->frinkNodalv3dMax(X)<-cr->X)[Loci::Maximum] {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$frinkNodalv3dMax(X),$cr->$X) ;
  }
  $rule apply(face2node->frinkNodalv3dMax(X)<-X_f)[Loci::Maximum],constraint(ci->X) {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$frinkNodalv3dMax(X),$X_f) ;
  }

  $rule unit(frinkNodalv3dMin(X)), constraint(pos) {
    const real_t mx = std::numeric_limits<real_t>::max() ;
    $frinkNodalv3dMin(X) = vector3d<real_t>(mx,mx,mx) ;
  }
  $rule apply(face2node->frinkNodalv3dMin(X)<-cl->X)[Loci::Minimum] {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$frinkNodalv3dMin(X),$cl->$X) ;
  }
  $rule apply(face2node->frinkNodalv3dMin(X)<-cr->X)[Loci::Minimum] {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$frinkNodalv3dMin(X),$cr->$X) ;
  }
  $rule apply(face2node->frinkNodalv3dMin(X)<-X_f)[Loci::Minimum],constraint(ci->X) {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$frinkNodalv3dMin(X),$X_f) ;
  }



  $type frinkNodalvMax(X) storeVec<real_t> ;
  $type frinkNodalvMin(X) storeVec<real_t> ;
  $type X storeVec<real_t> ;
  $type X_f storeVec<real_t> ;
  $type vecSize(X) param<int> ;


  $rule unit(frinkNodalvMax(X)<-vecSize(X)), constraint(pos), prelude {
    $frinkNodalvMax(X).setVecSize(*$vecSize(X)) ;
  } compute {
    $frinkNodalvMax(X) = mk_Scalar(std::numeric_limits<real_t>::min()) ;
  }
  $rule apply(face2node->frinkNodalvMax(X)<-cl->X)[Loci::Maximum] {
    const int sz = $face2node.size() ;
    for(int i=0;i<sz;++i)
      join($face2node[i]->$frinkNodalvMax(X),$cl->$X) ;
  }
  $rule apply(face2node->frinkNodalvMax(X)<-cr->X)[Loci::Maximum] {
    const int sz = $face2node.size() ;
    for(int i=0;i<sz;++i)
      join($face2node[i]->$frinkNodalvMax(X),$cr->$X) ;
  }
  $rule apply(face2node->frinkNodalvMax(X)<-X_f)[Loci::Maximum],
    constraint(ci->X) {
    const int sz = $face2node.size() ;
    for(int i=0;i<sz;++i)
      join($face2node[i]->$frinkNodalvMax(X),$X_f) ;
  }

  $rule unit(frinkNodalvMin(X)<-vecSize(X)), constraint(pos), prelude {
    $frinkNodalvMin(X).setVecSize(*$vecSize(X)) ;
  } compute {
    $frinkNodalvMin(X) = mk_Scalar(std::numeric_limits<real_t>::max()) ;
  }
  $rule apply(face2node->frinkNodalvMin(X)<-cl->X)[Loci::Minimum] {
    const int sz = $face2node.size() ;
    for(int i=0;i<sz;++i)
      join($face2node[i]->$frinkNodalvMin(X),$cl->$X) ;
  }
  $rule apply(face2node->frinkNodalvMin(X)<-cr->X)[Loci::Minimum] {
    const int sz = $face2node.size() ;
    for(int i=0;i<sz;++i)
      join($face2node[i]->$frinkNodalvMin(X),$cr->$X) ;
  }
  $rule apply(face2node->frinkNodalvMin(X)<-X_f)[Loci::Minimum],
    constraint(ci->X) {
    const int sz = $face2node.size() ;
    for(int i=0;i<sz;++i)
      join($face2node[i]->$frinkNodalvMin(X),$X_f) ;
  }

  // Now code to compute nodal values

  $type frink_nodal_weights store<real_t> ;

  $rule unit(frink_nodal_weights), constraint(pos) {
    $frink_nodal_weights = 0 ;
  }

  $rule apply((upper,lower,boundary_map)->face2node->frink_nodal_weights<-(upper,lower,boundary_map)->face2node->frink_nodal_weights,cellcenter,(upper,lower,boundary_map)->face2node->pos)[Loci::Summation],constraint(geom_cells) {
    int sztot = 0 ;
    
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      sztot += fi->$face2node.size() ;

    vector<Entity> node_list(sztot) ;
    int cnt = 0 ;
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    
    sort(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ne = unique(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ns = node_list.begin() ;
    for(vector<Entity>::iterator vi = ns;vi!=ne;++vi) {
      const real_t weight = 1./norm(vi->$pos-$cellcenter) ;
      join(vi->$frink_nodal_weights,weight) ;
    }
  }

  $type frinkLimiting param<std::string> ;

  $rule default(frinkLimiting),
    comments("use nodal extent limiting on the frink based gradient.  Option is 'yes' or 'no'")
  {
    $frinkLimiting = "yes" ;
  }

  $type frinkLimitingOn Constraint ;
  $type frinkLimitingOff Constraint ;

  $rule constraint(frinkLimitingOn,frinkLimitingOff<-frinkLimiting) {
    $frinkLimitingOn = EMPTY ;
    $frinkLimitingOff = EMPTY ;
    if($frinkLimiting == "yes") {
      $frinkLimitingOn = $*frinkLimiting.domain() ;
    } else if($frinkLimiting == "no") {
      $frinkLimitingOff = $*frinkLimiting.domain() ;
    } else {
      if(Loci::MPI_rank == 0) {
        cerr << "frinkLimiting must be 'yes' or 'no'" << endl ;
      }
      $frinkLimitingOff = $*frinkLimiting.domain() ;
    }
  }
  
  $type Wf_l store<vector3d<real_t> > ;
  $type Wf_r store<vector3d<real_t> > ;

  $type frinkNodal(X) store<real_t> ;
  $type X store<real_t> ;
  $type X_f store<real_t> ;

  
  $rule unit(frinkNodal(X)),constraint(pos) {
    $frinkNodal(X) = 0 ;
  }

  $rule apply((upper,lower,boundary_map)->face2node->frinkNodal(X)<-
              (upper,lower,boundary_map)->face2node->frink_nodal_weights,
              cellcenter,(upper,lower,boundary_map)->face2node->pos,
              (upper,lower,boundary_map)->face2node->frinkNodalMax(X),
              (upper,lower,boundary_map)->face2node->frinkNodalMin(X),
              lower->Wf_r,(upper,boundary_map)->Wf_l,
              X,lower->cl->X,upper->cr->X,boundary_map->X_f
              )[Loci::Summation],constraint(geom_cells,frinkLimitingOn) {
    int sztot = 0 ;
    
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      sztot += fi->$face2node.size() ;

    vector<Entity> node_list(sztot) ;
    int cnt = 0 ;
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    
    sort(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ne = unique(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ns = node_list.begin() ;

    // Now compute gradient

    vector3d<real_t> gradx = vector3d<real_t>(0,0,0) ;
    real_t X_center = $X ;
    for(const int *li = $lower.begin();li!=$lower.end();++li) {
      real_t df = li->$cl->$X - X_center ;
      gradx += df*li->$Wf_r ;
    }
    for(const int *ui = $upper.begin();ui!=$upper.end();++ui) {
      real_t df = ui->$cr->$X - X_center ;
      gradx += df*ui->$Wf_l ;
    }
    for(const int *bi = $boundary_map.begin();bi!=$boundary_map.end(); ++bi) {
      real_t df = bi->$X_f - X_center ;
      gradx += df*bi->$Wf_l ;
    }

    // grads[cc] = Qt_b ; 

    // compute weighted sum of node extrapolations
    for(vector<Entity>::iterator vi = ns;vi!=ne;++vi) {
      const vector3d<real_t> dv = (vi->$pos-$cellcenter) ;
      real_t x_p = $X + dot(gradx,dv) ;

      // Limit extrapolation
      x_p = min(x_p,vi->$frinkNodalMax(X)) ;
      x_p = max(x_p,vi->$frinkNodalMin(X)) ;
      // Compute weighted contribution to node
      const real_t x_contrib = x_p/(norm(dv)*vi->$frink_nodal_weights) ;
      join(vi->$frinkNodal(X),x_contrib) ;
    }
  }

  $rule apply((upper,lower,boundary_map)->face2node->frinkNodal(X)<-
              (upper,lower,boundary_map)->face2node->frink_nodal_weights,
              cellcenter,(upper,lower,boundary_map)->face2node->pos,
              lower->Wf_r,(upper,boundary_map)->Wf_l,
              X,lower->cl->X,upper->cr->X,boundary_map->X_f
              )[Loci::Summation],constraint(geom_cells,frinkLimitingOff) {
    int sztot = 0 ;
    
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      sztot += fi->$face2node.size() ;

    vector<Entity> node_list(sztot) ;
    int cnt = 0 ;
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    
    sort(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ne = unique(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ns = node_list.begin() ;

    // Now compute gradient

    vector3d<real_t> gradx = vector3d<real_t>(0,0,0) ;
    real_t X_center = $X ;
    for(const int *li = $lower.begin();li!=$lower.end();++li) {
      real_t df = li->$cl->$X - X_center ;
      gradx += df*li->$Wf_r ;
    }
    for(const int *ui = $upper.begin();ui!=$upper.end();++ui) {
      real_t df = ui->$cr->$X - X_center ;
      gradx += df*ui->$Wf_l ;
    }
    for(const int *bi = $boundary_map.begin();bi!=$boundary_map.end(); ++bi) {
      real_t df = bi->$X_f - X_center ;
      gradx += df*bi->$Wf_l ;
    }

    // grads[cc] = Qt_b ; 

    // compute weighted sum of node extrapolations
    for(vector<Entity>::iterator vi = ns;vi!=ne;++vi) {
      const vector3d<real_t> dv = (vi->$pos-$cellcenter) ;
      real_t x_p = $X + dot(gradx,dv) ;

      // Compute weighted contribution to node
      const real_t x_contrib = x_p/(norm(dv)*vi->$frink_nodal_weights) ;
      join(vi->$frinkNodal(X),x_contrib) ;
    }
  }

  $type frinkNodalv3d(X) store<vector3d<real_t> > ;

  $type X store<vector3d<real_t> > ;
  $type X_f store<vector3d<real_t> > ;

  
  $rule unit(frinkNodalv3d(X)),constraint(pos) {
    $frinkNodalv3d(X) = vector3d<real_t>(0,0,0) ;
  }

  $rule apply((upper,lower,boundary_map)->face2node->frinkNodalv3d(X)<-
              (upper,lower,boundary_map)->face2node->frink_nodal_weights,
              cellcenter,(upper,lower,boundary_map)->face2node->pos,
              (upper,lower,boundary_map)->face2node->frinkNodalv3dMax(X),
              (upper,lower,boundary_map)->face2node->frinkNodalv3dMin(X),
              lower->Wf_r,(upper,boundary_map)->Wf_l,
              X,lower->cl->X,upper->cr->X,boundary_map->X_f
              )[Loci::Summation],constraint(geom_cells,frinkLimitingOn) {
    int sztot = 0 ;
    
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      sztot += fi->$face2node.size() ;

    vector<Entity> node_list(sztot) ;
    int cnt = 0 ;
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    
    sort(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ne = unique(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ns = node_list.begin() ;

    // Now compute gradient

    const vector3d<real_t> X_center = $X ;
    tensor3d<real_t>  gradx = tensor3d<real_t> (vector3d<real_t>(0,0,0),vector3d<real_t>(0,0,0),vector3d<real_t>(0,0,0)) ;
    for(const int *li = $lower.begin();li!=$lower.end();++li) {
      vector3d<real_t> df = li->$cl->$X - X_center ;
      gradx.x += df.x*li->$Wf_r ;
      gradx.y += df.y*li->$Wf_r ;
      gradx.z += df.z*li->$Wf_r ;
    }
    for(const int *ui = $upper.begin();ui!=$upper.end();++ui) {
      vector3d<real_t> df = ui->$cr->$X - X_center ;
      gradx.x += df.x*ui->$Wf_l ;
      gradx.y += df.y*ui->$Wf_l ;
      gradx.z += df.z*ui->$Wf_l ;
    }
    for(const int *bi = $boundary_map.begin();bi!=$boundary_map.end(); ++bi) {
      vector3d<real_t> df = bi->$X_f - X_center ;
      gradx.x += df.x*bi->$Wf_l ;
      gradx.y += df.y*bi->$Wf_l ;
      gradx.z += df.z*bi->$Wf_l ;
    }

    // compute weighted sum of node extrapolations
    for(vector<Entity>::iterator vi = ns;vi!=ne;++vi) {
      const vector3d<real_t> dv = (vi->$pos-$cellcenter) ;
      vector3d<real_t> x_p = $X + dot(gradx,dv) ;

      // Limit extrapolation
      x_p = min(x_p,vi->$frinkNodalv3dMax(X)) ;
      x_p = max(x_p,vi->$frinkNodalv3dMin(X)) ;
      
      // Compute weighted contribution to node
      const vector3d<real_t> x_contrib = x_p/(norm(dv)*vi->$frink_nodal_weights) ;
      join(vi->$frinkNodalv3d(X),x_contrib) ;
    }
  }

  $rule apply((upper,lower,boundary_map)->face2node->frinkNodalv3d(X)<-
              (upper,lower,boundary_map)->face2node->frink_nodal_weights,
              cellcenter,(upper,lower,boundary_map)->face2node->pos,
              lower->Wf_r,(upper,boundary_map)->Wf_l,
              X,lower->cl->X,upper->cr->X,boundary_map->X_f
              )[Loci::Summation],constraint(geom_cells,frinkLimitingOff) {
    int sztot = 0 ;
    
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      sztot += fi->$face2node.size() ;

    vector<Entity> node_list(sztot) ;
    int cnt = 0 ;
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    
    sort(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ne = unique(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ns = node_list.begin() ;

    // Now compute gradient

    const vector3d<real_t> X_center = $X ;
    tensor3d<real_t>  gradx = tensor3d<real_t> (vector3d<real_t>(0,0,0),vector3d<real_t>(0,0,0),vector3d<real_t>(0,0,0)) ;
    for(const int *li = $lower.begin();li!=$lower.end();++li) {
      vector3d<real_t> df = li->$cl->$X - X_center ;
      gradx.x += df.x*li->$Wf_r ;
      gradx.y += df.y*li->$Wf_r ;
      gradx.z += df.z*li->$Wf_r ;
    }
    for(const int *ui = $upper.begin();ui!=$upper.end();++ui) {
      vector3d<real_t> df = ui->$cr->$X - X_center ;
      gradx.x += df.x*ui->$Wf_l ;
      gradx.y += df.y*ui->$Wf_l ;
      gradx.z += df.z*ui->$Wf_l ;
    }
    for(const int *bi = $boundary_map.begin();bi!=$boundary_map.end(); ++bi) {
      vector3d<real_t> df = bi->$X_f - X_center ;
      gradx.x += df.x*bi->$Wf_l ;
      gradx.y += df.y*bi->$Wf_l ;
      gradx.z += df.z*bi->$Wf_l ;
    }

    // compute weighted sum of node extrapolations
    for(vector<Entity>::iterator vi = ns;vi!=ne;++vi) {
      const vector3d<real_t> dv = (vi->$pos-$cellcenter) ;
      vector3d<real_t> x_p = $X + dot(gradx,dv) ;

      // Compute weighted contribution to node
      const vector3d<real_t> x_contrib = x_p/(norm(dv)*vi->$frink_nodal_weights) ;
      join(vi->$frinkNodalv3d(X),x_contrib) ;
    }
  }

  $type frinkNodalv(X) storeVec<real_t> ;
  $type X storeVec<real_t> ;
  $type X_f storeVec<real_t> ;

  
  $rule unit(frinkNodalv(X)<-vecSize(X)),constraint(pos), prelude {
    $frinkNodalv(X).setVecSize(*$vecSize(X)) ;
  } compute {
    $frinkNodalv(X) = mk_Scalar(0) ;
  }

  $rule apply((upper,lower,boundary_map)->face2node->frinkNodalv(X)<-
              (upper,lower,boundary_map)->face2node->frink_nodal_weights,
              cellcenter,(upper,lower,boundary_map)->face2node->pos,
              (upper,lower,boundary_map)->face2node->frinkNodalvMax(X),
              (upper,lower,boundary_map)->face2node->frinkNodalvMin(X),
              lower->Wf_r,(upper,boundary_map)->Wf_l,
              X,lower->cl->X,upper->cr->X,boundary_map->X_f
              )[Loci::Summation],constraint(geom_cells,frinkLimitingOn) {
    int sztot = 0 ;
    
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      sztot += fi->$face2node.size() ;

    vector<Entity> node_list(sztot) ;
    int cnt = 0 ;
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    
    sort(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ne = unique(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ns = node_list.begin() ;

    // Now compute gradient
    const int vs = $*frinkNodalv(X).vecSize() ;

    for(int i=0;i<vs;++i) {
      vector3d<real_t> gradx = vector3d<real_t>(0,0,0) ;
      real_t X_center = $X[i] ;
      for(const int *li = $lower.begin();li!=$lower.end();++li) {
        real_t df = li->$cl->$X[i] - X_center ;
        gradx += df*li->$Wf_r ;
      }
      for(const int *ui = $upper.begin();ui!=$upper.end();++ui) {
        real_t df = ui->$cr->$X[i] - X_center ;
        gradx += df*ui->$Wf_l ;
      }
      for(const int *bi = $boundary_map.begin();bi!=$boundary_map.end(); ++bi) {
        real_t df = bi->$X_f[i] - X_center ;
        gradx += df*bi->$Wf_l ;
      }

      // compute weighted sum of node extrapolations
      for(vector<Entity>::iterator vi = ns;vi!=ne;++vi) {
        const vector3d<real_t> dv = (vi->$pos-$cellcenter) ;
        real_t x_p = $X[i] + dot(gradx,dv) ;

        // Limit extrapolation
        x_p = min(x_p,vi->$frinkNodalvMax(X)[i]) ;
        x_p = max(x_p,vi->$frinkNodalvMin(X)[i]) ;

        // Compute weighted contribution to node
        const real_t x_contrib = x_p/(norm(dv)*vi->$frink_nodal_weights) ;
        vi->$frinkNodalv(X)[i] += x_contrib ;
      }
    }
  }
  $rule apply((upper,lower,boundary_map)->face2node->frinkNodalv(X)<-
              (upper,lower,boundary_map)->face2node->frink_nodal_weights,
              cellcenter,(upper,lower,boundary_map)->face2node->pos,
              lower->Wf_r,(upper,boundary_map)->Wf_l,
              X,lower->cl->X,upper->cr->X,boundary_map->X_f
              )[Loci::Summation],constraint(geom_cells,frinkLimitingOff) {
    int sztot = 0 ;
    
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      sztot += fi->$face2node.size() ;

    vector<Entity> node_list(sztot) ;
    int cnt = 0 ;
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    
    sort(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ne = unique(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ns = node_list.begin() ;

    // Now compute gradient
    const int vs = $*frinkNodalv(X).vecSize() ;

    for(int i=0;i<vs;++i) {
      vector3d<real_t> gradx = vector3d<real_t>(0,0,0) ;
      real_t X_center = $X[i] ;
      for(const int *li = $lower.begin();li!=$lower.end();++li) {
        real_t df = li->$cl->$X[i] - X_center ;
        gradx += df*li->$Wf_r ;
      }
      for(const int *ui = $upper.begin();ui!=$upper.end();++ui) {
        real_t df = ui->$cr->$X[i] - X_center ;
        gradx += df*ui->$Wf_l ;
      }
      for(const int *bi = $boundary_map.begin();bi!=$boundary_map.end(); ++bi) {
        real_t df = bi->$X_f[i] - X_center ;
        gradx += df*bi->$Wf_l ;
      }

      // compute weighted sum of node extrapolations
      for(vector<Entity>::iterator vi = ns;vi!=ne;++vi) {
        const vector3d<real_t> dv = (vi->$pos-$cellcenter) ;
        real_t x_p = $X[i] + dot(gradx,dv) ;

        // Compute weighted contribution to node
        const real_t x_contrib = x_p/(norm(dv)*vi->$frink_nodal_weights) ;
        vi->$frinkNodalv(X)[i] += x_contrib ;
      }
    }
  }

  // Second order area integration
  $type frinkIntegrate(X) store<real_t> ;
  $type X store<real_t> ;
  
  $rule pointwise(frinkIntegrate(X)<-area,facecenter,face2node->pos,face2node->frinkNodal(X)) {
    const int sz = $face2node.size() ;
    const vector3d<real_t> center = $facecenter ;

    // We will use the Laplacian to compute a second order accurate
    // value for the face centroid from nodal values
    // We project the face coordinates into a two dimensional plane
    // with the same normal as the face.
    
    // First compute local coordinate system
    vector3d<real_t> n = $area.n ;
    vector3d<real_t> v1 = $face2node[0]->$pos-center ;
    vector3d<real_t> v2 = $face2node[1]->$pos-$face2node[0]->$pos ;
    v1 = v1-n*dot(v1,n) ;
    v1 = v1/norm(v1) ;
    v2 = v2-n*dot(v2,n) ;
    v2 = v2-v1*dot(v1,v2) ;
    v2 = v2/norm(v2) ;
    // v1 and v2 are the face coordinate unit vectors

    // Now we solve an optimation problem whereby we minimize the variance
    // of the weights
    real_t Rx = 0 ;
    real_t Ry = 0 ;
    real_t Ixx = 0 ;
    real_t Ixy = 0 ;
    real_t Iyy = 0 ;
    
    // v1 and v2 are orthogonal face coordinate normal vectors
    for(int i=0;i<sz;++i) {
      const vector3d<real_t> dv = $face2node[i]->$pos-center ;
      const real_t xl = dot(dv,v1) ;
      const real_t yl = dot(dv,v2) ;
      Rx += xl ;
      Ry += yl ;
      Ixx += xl*xl ;
      Ixy += xl*yl ;
      Iyy += yl*yl ;
    }
    const real_t rcoef = 1./(Ixx*Iyy-Ixy*Ixy) ;
    const real_t lambdax = (Ixy*Ry-Iyy*Rx)*rcoef ;
    const real_t lambday = (Ixy*Rx-Ixx*Ry)*rcoef ;

    //Now we compute the weighted sums for the interpolation value
    real_t Xc = 0 ;
    real_t w_tot = 0 ;
    for(int i=0;i<sz;++i) {
      const vector3d<real_t> dv = $face2node[i]->$pos-center ;
      const real_t xl = dot(dv,v1) ;
      const real_t yl = dot(dv,v2) ;
      const real_t dw = lambdax*xl+lambday*yl ;
      const real_t w = (1.+dw) ;
      w_tot += w ;
      warn(w<0.0) ;
      Xc += w*$face2node[i]->$frinkNodal(X) ;
    }
    $frinkIntegrate(X) = Xc/w_tot ;
    
  }
  
  $type frinkIntegratev(X) storeVec<real_t> ;
  $type X storeVec<real_t> ;
  
  $rule pointwise(frinkIntegratev(X)<-area,facecenter,face2node->pos,face2node->frinkNodalv(X)), prelude {
    $frinkIntegratev(X).setVecSize($frinkNodalv(X).vecSize()) ;
  } compute {
    const int sz = $face2node.size() ;
    const vector3d<real_t> center = $facecenter ;

    // We will use the Laplacian to compute a second order accurate
    // value for the face centroid from nodal values
    // We project the face coordinates into a two dimensional plane
    // with the same normal as the face.
    
    // First compute local coordinate system
    vector3d<real_t> n = $area.n ;
    vector3d<real_t> v1 = $face2node[0]->$pos-center ;
    vector3d<real_t> v2 = $face2node[1]->$pos-$face2node[0]->$pos ;
    v1 = v1-n*dot(v1,n) ;
    v1 = v1/norm(v1) ;
    v2 = v2-n*dot(v2,n) ;
    v2 = v2-v1*dot(v1,v2) ;
    v2 = v2/norm(v2) ;
    // v1 and v2 are the face coordinate unit vectors

    // Now we solve an optimation problem whereby we minimize the variance
    // of the weights
    real_t Rx = 0 ;
    real_t Ry = 0 ;
    real_t Ixx = 0 ;
    real_t Ixy = 0 ;
    real_t Iyy = 0 ;
    
    // v1 and v2 are orthogonal face coordinate normal vectors
    for(int i=0;i<sz;++i) {
      const vector3d<real_t> dv = $face2node[i]->$pos-center ;
      const real_t xl = dot(dv,v1) ;
      const real_t yl = dot(dv,v2) ;
      Rx += xl ;
      Ry += yl ;
      Ixx += xl*xl ;
      Ixy += xl*yl ;
      Iyy += yl*yl ;
    }
    const real_t rcoef = 1./(Ixx*Iyy-Ixy*Ixy) ;
    const real_t lambdax = (Ixy*Ry-Iyy*Rx)*rcoef ;
    const real_t lambday = (Ixy*Rx-Ixx*Ry)*rcoef ;

    //Now we compute the weighted sums for the interpolation value

    const int nv = $*frinkNodalv(X).vecSize() ;
    for(int j=0;j<nv;++j)
      $frinkIntegratev(X)[j] = 0 ;
    real_t w_tot = 0 ;
    for(int i=0;i<sz;++i) {
      const vector3d<real_t> dv = $face2node[i]->$pos-center ;
      const real_t xl = dot(dv,v1) ;
      const real_t yl = dot(dv,v2) ;
      
      const real_t dw = lambdax*xl+lambday*yl ;
      const real_t w = (1.+dw) ;
      w_tot += w ;
      warn(w<0.0) ;
      for(int j=0;j<nv;++j)
        $frinkIntegratev(X)[j] += w*$face2node[i]->$frinkNodalv(X)[j] ;
    }
    for(int j=0;j<nv;++j)
      $frinkIntegratev(X)[j] *= 1./w_tot ;

  }

  $type frinkIntegratev3d(X) store<vector3d<real_t> > ;
  $type X store<vector3d<real_t> > ;
  
  $rule pointwise(frinkIntegratev3d(X)<-area,facecenter,face2node->pos,face2node->frinkNodalv3d(X)) {
    const int sz = $face2node.size() ;
    const vector3d<real_t> center = $facecenter ;

    // We will use the Laplacian to compute a second order accurate
    // value for the face centroid from nodal values
    // We project the face coordinates into a two dimensional plane
    // with the same normal as the face.
    
    // First compute local coordinate system
    vector3d<real_t> n = $area.n ;
    vector3d<real_t> v1 = $face2node[0]->$pos-center ;
    vector3d<real_t> v2 = $face2node[1]->$pos-$face2node[0]->$pos ;
    v1 = v1-n*dot(v1,n) ;
    v1 = v1/norm(v1) ;
    v2 = v2-n*dot(v2,n) ;
    v2 = v2-v1*dot(v1,v2) ;
    v2 = v2/norm(v2) ;
    // v1 and v2 are the face coordinate unit vectors

    // Now we solve an optimation problem whereby we minimize the variance
    // of the weights
    real_t Rx = 0 ;
    real_t Ry = 0 ;
    real_t Ixx = 0 ;
    real_t Ixy = 0 ;
    real_t Iyy = 0 ;
    
    // v1 and v2 are orthogonal face coordinate normal vectors
    for(int i=0;i<sz;++i) {
      const vector3d<real_t> dv = $face2node[i]->$pos-center ;
      const real_t xl = dot(dv,v1) ;
      const real_t yl = dot(dv,v2) ;
      Rx += xl ;
      Ry += yl ;
      Ixx += xl*xl ;
      Ixy += xl*yl ;
      Iyy += yl*yl ;
    }
    const real_t rcoef = 1./(Ixx*Iyy-Ixy*Ixy) ;
    const real_t lambdax = (Ixy*Ry-Iyy*Rx)*rcoef ;
    const real_t lambday = (Ixy*Rx-Ixx*Ry)*rcoef ;

    //Now we compute the weighted sums for the interpolation value
    vector3d<real_t> Xc = vector3d<real_t>(0,0,0) ;
    real_t w_tot = 0 ;
    for(int i=0;i<sz;++i) {
      const vector3d<real_t> dv = $face2node[i]->$pos-center ;
      const real_t xl = dot(dv,v1) ;
      const real_t yl = dot(dv,v2) ;
      const real_t dw = lambdax*xl+lambday*yl ;
      const real_t w = (1.+dw) ;
      w_tot += w ;
      warn(w<0.0) ;
      Xc += w*$face2node[i]->$frinkNodalv3d(X) ;
    }
    $frinkIntegratev3d(X) = Xc/w_tot ;
  }

  $type X storeVec<real_t> ;
  $type X_f storeVec<real_t> ;
  
  
  $rule pointwise(gradv(X)<-(lower,upper)->(area,frinkIntegratev(X)),
                  boundary_map->(X_f,area),vol),
    constraint(geom_cells,frinkGradient), prelude {
    $gradv(X).setVecSize($frinkIntegratev(X).vecSize()) ;
  } compute {
    const real_t rvol = 1./$vol ;
    const int vs = $*frinkIntegratev(X).vecSize() ;
    for(int i=0;i<vs;++i) {
      vector3d<real_t> gradsum = vector3d<real_t>(0.0,0.0,0.0);
      for(const Entity *li = $lower.begin();li!=$lower.end();++li) {
        const real_t xf = li->$frinkIntegratev(X)[i] ;
        gradsum -= xf*li->$area.sada*li->$area.n ;
      }
      for(const Entity *ui = $upper.begin();ui!=$upper.end();++ui) {
        const real_t xf = ui->$frinkIntegratev(X)[i] ;
         gradsum += xf*ui->$area.sada*ui->$area.n ;
      }
      for(const Entity *bi = $boundary_map.begin();bi!=$boundary_map.end();
          ++bi) {
        gradsum += bi->$X_f[i]*bi->$area.sada*bi->$area.n ;
      }

       $gradv(X)[i] = gradsum*rvol  ; 
    }
  }

  $type X store<real_t> ;
  $type X_f store<real_t> ;

  $rule pointwise(grads(X)<-(lower,upper)->(area,frinkIntegrate(X)),boundary_map->(X_f,area,frinkIntegrate(X)),vol),
    constraint(geom_cells,frinkGradient) {
    const real_t rvol = 1./$vol ;
    vector3d<real_t> gradsum = vector3d<real_t>(0.0,0.0,0.0);
    for(const Entity *li = $lower.begin();li!=$lower.end();++li) {
      const real_t xf = li->$frinkIntegrate(X) ;
      gradsum -= xf*li->$area.sada*li->$area.n ;
    }
    for(const Entity *ui = $upper.begin();ui!=$upper.end();++ui) {
      const real_t xf = ui->$frinkIntegrate(X) ;
      gradsum += xf*ui->$area.sada*ui->$area.n ;
    }
    for(const Entity *bi = $boundary_map.begin();bi!=$boundary_map.end();
        ++bi) {
      gradsum += bi->$X_f*bi->$area.sada*bi->$area.n ;
    }
    
    $grads(X)= gradsum*rvol  ; 
  }


  $type X store<vector3d<real_t> > ;
  $type X_f store<vector3d<real_t> > ;
  
  $rule pointwise(gradv3d(X)<-(lower,upper)->(frinkIntegratev3d(X),area),boundary_map->(X_f,area),vol),
    constraint(geom_cells,frinkGradient) {
    tensor3d<real_t>  gradsum = tensor3d<real_t> (vector3d<real_t>(0,0,0),vector3d<real_t>(0,0,0),vector3d<real_t>(0,0,0)) ;
    const real_t rvol = 1./$vol ;
    
    for(const Entity *li = $lower.begin();li!=$lower.end();++li) {
      const vector3d<real_t> xf = li->$frinkIntegratev3d(X) ;
      gradsum.x -= xf.x*li->$area.sada*li->$area.n ;
      gradsum.y -= xf.y*li->$area.sada*li->$area.n ;
      gradsum.z -= xf.z*li->$area.sada*li->$area.n ;
    }
    for(const Entity *ui = $upper.begin();ui!=$upper.end();++ui) {
      const vector3d<real_t> xf = ui->$frinkIntegratev3d(X) ;
      gradsum.x += xf.x*ui->$area.sada*ui->$area.n ;
      gradsum.y += xf.y*ui->$area.sada*ui->$area.n ;
      gradsum.z += xf.z*ui->$area.sada*ui->$area.n ;
    }
    for(const Entity *bi = $boundary_map.begin();bi!=$boundary_map.end();
        ++bi) {
      gradsum.x += bi->$X_f.x*bi->$area.sada*bi->$area.n ;
      gradsum.y += bi->$X_f.y*bi->$area.sada*bi->$area.n ;
      gradsum.z += bi->$X_f.z*bi->$area.sada*bi->$area.n ;
    }

    $gradv3d(X).x = gradsum.x*rvol  ; 
    $gradv3d(X).y = gradsum.y*rvol  ; 
    $gradv3d(X).z = gradsum.z*rvol  ; 
  }

  // Frink face gradients:
  $type X store<real_t> ;
  $type X_f store<real_t> ;

  $rule pointwise(frink::grads_f(X)<-(cl,cr)->(X,cellcenter),
                  face2node->(frinkNodal(X),pos)),
    constraint(frinkGradient,(cl,cr)->cellcenter) {
    const int sz = $face2node.size() ;
    const vector3d<real_t> center_l = $cl->$cellcenter ;
    const vector3d<real_t> center_r = $cr->$cellcenter ;
    vector3d<real_t> sum = vector3d<real_t>(0,0,0) ;
    real_t lvol = 0 ;

    for(int i=0;i<sz;++i) {
      int n1 = i ;
      int n2 = (i+1)%sz ;
      const real_t X1 = $face2node[n1]->$frinkNodal(X) ;
      const real_t X2 = $face2node[n1]->$frinkNodal(X) ;
      // 2*dot(A,n)
      const vector3d<real_t> v1l = $face2node[n1]->$pos-center_l ;
      const vector3d<real_t> v2l = $face2node[n2]->$pos-center_l ;
      sum -= ($cl->$X+X1+X2)*cross(v1l,v2l) ;
      const vector3d<real_t> v1r = $face2node[n1]->$pos-center_r ;
      const vector3d<real_t> v2r = $face2node[n2]->$pos-center_r ;
      const vector3d<real_t> crossr = cross(v1r,v2r) ;
      sum += ($cr->$X+X1+X2)*crossr ;
      lvol += dot(center_r-center_l,crossr) ;
    }
    $grads_f(X) = sum/lvol ;
  }

  $rule pointwise(frink::grads_f(X)<-ci->(X,cellcenter),X_f,facecenter,
                  face2node->(frinkNodal(X),pos)),
    constraint(frinkGradient,ci->cellcenter) {
    const int sz = $face2node.size() ;
    const vector3d<real_t> center_l = $ci->$cellcenter ;
    const vector3d<real_t> center_r = $facecenter ;
    vector3d<real_t> sum = vector3d<real_t>(0,0,0) ;
    real_t lvol = 0 ;

    for(int i=0;i<sz;++i) {
      int n1 = i ;
      int n2 = (i+1)%sz ;
      const real_t X1 = $face2node[n1]->$frinkNodal(X) ;
      const real_t X2 = $face2node[n1]->$frinkNodal(X) ;
      // 2*dot(A,n)
      const vector3d<real_t> v1l = $face2node[n1]->$pos-center_l ;
      const vector3d<real_t> v2l = $face2node[n2]->$pos-center_l ;
      sum -= ($ci->$X+X1+X2)*cross(v1l,v2l) ;
      const vector3d<real_t> v1r = $face2node[n1]->$pos-center_r ;
      const vector3d<real_t> v2r = $face2node[n2]->$pos-center_r ;
      const vector3d<real_t> crossr = cross(v1r,v2r) ;
      sum += ($X_f+X1+X2)*crossr ;
      lvol += dot(center_r-center_l,crossr) ;
    }
    $grads_f(X) = sum/lvol ;
  }

  $type X storeVec<real_t> ;
  $type X_f storeVec<real_t> ;

  $rule pointwise(frink::gradv_f(X)<-(cl,cr)->(X,cellcenter),
                  face2node->(frinkNodalv(X),pos)),
    constraint(frinkGradient,(cl,cr)->cellcenter),prelude {
    $gradv_f(X).setVecSize($X.vecSize()) ;
  } compute {
    const int vs = $*gradv_f(X).vecSize() ;
    
    const int sz = $face2node.size() ;
    const vector3d<real_t> center_l = $cl->$cellcenter ;
    const vector3d<real_t> center_r = $cr->$cellcenter ;

    for(int j=0;j<vs;++j) {
      vector3d<real_t> sum = vector3d<real_t>(0,0,0) ;
      real_t lvol = 0 ;

      for(int i=0;i<sz;++i) {
        int n1 = i ;
        int n2 = (i+1)%sz ;
        const real_t X1 = $face2node[n1]->$frinkNodalv(X)[j] ;
        const real_t X2 = $face2node[n1]->$frinkNodalv(X)[j] ;
        // 2*dot(A,n)
        const vector3d<real_t> v1l = $face2node[n1]->$pos-center_l ;
        const vector3d<real_t> v2l = $face2node[n2]->$pos-center_l ;
        sum -= ($cl->$X[j]+X1+X2)*cross(v1l,v2l) ;
        const vector3d<real_t> v1r = $face2node[n1]->$pos-center_r ;
        const vector3d<real_t> v2r = $face2node[n2]->$pos-center_r ;
        const vector3d<real_t> crossr = cross(v1r,v2r) ;
        sum += ($cr->$X[j]+X1+X2)*crossr ;
        lvol += dot(center_r-center_l,crossr) ;
      }
      $gradv_f(X)[j] = sum/lvol ;
    }
  }

  $rule pointwise(frink::gradv_f(X)<-ci->(X,cellcenter),X_f,facecenter,
                  face2node->(frinkNodalv(X),pos)),
      constraint(frinkGradient,ci->cellcenter), prelude {
    $gradv_f(X).setVecSize($X_f.vecSize()) ;
  } compute {
    const int vs = $*X_f.vecSize() ;
    const int sz = $face2node.size() ;
    const vector3d<real_t> center_l = $ci->$cellcenter ;
    const vector3d<real_t> center_r = $facecenter ;

    for(int j=0;j<vs;++j) {
      vector3d<real_t> sum = vector3d<real_t>(0,0,0) ;
      real_t lvol = 0 ;
      
      for(int i=0;i<sz;++i) {
        int n1 = i ;
        int n2 = (i+1)%sz ;
        const real_t X1 = $face2node[n1]->$frinkNodalv(X)[j] ;
        const real_t X2 = $face2node[n1]->$frinkNodalv(X)[j] ;
        // 2*dot(A,n)
        const vector3d<real_t> v1l = $face2node[n1]->$pos-center_l ;
        const vector3d<real_t> v2l = $face2node[n2]->$pos-center_l ;
        sum -= ($ci->$X[j]+X1+X2)*cross(v1l,v2l) ;
        const vector3d<real_t> v1r = $face2node[n1]->$pos-center_r ;
        const vector3d<real_t> v2r = $face2node[n2]->$pos-center_r ;
        const vector3d<real_t> crossr = cross(v1r,v2r) ;
        sum += ($X_f[j]+X1+X2)*crossr ;
        lvol += dot(center_r-center_l,crossr) ;
      }
      $gradv_f(X)[j] = sum/lvol ;
    }
  }

  // This doesn't seem to work... why?
#ifdef FRINK_FACE_GRAD

  $type X store<vector3d<real_t> > ;
  $type X_f store<vector3d<real_t> > ;

  $rule pointwise(frink::gradv3d_f(X)<-(cl,cr)->(X,cellcenter),
                  face2node->(frinkNodalv3d(X),pos)),
    constraint(frinkGradient,(cl,cr)->cellcenter) {
    const int sz = $face2node.size() ;
    const vector3d<real_t> center_l = $cl->$cellcenter ;
    const vector3d<real_t> center_r = $cr->$cellcenter ;
    vector3d<real_t> sumx = vector3d<real_t>(0,0,0) ;
    vector3d<real_t> sumy = vector3d<real_t>(0,0,0) ;
    vector3d<real_t> sumz = vector3d<real_t>(0,0,0) ;
    real_t lvol = 0 ;

    for(int i=0;i<sz;++i) {
      int n1 = i ;
      int n2 = (i+1)%sz ;
      const vector3d<real_t> X1 = $face2node[n1]->$frinkNodalv3d(X) ;
      const vector3d<real_t> X2 = $face2node[n1]->$frinkNodalv3d(X) ;
      // 2*dot(A,n)
      const vector3d<real_t> v1l = $face2node[n1]->$pos-center_l ;
      const vector3d<real_t> v2l = $face2node[n2]->$pos-center_l ;
      const vector3d<real_t> crossl = cross(v1l,v2l) ;
      sumx -= ($cl->$X.x+X1.x+X2.x)*crossl ;
      sumy -= ($cl->$X.y+X1.y+X2.y)*crossl ;
      sumz -= ($cl->$X.z+X1.z+X2.z)*crossl ;
      const vector3d<real_t> v1r = $face2node[n1]->$pos-center_r ;
      const vector3d<real_t> v2r = $face2node[n2]->$pos-center_r ;
      const vector3d<real_t> crossr = cross(v1r,v2r) ;
      sumx += ($cr->$X.x+X1.x+X2.x)*crossr ;
      sumy += ($cr->$X.y+X1.y+X2.y)*crossr ;
      sumz += ($cr->$X.z+X1.z+X2.z)*crossr ;
      lvol += dot(center_r-center_l,crossr) ;
    }
    const real_t rlvol = 1./lvol ;
    $gradv3d_f(X).x = sumx*rlvol ;
    $gradv3d_f(X).y = sumy*rlvol ;
    $gradv3d_f(X).z = sumz*rlvol ;
  }


  $rule pointwise(frink::gradv3d_f(X)<-ci->(X,cellcenter),X_f,facecenter,
                  face2node->(frinkNodalv3d(X),pos)),
    constraint(frinkGradient,ci->cellcenter) {
    const int sz = $face2node.size() ;
    const vector3d<real_t> center_l = $ci->$cellcenter ;
    const vector3d<real_t> center_r = $facecenter ;
    vector3d<real_t> sumx = vector3d<real_t>(0,0,0) ;
    vector3d<real_t> sumy = vector3d<real_t>(0,0,0) ;
    vector3d<real_t> sumz = vector3d<real_t>(0,0,0) ;
    real_t lvol = 0 ;

    for(int i=0;i<sz;++i) {
      int n1 = i ;
      int n2 = (i+1)%sz ;
      const vector3d<real_t> X1 = $face2node[n1]->$frinkNodalv3d(X) ;
      const vector3d<real_t> X2 = $face2node[n1]->$frinkNodalv3d(X) ;
      // 2*dot(A,n)
      const vector3d<real_t> v1l = $face2node[n1]->$pos-center_l ;
      const vector3d<real_t> v2l = $face2node[n2]->$pos-center_l ;
      const vector3d<real_t> crossl = cross(v1l,v2l) ;
      sumx -= ($ci->$X.x+X1.x+X2.x)*crossl ;
      sumy -= ($ci->$X.y+X1.y+X2.y)*crossl ;
      sumz -= ($ci->$X.z+X1.z+X2.z)*crossl ;
      const vector3d<real_t> v1r = $face2node[n1]->$pos-center_r ;
      const vector3d<real_t> v2r = $face2node[n2]->$pos-center_r ;
      const vector3d<real_t> crossr = cross(v1r,v2r) ;
      sumx += ($X_f.x+X1.x+X2.x)*crossr ;
      sumy += ($X_f.x+X1.x+X2.x)*crossr ;
      sumz += ($X_f.x+X1.x+X2.x)*crossr ;
      lvol += dot(center_r-center_l,crossr) ;
    }
    const real_t rlvol = 1./lvol ;
    $gradv3d_f(X).x = sumx*rlvol ;
    $gradv3d_f(X).y = sumy*rlvol ;
    $gradv3d_f(X).z = sumz*rlvol ;
  }
#endif
}
