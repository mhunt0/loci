#include <Loci.h>
$include "FVM.lh"
#include <vector>
using std::vector ;
#include <algorithm>
using std::sort ;
using std::unique ;

namespace Loci {
  $type NGTNodalMax(X) store<real_t> ;
  $type NGTNodalMin(X) store<real_t> ;
  $type X store<real_t> ;
  $type X_f store<real_t> ;

  using std::max ;
  using std::min ;
  using std::cout ;
  
  $rule unit(NGTNodalMax(X)), constraint(pos) {
    $NGTNodalMax(X) = std::numeric_limits<real_t>::min() ;
  }
  $rule apply(face2node->NGTNodalMax(X)<-cl->X)[Loci::Maximum] {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$NGTNodalMax(X),$cl->$X) ;
  }
  $rule apply(face2node->NGTNodalMax(X)<-cr->X)[Loci::Maximum] {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$NGTNodalMax(X),$cr->$X) ;
  }
  $rule apply(face2node->NGTNodalMax(X)<-X_f)[Loci::Maximum],constraint(ci->X) {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$NGTNodalMax(X),$X_f) ;
  }

  $rule unit(NGTNodalMin(X)), constraint(pos) {
    $NGTNodalMin(X) = std::numeric_limits<real_t>::max() ;
  }
  $rule apply(face2node->NGTNodalMin(X)<-cl->X)[Loci::Minimum] {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$NGTNodalMin(X),$cl->$X) ;
  }
  $rule apply(face2node->NGTNodalMin(X)<-cr->X)[Loci::Minimum] {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$NGTNodalMin(X),$cr->$X) ;
  }
  $rule apply(face2node->NGTNodalMin(X)<-X_f)[Loci::Minimum],constraint(ci->X) {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$NGTNodalMin(X),$X_f) ;
  }

  $type NGTNodalv3dMax(X) store<vector3d<real_t> > ;
  $type NGTNodalv3dMin(X) store<vector3d<real_t> > ;
  $type X store<vector3d<real_t> > ;
  $type X_f store<vector3d<real_t> > ;

  inline vector3d<real_t> max(const vector3d<real_t> &v1,
                              const vector3d<real_t> &v2) {
    return vector3d<real_t>(std::max(v1.x,v2.x),
                            std::max(v1.y,v2.y),
                            std::max(v1.z,v2.z)) ;
  }

  inline vector3d<real_t> min(const vector3d<real_t> &v1,
                              const vector3d<real_t> &v2) {
    return vector3d<real_t>(std::min(v1.x,v2.x),
                            std::min(v1.y,v2.y),
                            std::min(v1.z,v2.z)) ;
  }
  

  $rule unit(NGTNodalv3dMax(X)), constraint(pos) {
    const real_t mn = std::numeric_limits<real_t>::min() ;
    $NGTNodalv3dMax(X) = vector3d<real_t>(mn,mn,mn) ;
  }
  $rule apply(face2node->NGTNodalv3dMax(X)<-cl->X)[Loci::Maximum] {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$NGTNodalv3dMax(X),$cl->$X) ;
  }
  $rule apply(face2node->NGTNodalv3dMax(X)<-cr->X)[Loci::Maximum] {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$NGTNodalv3dMax(X),$cr->$X) ;
  }
  $rule apply(face2node->NGTNodalv3dMax(X)<-X_f)[Loci::Maximum],constraint(ci->X) {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$NGTNodalv3dMax(X),$X_f) ;
  }

  $rule unit(NGTNodalv3dMin(X)), constraint(pos) {
    const real_t mx = std::numeric_limits<real_t>::max() ;
    $NGTNodalv3dMin(X) = vector3d<real_t>(mx,mx,mx) ;
  }
  $rule apply(face2node->NGTNodalv3dMin(X)<-cl->X)[Loci::Minimum] {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$NGTNodalv3dMin(X),$cl->$X) ;
  }
  $rule apply(face2node->NGTNodalv3dMin(X)<-cr->X)[Loci::Minimum] {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$NGTNodalv3dMin(X),$cr->$X) ;
  }
  $rule apply(face2node->NGTNodalv3dMin(X)<-X_f)[Loci::Minimum],constraint(ci->X) {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$NGTNodalv3dMin(X),$X_f) ;
  }



  $type NGTNodalvMax(X) storeVec<real_t> ;
  $type NGTNodalvMin(X) storeVec<real_t> ;
  $type X storeVec<real_t> ;
  $type X_f storeVec<real_t> ;
  $type vecSize(X) param<int> ;


  $rule unit(NGTNodalvMax(X)<-vecSize(X)), constraint(pos), prelude {
    $NGTNodalvMax(X).setVecSize(*$vecSize(X)) ;
  } compute {
    $NGTNodalvMax(X) = mk_Scalar(std::numeric_limits<real_t>::min()) ;
  }
  $rule apply(face2node->NGTNodalvMax(X)<-cl->X)[Loci::Maximum] {
    const int sz = $face2node.size() ;
    for(int i=0;i<sz;++i)
      join($face2node[i]->$NGTNodalvMax(X),$cl->$X) ;
  }
  $rule apply(face2node->NGTNodalvMax(X)<-cr->X)[Loci::Maximum] {
    const int sz = $face2node.size() ;
    for(int i=0;i<sz;++i)
      join($face2node[i]->$NGTNodalvMax(X),$cr->$X) ;
  }
  $rule apply(face2node->NGTNodalvMax(X)<-X_f)[Loci::Maximum],
    constraint(ci->X) {
    const int sz = $face2node.size() ;
    for(int i=0;i<sz;++i)
      join($face2node[i]->$NGTNodalvMax(X),$X_f) ;
  }

  $rule unit(NGTNodalvMin(X)<-vecSize(X)), constraint(pos), prelude {
    $NGTNodalvMin(X).setVecSize(*$vecSize(X)) ;
  } compute {
    $NGTNodalvMin(X) = mk_Scalar(std::numeric_limits<real_t>::max()) ;
  }
  $rule apply(face2node->NGTNodalvMin(X)<-cl->X)[Loci::Minimum] {
    const int sz = $face2node.size() ;
    for(int i=0;i<sz;++i)
      join($face2node[i]->$NGTNodalvMin(X),$cl->$X) ;
  }
  $rule apply(face2node->NGTNodalvMin(X)<-cr->X)[Loci::Minimum] {
    const int sz = $face2node.size() ;
    for(int i=0;i<sz;++i)
      join($face2node[i]->$NGTNodalvMin(X),$cr->$X) ;
  }
  $rule apply(face2node->NGTNodalvMin(X)<-X_f)[Loci::Minimum],
    constraint(ci->X) {
    const int sz = $face2node.size() ;
    for(int i=0;i<sz;++i)
      join($face2node[i]->$NGTNodalvMin(X),$X_f) ;
  }

  // Now code to compute nodal values

  $type NGT_nodal_weights store<real_t> ;

  $rule unit(NGT_nodal_weights), constraint(pos) {
    $NGT_nodal_weights = 0 ;
  }

  $rule apply((upper,lower,boundary_map)->face2node->NGT_nodal_weights<-(upper,lower,boundary_map)->face2node->NGT_nodal_weights,cellcenter,(upper,lower,boundary_map)->face2node->pos)[Loci::Summation],constraint(geom_cells) {
    int sztot = 0 ;
    
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      sztot += fi->$face2node.size() ;

    vector<Entity> node_list(sztot) ;
    int cnt = 0 ;
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    
    sort(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ne = unique(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ns = node_list.begin() ;
    for(vector<Entity>::iterator vi = ns;vi!=ne;++vi) {
      const real_t weight = 1./norm(vi->$pos-$cellcenter) ;
      join(vi->$NGT_nodal_weights,weight) ;
    }
  }

  $type NGTLimiting param<std::string> ;

  $rule default(NGTLimiting),
    comments("use nodal extent limiting on the NGT based gradient.  Option is 'yes', 'no'")
  {
    $NGTLimiting = "yes" ;
  }

  $type NGTLimitingOn Constraint ;
  $type NGTLimitingOff Constraint ;
  $type frinkNodalMethod Constraint ;

  $rule constraint(frinkNodalMethod,NGTLimitingOn,NGTLimitingOff<-NGTLimiting) {
    $frinkNodalMethod = EMPTY ;
    $NGTLimitingOn = EMPTY ;
    $NGTLimitingOff = EMPTY ;
    if($NGTLimiting == "yes") {
      $NGTLimitingOn = $*NGTLimiting.domain() ;
    } else if($NGTLimiting == "no") {
      $NGTLimitingOff = $*NGTLimiting.domain() ;
    } else if($NGTLimiting == "frink") {
      $frinkNodalMethod = $*NGTLimiting.domain() ;
    } else {
      if(Loci::MPI_rank == 0) {
        cerr << "NGTLimiting must be 'yes', 'no', or 'frink'" << endl ;
      }
      $NGTLimitingOff = $*NGTLimiting.domain() ;
    }
  }

  $type NGTViscous param<std::string> ;

  $rule default(NGTViscous),
                comments("Use nodal green's theorem for viscous face gradients? 'yes' or 'no' setting.") {
    $NGTViscous = "yes" ;
  }

  $type UseNGTViscous Constraint ;

  $rule constraint(UseNGTViscous<-NGTViscous) {
    $UseNGTViscous = EMPTY ;
    if($NGTViscous == "yes") {
      $UseNGTViscous = $*NGTViscous.domain() ;
    } 
  }

  
  $type Wf_l store<vector3d<real_t> > ;
  $type Wf_r store<vector3d<real_t> > ;

  $type NGTNodal(X) store<real_t> ;
  $type X store<real_t> ;
  $type X_f store<real_t> ;

  
  $rule unit(NGTNodal(X)),constraint(pos) {
    $NGTNodal(X) = 0 ;
  }

  $rule apply((upper,lower,boundary_map)->face2node->NGTNodal(X)<-
              (upper,lower,boundary_map)->face2node->NGT_nodal_weights,
              cellcenter,(upper,lower,boundary_map)->face2node->pos,
              (upper,lower,boundary_map)->face2node->NGTNodalMax(X),
              (upper,lower,boundary_map)->face2node->NGTNodalMin(X),
              lower->Wf_r,(upper,boundary_map)->Wf_l,
              X,lower->cl->X,upper->cr->X,boundary_map->X_f
              )[Loci::Summation],constraint(geom_cells,NGTLimitingOn) {
    int sztot = 0 ;
    
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      sztot += fi->$face2node.size() ;

    vector<Entity> node_list(sztot) ;
    int cnt = 0 ;
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    
    sort(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ne = unique(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ns = node_list.begin() ;

    // Now compute gradient

    vector3d<real_t> gradx = vector3d<real_t>(0,0,0) ;
    real_t X_center = $X ;
    for(const int *li = $lower.begin();li!=$lower.end();++li) {
      real_t df = li->$cl->$X - X_center ;
      gradx += df*li->$Wf_r ;
    }
    for(const int *ui = $upper.begin();ui!=$upper.end();++ui) {
      real_t df = ui->$cr->$X - X_center ;
      gradx += df*ui->$Wf_l ;
    }
    for(const int *bi = $boundary_map.begin();bi!=$boundary_map.end(); ++bi) {
      real_t df = bi->$X_f - X_center ;
      gradx += df*bi->$Wf_l ;
    }

    // grads[cc] = Qt_b ; 

    // compute weighted sum of node extrapolations
    for(vector<Entity>::iterator vi = ns;vi!=ne;++vi) {
      const vector3d<real_t> dv = (vi->$pos-$cellcenter) ;
      real_t x_p = $X + dot(gradx,dv) ;

      // Limit extrapolation
      x_p = min(x_p,vi->$NGTNodalMax(X)) ;
      x_p = max(x_p,vi->$NGTNodalMin(X)) ;
      // Compute weighted contribution to node
      const real_t x_contrib = x_p/(norm(dv)*vi->$NGT_nodal_weights) ;
      join(vi->$NGTNodal(X),x_contrib) ;
    }
  }

  $rule apply((upper,lower,boundary_map)->face2node->NGTNodal(X)<-
              (upper,lower,boundary_map)->face2node->NGT_nodal_weights,
              cellcenter,(upper,lower,boundary_map)->face2node->pos,
              lower->Wf_r,(upper,boundary_map)->Wf_l,
              X,lower->cl->X,upper->cr->X,boundary_map->X_f
              )[Loci::Summation],constraint(geom_cells,NGTLimitingOff) {
    int sztot = 0 ;
    
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      sztot += fi->$face2node.size() ;

    vector<Entity> node_list(sztot) ;
    int cnt = 0 ;
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    
    sort(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ne = unique(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ns = node_list.begin() ;

    // Now compute gradient

    vector3d<real_t> gradx = vector3d<real_t>(0,0,0) ;
    real_t X_center = $X ;
    for(const int *li = $lower.begin();li!=$lower.end();++li) {
      real_t df = li->$cl->$X - X_center ;
      gradx += df*li->$Wf_r ;
    }
    for(const int *ui = $upper.begin();ui!=$upper.end();++ui) {
      real_t df = ui->$cr->$X - X_center ;
      gradx += df*ui->$Wf_l ;
    }
    for(const int *bi = $boundary_map.begin();bi!=$boundary_map.end(); ++bi) {
      real_t df = bi->$X_f - X_center ;
      gradx += df*bi->$Wf_l ;
    }

    // grads[cc] = Qt_b ; 

    // compute weighted sum of node extrapolations
    for(vector<Entity>::iterator vi = ns;vi!=ne;++vi) {
      const vector3d<real_t> dv = (vi->$pos-$cellcenter) ;
      real_t x_p = $X + dot(gradx,dv) ;

      // Compute weighted contribution to node
      const real_t x_contrib = x_p/(norm(dv)*vi->$NGT_nodal_weights) ;
      join(vi->$NGTNodal(X),x_contrib) ;
    }
  }

  $rule apply((upper,lower,boundary_map)->face2node->NGTNodal(X)<-
              (upper,lower,boundary_map)->face2node->NGT_nodal_weights,
              cellcenter,(upper,lower,boundary_map)->face2node->pos,
              X,boundary_map->X_f)[Loci::Summation],constraint(geom_cells,frinkNodalMethod) {
    entitySet node_set,bnode_set ;

    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_set += *ni ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_set += *ni ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        bnode_set += *ni ;

    node_set -= bnode_set ;
    
    for(entitySet::const_iterator vi = node_set.begin();vi!=node_set.end();++vi) {
      const vector3d<real_t> dv = (vi->$pos-$cellcenter) ;
      real_t x_p = $X  ;

      // Compute weighted contribution to node
      const real_t x_contrib = x_p/(norm(dv)*vi->$NGT_nodal_weights) ;
      join(vi->$NGTNodal(X),x_contrib) ;
    }
    real_t Xf = 0 ;
    if($boundary_map.size() != 0) {
      for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi)
        Xf+= fi->$X_f ;
      Xf /= real_t($boundary_map.size()) ;

      for(entitySet::const_iterator vi = bnode_set.begin();
          vi!=bnode_set.end();++vi) {
        const vector3d<real_t> dv = (vi->$pos-$cellcenter) ;
        real_t x_p = Xf  ;
        
        // Compute weighted contribution to node
        const real_t x_contrib = x_p/(norm(dv)*vi->$NGT_nodal_weights) ;
        join(vi->$NGTNodal(X),x_contrib) ;
      }
    }
  }

  $type NGTNodalv3d(X) store<vector3d<real_t> > ;

  $type X store<vector3d<real_t> > ;
  $type X_f store<vector3d<real_t> > ;

  
  $rule unit(NGTNodalv3d(X)),constraint(pos) {
    $NGTNodalv3d(X) = vector3d<real_t>(0,0,0) ;
  }

  $rule apply((upper,lower,boundary_map)->face2node->NGTNodalv3d(X)<-
              (upper,lower,boundary_map)->face2node->NGT_nodal_weights,
              cellcenter,(upper,lower,boundary_map)->face2node->pos,
              (upper,lower,boundary_map)->face2node->NGTNodalv3dMax(X),
              (upper,lower,boundary_map)->face2node->NGTNodalv3dMin(X),
              lower->Wf_r,(upper,boundary_map)->Wf_l,
              X,lower->cl->X,upper->cr->X,boundary_map->X_f
              )[Loci::Summation],constraint(geom_cells,NGTLimitingOn) {
    int sztot = 0 ;
    
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      sztot += fi->$face2node.size() ;

    vector<Entity> node_list(sztot) ;
    int cnt = 0 ;
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    
    sort(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ne = unique(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ns = node_list.begin() ;

    // Now compute gradient

    const vector3d<real_t> X_center = $X ;
    tensor3d<real_t>  gradx = tensor3d<real_t> (vector3d<real_t>(0,0,0),vector3d<real_t>(0,0,0),vector3d<real_t>(0,0,0)) ;
    for(const int *li = $lower.begin();li!=$lower.end();++li) {
      vector3d<real_t> df = li->$cl->$X - X_center ;
      gradx.x += df.x*li->$Wf_r ;
      gradx.y += df.y*li->$Wf_r ;
      gradx.z += df.z*li->$Wf_r ;
    }
    for(const int *ui = $upper.begin();ui!=$upper.end();++ui) {
      vector3d<real_t> df = ui->$cr->$X - X_center ;
      gradx.x += df.x*ui->$Wf_l ;
      gradx.y += df.y*ui->$Wf_l ;
      gradx.z += df.z*ui->$Wf_l ;
    }
    for(const int *bi = $boundary_map.begin();bi!=$boundary_map.end(); ++bi) {
      vector3d<real_t> df = bi->$X_f - X_center ;
      gradx.x += df.x*bi->$Wf_l ;
      gradx.y += df.y*bi->$Wf_l ;
      gradx.z += df.z*bi->$Wf_l ;
    }

    // compute weighted sum of node extrapolations
    for(vector<Entity>::iterator vi = ns;vi!=ne;++vi) {
      const vector3d<real_t> dv = (vi->$pos-$cellcenter) ;
      vector3d<real_t> x_p = $X + dot(gradx,dv) ;

      // Limit extrapolation
      x_p = min(x_p,vi->$NGTNodalv3dMax(X)) ;
      x_p = max(x_p,vi->$NGTNodalv3dMin(X)) ;
      
      // Compute weighted contribution to node
      const vector3d<real_t> x_contrib = x_p/(norm(dv)*vi->$NGT_nodal_weights) ;
      join(vi->$NGTNodalv3d(X),x_contrib) ;
    }
  }

  $rule apply((upper,lower,boundary_map)->face2node->NGTNodalv3d(X)<-
              (upper,lower,boundary_map)->face2node->NGT_nodal_weights,
              cellcenter,(upper,lower,boundary_map)->face2node->pos,
              lower->Wf_r,(upper,boundary_map)->Wf_l,
              X,lower->cl->X,upper->cr->X,boundary_map->X_f
              )[Loci::Summation],constraint(geom_cells,NGTLimitingOff) {
    int sztot = 0 ;
    
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      sztot += fi->$face2node.size() ;

    vector<Entity> node_list(sztot) ;
    int cnt = 0 ;
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    
    sort(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ne = unique(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ns = node_list.begin() ;

    // Now compute gradient

    const vector3d<real_t> X_center = $X ;
    tensor3d<real_t>  gradx = tensor3d<real_t> (vector3d<real_t>(0,0,0),vector3d<real_t>(0,0,0),vector3d<real_t>(0,0,0)) ;
    for(const int *li = $lower.begin();li!=$lower.end();++li) {
      vector3d<real_t> df = li->$cl->$X - X_center ;
      gradx.x += df.x*li->$Wf_r ;
      gradx.y += df.y*li->$Wf_r ;
      gradx.z += df.z*li->$Wf_r ;
    }
    for(const int *ui = $upper.begin();ui!=$upper.end();++ui) {
      vector3d<real_t> df = ui->$cr->$X - X_center ;
      gradx.x += df.x*ui->$Wf_l ;
      gradx.y += df.y*ui->$Wf_l ;
      gradx.z += df.z*ui->$Wf_l ;
    }
    for(const int *bi = $boundary_map.begin();bi!=$boundary_map.end(); ++bi) {
      vector3d<real_t> df = bi->$X_f - X_center ;
      gradx.x += df.x*bi->$Wf_l ;
      gradx.y += df.y*bi->$Wf_l ;
      gradx.z += df.z*bi->$Wf_l ;
    }

    // compute weighted sum of node extrapolations
    for(vector<Entity>::iterator vi = ns;vi!=ne;++vi) {
      const vector3d<real_t> dv = (vi->$pos-$cellcenter) ;
      vector3d<real_t> x_p = $X + dot(gradx,dv) ;

      // Compute weighted contribution to node
      const vector3d<real_t> x_contrib = x_p/(norm(dv)*vi->$NGT_nodal_weights) ;
      join(vi->$NGTNodalv3d(X),x_contrib) ;
    }
  }

  $rule apply((upper,lower,boundary_map)->face2node->NGTNodalv3d(X)<-
              (upper,lower,boundary_map)->face2node->NGT_nodal_weights,
              cellcenter,(upper,lower,boundary_map)->face2node->pos,
              X,boundary_map->X_f)[Loci::Summation],constraint(geom_cells,frinkNodalMethod) {
    entitySet node_set,bnode_set ;

    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_set += *ni ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_set += *ni ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        bnode_set += *ni ;

    node_set -= bnode_set ;
    


    
    for(entitySet::const_iterator vi = node_set.begin();vi!=node_set.end();++vi) {
      const vector3d<real_t> dv = (vi->$pos-$cellcenter) ;
      vector3d<real_t> x_p = $X ;

      // Compute weighted contribution to node
      const vector3d<real_t> x_contrib = x_p/(norm(dv)*vi->$NGT_nodal_weights) ;
      join(vi->$NGTNodalv3d(X),x_contrib) ;
    }
    vector3d<real_t> Xf = vector3d<real_t>(0,0,0) ;
    if($boundary_map.size() != 0) {
      for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi)
        Xf+= fi->$X_f ;
      Xf /= real_t($boundary_map.size()) ;
      for(entitySet::const_iterator vi = bnode_set.begin();vi!=bnode_set.end();++vi) {
        const vector3d<real_t> dv = (vi->$pos-$cellcenter) ;
        vector3d<real_t> x_p = Xf  ;
        
        // Compute weighted contribution to node
        const vector3d<real_t> x_contrib = x_p/(norm(dv)*vi->$NGT_nodal_weights) ;
        join(vi->$NGTNodalv3d(X),x_contrib) ;
      }
    }

  }
  
  $type NGTNodalv(X) storeVec<real_t> ;
  $type X storeVec<real_t> ;
  $type X_f storeVec<real_t> ;

  
  $rule unit(NGTNodalv(X)<-vecSize(X)),constraint(pos), prelude {
    $NGTNodalv(X).setVecSize(*$vecSize(X)) ;
  } compute {
    $NGTNodalv(X) = mk_Scalar(0) ;
  }

  $rule apply((upper,lower,boundary_map)->face2node->NGTNodalv(X)<-
              (upper,lower,boundary_map)->face2node->NGT_nodal_weights,
              cellcenter,(upper,lower,boundary_map)->face2node->pos,
              (upper,lower,boundary_map)->face2node->NGTNodalvMax(X),
              (upper,lower,boundary_map)->face2node->NGTNodalvMin(X),
              lower->Wf_r,(upper,boundary_map)->Wf_l,
              X,lower->cl->X,upper->cr->X,boundary_map->X_f
              )[Loci::Summation],constraint(geom_cells,NGTLimitingOn) {
    int sztot = 0 ;
    
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      sztot += fi->$face2node.size() ;

    vector<Entity> node_list(sztot) ;
    int cnt = 0 ;
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    
    sort(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ne = unique(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ns = node_list.begin() ;

    // Now compute gradient
    const int vs = $*NGTNodalv(X).vecSize() ;

    for(int i=0;i<vs;++i) {
      vector3d<real_t> gradx = vector3d<real_t>(0,0,0) ;
      real_t X_center = $X[i] ;
      for(const int *li = $lower.begin();li!=$lower.end();++li) {
        real_t df = li->$cl->$X[i] - X_center ;
        gradx += df*li->$Wf_r ;
      }
      for(const int *ui = $upper.begin();ui!=$upper.end();++ui) {
        real_t df = ui->$cr->$X[i] - X_center ;
        gradx += df*ui->$Wf_l ;
      }
      for(const int *bi = $boundary_map.begin();bi!=$boundary_map.end(); ++bi) {
        real_t df = bi->$X_f[i] - X_center ;
        gradx += df*bi->$Wf_l ;
      }

      // compute weighted sum of node extrapolations
      for(vector<Entity>::iterator vi = ns;vi!=ne;++vi) {
        const vector3d<real_t> dv = (vi->$pos-$cellcenter) ;
        real_t x_p = $X[i] + dot(gradx,dv) ;

        // Limit extrapolation
        x_p = min(x_p,vi->$NGTNodalvMax(X)[i]) ;
        x_p = max(x_p,vi->$NGTNodalvMin(X)[i]) ;

        // Compute weighted contribution to node
        const real_t x_contrib = x_p/(norm(dv)*vi->$NGT_nodal_weights) ;
        vi->$NGTNodalv(X)[i] += x_contrib ;
      }
    }
  }
  $rule apply((upper,lower,boundary_map)->face2node->NGTNodalv(X)<-
              (upper,lower,boundary_map)->face2node->NGT_nodal_weights,
              cellcenter,(upper,lower,boundary_map)->face2node->pos,
              lower->Wf_r,(upper,boundary_map)->Wf_l,
              X,lower->cl->X,upper->cr->X,boundary_map->X_f
              )[Loci::Summation],constraint(geom_cells,NGTLimitingOff) {
    int sztot = 0 ;
    
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      sztot += fi->$face2node.size() ;

    vector<Entity> node_list(sztot) ;
    int cnt = 0 ;
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    
    sort(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ne = unique(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ns = node_list.begin() ;

    // Now compute gradient
    const int vs = $*NGTNodalv(X).vecSize() ;

    for(int i=0;i<vs;++i) {
      vector3d<real_t> gradx = vector3d<real_t>(0,0,0) ;
      real_t X_center = $X[i] ;
      for(const int *li = $lower.begin();li!=$lower.end();++li) {
        real_t df = li->$cl->$X[i] - X_center ;
        gradx += df*li->$Wf_r ;
      }
      for(const int *ui = $upper.begin();ui!=$upper.end();++ui) {
        real_t df = ui->$cr->$X[i] - X_center ;
        gradx += df*ui->$Wf_l ;
      }
      for(const int *bi = $boundary_map.begin();bi!=$boundary_map.end(); ++bi) {
        real_t df = bi->$X_f[i] - X_center ;
        gradx += df*bi->$Wf_l ;
      }

      // compute weighted sum of node extrapolations
      for(vector<Entity>::iterator vi = ns;vi!=ne;++vi) {
        const vector3d<real_t> dv = (vi->$pos-$cellcenter) ;
        real_t x_p = $X[i] + dot(gradx,dv) ;

        // Compute weighted contribution to node
        const real_t x_contrib = x_p/(norm(dv)*vi->$NGT_nodal_weights) ;
        vi->$NGTNodalv(X)[i] += x_contrib ;
      }
    }
  }

  $rule apply((upper,lower,boundary_map)->face2node->NGTNodalv(X)<-
              (upper,lower,boundary_map)->face2node->NGT_nodal_weights,
              cellcenter,(upper,lower,boundary_map)->face2node->pos,
              X,boundary_map->X_f)[Loci::Summation],constraint(geom_cells,frinkNodalMethod) {
    entitySet node_set,bnode_set ;

    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_set += *ni ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_set += *ni ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        bnode_set += *ni ;

    node_set -= bnode_set ;
    

    const int vs = $*NGTNodalv(X).vecSize() ;

    for(int i=0;i<vs;++i) {
      for(entitySet::const_iterator vi = node_set.begin();
          vi!=node_set.end();++vi) {
        const vector3d<real_t> dv = (vi->$pos-$cellcenter) ;
        real_t x_p = $X[i]  ;

        // Compute weighted contribution to node
        const real_t x_contrib = x_p/(norm(dv)*vi->$NGT_nodal_weights) ;
        vi->$NGTNodalv(X)[i] += x_contrib ;
      }
      if($boundary_map.size() != 0) {
        real_t Xf = 0 ;
        for(const Entity *fi=$boundary_map.begin();
            fi!=$boundary_map.end();++fi)
          Xf+= fi->$X_f[i] ;
        Xf /= real_t($boundary_map.size()) ;
        for(entitySet::const_iterator vi = bnode_set.begin();
            vi!=bnode_set.end();++vi) {
          const vector3d<real_t> dv = (vi->$pos-$cellcenter) ;
          real_t x_p = Xf  ;

          const real_t x_contrib = x_p/(norm(dv)*vi->$NGT_nodal_weights) ;
          vi->$NGTNodalv(X)[i]+=x_contrib ;
        }
      }
    }
  }

  // Second order area integration
  $type NGTIntegrate(X) store<real_t> ;
  $type X store<real_t> ;
  
  $rule pointwise(NGTIntegrate(X)<-area,facecenter,face2node->pos,face2node->NGTNodal(X)) {
    const int sz = $face2node.size() ;
    const vector3d<real_t> center = $facecenter ;

    // We will use the Laplacian to compute a second order accurate
    // value for the face centroid from nodal values
    // We project the face coordinates into a two dimensional plane
    // with the same normal as the face.
    
    // First compute local coordinate system
    vector3d<real_t> n = $area.n ;
    vector3d<real_t> v1 = $face2node[0]->$pos-center ;
    vector3d<real_t> v2 = $face2node[1]->$pos-$face2node[0]->$pos ;
    v1 = v1-n*dot(v1,n) ;
    v1 = v1/norm(v1) ;
    v2 = v2-n*dot(v2,n) ;
    v2 = v2-v1*dot(v1,v2) ;
    v2 = v2/norm(v2) ;
    // v1 and v2 are the face coordinate unit vectors

    // Now we solve an optimation problem whereby we minimize the variance
    // of the weights
    real_t Rx = 0 ;
    real_t Ry = 0 ;
    real_t Ixx = 0 ;
    real_t Ixy = 0 ;
    real_t Iyy = 0 ;
    
    // v1 and v2 are orthogonal face coordinate normal vectors
    for(int i=0;i<sz;++i) {
      const vector3d<real_t> dv = $face2node[i]->$pos-center ;
      const real_t xl = dot(dv,v1) ;
      const real_t yl = dot(dv,v2) ;
      Rx += xl ;
      Ry += yl ;
      Ixx += xl*xl ;
      Ixy += xl*yl ;
      Iyy += yl*yl ;
    }
    const real_t rcoef = 1./(Ixx*Iyy-Ixy*Ixy) ;
    const real_t lambdax = (Ixy*Ry-Iyy*Rx)*rcoef ;
    const real_t lambday = (Ixy*Rx-Ixx*Ry)*rcoef ;

    //Now we compute the weighted sums for the interpolation value
    real_t Xc = 0 ;
    real_t w_tot = 0 ;
    for(int i=0;i<sz;++i) {
      const vector3d<real_t> dv = $face2node[i]->$pos-center ;
      const real_t xl = dot(dv,v1) ;
      const real_t yl = dot(dv,v2) ;
      const real_t dw = lambdax*xl+lambday*yl ;
      const real_t w = (1.+dw) ;
      w_tot += w ;
      warn(w<0.0) ;
      Xc += w*$face2node[i]->$NGTNodal(X) ;
    }
    $NGTIntegrate(X) = Xc/w_tot ;
    
  }
  
  $type NGTIntegratev(X) storeVec<real_t> ;
  $type X storeVec<real_t> ;
  
  $rule pointwise(NGTIntegratev(X)<-area,facecenter,face2node->pos,face2node->NGTNodalv(X)), prelude {
    $NGTIntegratev(X).setVecSize($NGTNodalv(X).vecSize()) ;
  } compute {
    const int sz = $face2node.size() ;
    const vector3d<real_t> center = $facecenter ;

    // We will use the Laplacian to compute a second order accurate
    // value for the face centroid from nodal values
    // We project the face coordinates into a two dimensional plane
    // with the same normal as the face.
    
    // First compute local coordinate system
    vector3d<real_t> n = $area.n ;
    vector3d<real_t> v1 = $face2node[0]->$pos-center ;
    vector3d<real_t> v2 = $face2node[1]->$pos-$face2node[0]->$pos ;
    v1 = v1-n*dot(v1,n) ;
    v1 = v1/norm(v1) ;
    v2 = v2-n*dot(v2,n) ;
    v2 = v2-v1*dot(v1,v2) ;
    v2 = v2/norm(v2) ;
    // v1 and v2 are the face coordinate unit vectors

    // Now we solve an optimation problem whereby we minimize the variance
    // of the weights
    real_t Rx = 0 ;
    real_t Ry = 0 ;
    real_t Ixx = 0 ;
    real_t Ixy = 0 ;
    real_t Iyy = 0 ;
    
    // v1 and v2 are orthogonal face coordinate normal vectors
    for(int i=0;i<sz;++i) {
      const vector3d<real_t> dv = $face2node[i]->$pos-center ;
      const real_t xl = dot(dv,v1) ;
      const real_t yl = dot(dv,v2) ;
      Rx += xl ;
      Ry += yl ;
      Ixx += xl*xl ;
      Ixy += xl*yl ;
      Iyy += yl*yl ;
    }
    const real_t rcoef = 1./(Ixx*Iyy-Ixy*Ixy) ;
    const real_t lambdax = (Ixy*Ry-Iyy*Rx)*rcoef ;
    const real_t lambday = (Ixy*Rx-Ixx*Ry)*rcoef ;

    //Now we compute the weighted sums for the interpolation value

    const int nv = $*NGTNodalv(X).vecSize() ;
    for(int j=0;j<nv;++j)
      $NGTIntegratev(X)[j] = 0 ;
    real_t w_tot = 0 ;
    for(int i=0;i<sz;++i) {
      const vector3d<real_t> dv = $face2node[i]->$pos-center ;
      const real_t xl = dot(dv,v1) ;
      const real_t yl = dot(dv,v2) ;
      
      const real_t dw = lambdax*xl+lambday*yl ;
      const real_t w = (1.+dw) ;
      w_tot += w ;
      warn(w<0.0) ;
      for(int j=0;j<nv;++j)
        $NGTIntegratev(X)[j] += w*$face2node[i]->$NGTNodalv(X)[j] ;
    }
    for(int j=0;j<nv;++j)
      $NGTIntegratev(X)[j] *= 1./w_tot ;

  }

  $type NGTIntegratev3d(X) store<vector3d<real_t> > ;
  $type X store<vector3d<real_t> > ;
  
  $rule pointwise(NGTIntegratev3d(X)<-area,facecenter,face2node->pos,face2node->NGTNodalv3d(X)) {
    const int sz = $face2node.size() ;
    const vector3d<real_t> center = $facecenter ;

    // We will use the Laplacian to compute a second order accurate
    // value for the face centroid from nodal values
    // We project the face coordinates into a two dimensional plane
    // with the same normal as the face.
    
    // First compute local coordinate system
    vector3d<real_t> n = $area.n ;
    vector3d<real_t> v1 = $face2node[0]->$pos-center ;
    vector3d<real_t> v2 = $face2node[1]->$pos-$face2node[0]->$pos ;
    v1 = v1-n*dot(v1,n) ;
    v1 = v1/norm(v1) ;
    v2 = v2-n*dot(v2,n) ;
    v2 = v2-v1*dot(v1,v2) ;
    v2 = v2/norm(v2) ;
    // v1 and v2 are the face coordinate unit vectors

    // Now we solve an optimation problem whereby we minimize the variance
    // of the weights
    real_t Rx = 0 ;
    real_t Ry = 0 ;
    real_t Ixx = 0 ;
    real_t Ixy = 0 ;
    real_t Iyy = 0 ;
    
    // v1 and v2 are orthogonal face coordinate normal vectors
    for(int i=0;i<sz;++i) {
      const vector3d<real_t> dv = $face2node[i]->$pos-center ;
      const real_t xl = dot(dv,v1) ;
      const real_t yl = dot(dv,v2) ;
      Rx += xl ;
      Ry += yl ;
      Ixx += xl*xl ;
      Ixy += xl*yl ;
      Iyy += yl*yl ;
    }
    const real_t rcoef = 1./(Ixx*Iyy-Ixy*Ixy) ;
    const real_t lambdax = (Ixy*Ry-Iyy*Rx)*rcoef ;
    const real_t lambday = (Ixy*Rx-Ixx*Ry)*rcoef ;

    //Now we compute the weighted sums for the interpolation value
    vector3d<real_t> Xc = vector3d<real_t>(0,0,0) ;
    real_t w_tot = 0 ;
    for(int i=0;i<sz;++i) {
      const vector3d<real_t> dv = $face2node[i]->$pos-center ;
      const real_t xl = dot(dv,v1) ;
      const real_t yl = dot(dv,v2) ;
      const real_t dw = lambdax*xl+lambday*yl ;
      const real_t w = (1.+dw) ;
      w_tot += w ;
      warn(w<0.0) ;
      Xc += w*$face2node[i]->$NGTNodalv3d(X) ;
    }
    $NGTIntegratev3d(X) = Xc/w_tot ;
  }

  $type X storeVec<real_t> ;
  $type X_f storeVec<real_t> ;
  
  
  $rule pointwise(gradv(X)<-(lower,upper)->(area,NGTIntegratev(X)),
                  boundary_map->(X_f,area),vol),
    constraint(geom_cells,NGTGradient), prelude {
    $gradv(X).setVecSize($NGTIntegratev(X).vecSize()) ;
  } compute {
    const real_t rvol = 1./$vol ;
    const int vs = $*NGTIntegratev(X).vecSize() ;
    for(int i=0;i<vs;++i) {
      vector3d<real_t> gradsum = vector3d<real_t>(0.0,0.0,0.0);
      for(const Entity *li = $lower.begin();li!=$lower.end();++li) {
        const real_t xf = li->$NGTIntegratev(X)[i] ;
        gradsum -= xf*li->$area.sada*li->$area.n ;
      }
      for(const Entity *ui = $upper.begin();ui!=$upper.end();++ui) {
        const real_t xf = ui->$NGTIntegratev(X)[i] ;
         gradsum += xf*ui->$area.sada*ui->$area.n ;
      }
      for(const Entity *bi = $boundary_map.begin();bi!=$boundary_map.end();
          ++bi) {
        gradsum += bi->$X_f[i]*bi->$area.sada*bi->$area.n ;
      }

       $gradv(X)[i] = gradsum*rvol  ; 
    }
  }

  $type X store<real_t> ;
  $type X_f store<real_t> ;

  $rule pointwise(grads(X)<-(lower,upper)->(area,NGTIntegrate(X)),boundary_map->(X_f,area,NGTIntegrate(X)),vol),
    constraint(geom_cells,NGTGradient) {
    const real_t rvol = 1./$vol ;
    vector3d<real_t> gradsum = vector3d<real_t>(0.0,0.0,0.0);
    for(const Entity *li = $lower.begin();li!=$lower.end();++li) {
      const real_t xf = li->$NGTIntegrate(X) ;
      gradsum -= xf*li->$area.sada*li->$area.n ;
    }
    for(const Entity *ui = $upper.begin();ui!=$upper.end();++ui) {
      const real_t xf = ui->$NGTIntegrate(X) ;
      gradsum += xf*ui->$area.sada*ui->$area.n ;
    }
    for(const Entity *bi = $boundary_map.begin();bi!=$boundary_map.end();
        ++bi) {
      gradsum += bi->$X_f*bi->$area.sada*bi->$area.n ;
    }
    
    $grads(X)= gradsum*rvol  ; 
  }


  $type X store<vector3d<real_t> > ;
  $type X_f store<vector3d<real_t> > ;
  
  $rule pointwise(gradv3d(X)<-(lower,upper)->(NGTIntegratev3d(X),area),boundary_map->(X_f,area),vol),
    constraint(geom_cells,NGTGradient) {
    tensor3d<real_t>  gradsum = tensor3d<real_t> (vector3d<real_t>(0,0,0),vector3d<real_t>(0,0,0),vector3d<real_t>(0,0,0)) ;
    const real_t rvol = 1./$vol ;
    
    for(const Entity *li = $lower.begin();li!=$lower.end();++li) {
      const vector3d<real_t> xf = li->$NGTIntegratev3d(X) ;
      gradsum.x -= xf.x*li->$area.sada*li->$area.n ;
      gradsum.y -= xf.y*li->$area.sada*li->$area.n ;
      gradsum.z -= xf.z*li->$area.sada*li->$area.n ;
    }
    for(const Entity *ui = $upper.begin();ui!=$upper.end();++ui) {
      const vector3d<real_t> xf = ui->$NGTIntegratev3d(X) ;
      gradsum.x += xf.x*ui->$area.sada*ui->$area.n ;
      gradsum.y += xf.y*ui->$area.sada*ui->$area.n ;
      gradsum.z += xf.z*ui->$area.sada*ui->$area.n ;
    }
    for(const Entity *bi = $boundary_map.begin();bi!=$boundary_map.end();
        ++bi) {
      gradsum.x += bi->$X_f.x*bi->$area.sada*bi->$area.n ;
      gradsum.y += bi->$X_f.y*bi->$area.sada*bi->$area.n ;
      gradsum.z += bi->$X_f.z*bi->$area.sada*bi->$area.n ;
    }

    $gradv3d(X).x = gradsum.x*rvol  ; 
    $gradv3d(X).y = gradsum.y*rvol  ; 
    $gradv3d(X).z = gradsum.z*rvol  ; 
  }

  // NGT face gradients:
  $type X store<real_t> ;
  $type X_f store<real_t> ;


  // Compute extrema sensor

  $type extremaBeta(X) store<real_t> ;
  $type X store<real_t> ;

  $rule pointwise(extremaBeta(X)<-lower->cl->X,upper->cr->X,boundary_map->X_f,X) {
    real_t Xmax = std::numeric_limits<real_t>::min() ;
    real_t Xmin = std::numeric_limits<real_t>::max() ;
    const size_t supper = $upper.size() ;
    const size_t slower = $lower.size() ;
    //    const size_t sbmap = $boundary_map.size() ;
    for(size_t i=0;i<supper;++i) {
      Xmax = max(Xmax,$upper[i]->$cr->$X) ;
      Xmin = min(Xmin,$upper[i]->$cr->$X) ;
    } 
    for(size_t i=0;i<slower;++i) {
      Xmax = max(Xmax,$lower[i]->$cl->$X) ;
      Xmin = min(Xmin,$lower[i]->$cl->$X) ;
    }
    //    for(size_t i=0;i<sbmap;++i) {
      //      Xmax = max(Xmax,$boundary_map[i]->$X_f) ;
      //      Xmin = min(Xmin,$boundary_map[i]->$X_f) ;
    //    }   
    real_t Beta = 1.0 ;
    if($X > Xmax) {
      Beta = (Xmax-Xmin)/($X-Xmin) ;
    } else if ($X < Xmin) {
      Beta = (Xmax-Xmin)/(Xmax-$X) ;
    }
    $extremaBeta(X) = Beta ;
  }

  // NGT face gradients:
  $type X store<real_t> ;
  $type X_f store<real_t> ;

  $rule pointwise(NGT::grads_f(X)<-(cl,cr)->(X,cellcenter,extremaBeta(X)),
                  face2node->(NGTNodal(X),pos),area),
    constraint(NGTGradient,UseNGTViscous,(cl,cr)->cellcenter) {
    const int sz = $face2node.size() ;
    const vector3d<real_t> center_l = $cl->$cellcenter ;
    const vector3d<real_t> center_r = $cr->$cellcenter ;
    vector3d<real_t> sum = vector3d<real_t>(0,0,0) ;
    real_t lvol = 0 ;

    for(int i=0;i<sz;++i) {
      int n1 = i ;
      int n2 = (i+1)%sz ;
      const real_t X1 = $face2node[n1]->$NGTNodal(X) ;
      const real_t X2 = $face2node[n1]->$NGTNodal(X) ;
      // 2*dot(A,n)
      const vector3d<real_t> v1l = $face2node[n1]->$pos-center_l ;
      const vector3d<real_t> v2l = $face2node[n2]->$pos-center_l ;
      sum -= ($cl->$X+X1+X2)*cross(v1l,v2l) ;
      const vector3d<real_t> v1r = $face2node[n1]->$pos-center_r ;
      const vector3d<real_t> v2r = $face2node[n2]->$pos-center_r ;
      const vector3d<real_t> crossr = cross(v1r,v2r) ;
      sum += ($cr->$X+X1+X2)*crossr ;
      lvol += dot(center_r-center_l,crossr) ;
    }
    $grads_f(X) = sum/lvol ;
    const real_t gdotn = dot($grads_f(X),$area.n) ;
    const real_t gdotn_s = ($cr->$X-$cl->$X)/
      dot($cr->$cellcenter-$cl->$cellcenter,$area.n) ;
    real_t Beta = min($cl->$extremaBeta(X),$cr->$extremaBeta(X)) ;
    real_t Bs = Beta*Beta ;
    $grads_f(X) += $area.n*(1.-Bs)*(gdotn_s-gdotn) ;
  }

  $rule pointwise(NGT::grads_f(X)<-area,ci->(X,cellcenter,extremaBeta(X)),
                  X_f,facecenter, face2node->(NGTNodal(X),pos)),
    constraint(NGTGradient,UseNGTViscous,ci->cellcenter) {
    const int sz = $face2node.size() ;
    const vector3d<real_t> center_l = $ci->$cellcenter ;
    const vector3d<real_t> center_r = $facecenter ;
    vector3d<real_t> sum = vector3d<real_t>(0,0,0) ;
    real_t lvol = 0 ;

    for(int i=0;i<sz;++i) {
      int n1 = i ;
      int n2 = (i+1)%sz ;
      const real_t X1 = $face2node[n1]->$NGTNodal(X) ;
      const real_t X2 = $face2node[n1]->$NGTNodal(X) ;
      // 2*dot(A,n)
      const vector3d<real_t> v1l = $face2node[n1]->$pos-center_l ;
      const vector3d<real_t> v2l = $face2node[n2]->$pos-center_l ;
      sum -= ($ci->$X+X1+X2)*cross(v1l,v2l) ;
      const vector3d<real_t> v1r = $face2node[n1]->$pos-center_r ;
      const vector3d<real_t> v2r = $face2node[n2]->$pos-center_r ;
      const vector3d<real_t> crossr = cross(v1r,v2r) ;
      sum += ($X_f+X1+X2)*crossr ;
      lvol += dot(center_r-center_l,crossr) ;
    }
    $grads_f(X) = sum/lvol ;

    const real_t gdotn = dot($grads_f(X),$area.n) ;
    const real_t gdotn_s = ($X_f-$ci->$X)/
      dot($facecenter-$ci->$cellcenter,$area.n) ;
    real_t Beta = $ci->$extremaBeta(X) ;
    real_t Bs = Beta*Beta ;
    $grads_f(X) += $area.n*(1.-Bs)*(gdotn_s-gdotn) ;
  }

  $type X storeVec<real_t> ;
  $type X_f storeVec<real_t> ;

  $rule pointwise(NGT::gradv_f(X)<-(cl,cr)->(X,cellcenter),
                  face2node->(NGTNodalv(X),pos)),
    constraint(NGTGradient,UseNGTViscous,(cl,cr)->cellcenter),prelude {
    $gradv_f(X).setVecSize($X.vecSize()) ;
  } compute {
    const int vs = $*gradv_f(X).vecSize() ;

    const int sz = $face2node.size() ;
    const vector3d<real_t> center_l = $cl->$cellcenter ;
    const vector3d<real_t> center_r = $cr->$cellcenter ;

    for(int j=0;j<vs;++j) {
      vector3d<real_t> sum = vector3d<real_t>(0,0,0) ;
      real_t lvol = 0 ;

      for(int i=0;i<sz;++i) {
        int n1 = i ;
        int n2 = (i+1)%sz ;
        const real_t X1 = $face2node[n1]->$NGTNodalv(X)[j] ;
        const real_t X2 = $face2node[n1]->$NGTNodalv(X)[j] ;
        // 2*dot(A,n)
        const vector3d<real_t> v1l = $face2node[n1]->$pos-center_l ;
        const vector3d<real_t> v2l = $face2node[n2]->$pos-center_l ;
        sum -= ($cl->$X[j]+X1+X2)*cross(v1l,v2l) ;
        const vector3d<real_t> v1r = $face2node[n1]->$pos-center_r ;
        const vector3d<real_t> v2r = $face2node[n2]->$pos-center_r ;
        const vector3d<real_t> crossr = cross(v1r,v2r) ;
        sum += ($cr->$X[j]+X1+X2)*crossr ;
        lvol += dot(center_r-center_l,crossr) ;
      }
      $gradv_f(X)[j] = sum/lvol ;
    }
  }

  $rule pointwise(NGT::gradv_f(X)<-ci->(X,cellcenter),NGTIntegratev(X),facecenter,
                  face2node->(NGTNodalv(X),pos)),
      constraint(NGTGradient,UseNGTViscous,ci->cellcenter), prelude {
    $gradv_f(X).setVecSize($X.vecSize()) ;
  } compute {
    const int vs = $*X.vecSize() ;
    const int sz = $face2node.size() ;
    const vector3d<real_t> center_l = $ci->$cellcenter ;
    const vector3d<real_t> center_r = $facecenter ;

    for(int j=0;j<vs;++j) {
      vector3d<real_t> sum = vector3d<real_t>(0,0,0) ;
      real_t lvol = 0 ;

      for(int i=0;i<sz;++i) {
        int n1 = i ;
        int n2 = (i+1)%sz ;
        const real_t X1 = $face2node[n1]->$NGTNodalv(X)[j] ;
        const real_t X2 = $face2node[n1]->$NGTNodalv(X)[j] ;
        // 2*dot(A,n)
        const vector3d<real_t> v1l = $face2node[n1]->$pos-center_l ;
        const vector3d<real_t> v2l = $face2node[n2]->$pos-center_l ;
        sum -= ($ci->$X[j]+X1+X2)*cross(v1l,v2l) ;
        const vector3d<real_t> v1r = $face2node[n1]->$pos-center_r ;
        const vector3d<real_t> v2r = $face2node[n2]->$pos-center_r ;
        const vector3d<real_t> crossr = cross(v1r,v2r) ;
        sum += ($NGTIntegratev(X)[j]+X1+X2)*crossr ;
        lvol += dot(center_r-center_l,crossr) ;
      }
      $gradv_f(X)[j] = sum/lvol ;
    }
  }

  $type X store<vector3d<real_t> > ;
  $type X_f store<vector3d<real_t> > ;

  $rule pointwise(NGT::gradv3d_f(X)<-(cl,cr)->(X,cellcenter),
                  face2node->(NGTNodalv3d(X),pos)),
    constraint(NGTGradient,UseNGTViscous,(cl,cr)->cellcenter) {
    const int sz = $face2node.size() ;
    const vector3d<real_t> center_l = $cl->$cellcenter ;
    const vector3d<real_t> center_r = $cr->$cellcenter ;
    vector3d<real_t> sumx = vector3d<real_t>(0,0,0) ;
    vector3d<real_t> sumy = vector3d<real_t>(0,0,0) ;
    vector3d<real_t> sumz = vector3d<real_t>(0,0,0) ;
    real_t lvol = 0 ;

    for(int i=0;i<sz;++i) {
      int n1 = i ;
      int n2 = (i+1)%sz ;
      const vector3d<real_t> X1 = $face2node[n1]->$NGTNodalv3d(X) ;
      const vector3d<real_t> X2 = $face2node[n1]->$NGTNodalv3d(X) ;
      // 2*dot(A,n)
      const vector3d<real_t> v1l = $face2node[n1]->$pos-center_l ;
      const vector3d<real_t> v2l = $face2node[n2]->$pos-center_l ;
      const vector3d<real_t> crossl = cross(v1l,v2l) ;
      sumx -= ($cl->$X.x+X1.x+X2.x)*crossl ;
      sumy -= ($cl->$X.y+X1.y+X2.y)*crossl ;
      sumz -= ($cl->$X.z+X1.z+X2.z)*crossl ;
      const vector3d<real_t> v1r = $face2node[n1]->$pos-center_r ;
      const vector3d<real_t> v2r = $face2node[n2]->$pos-center_r ;
      const vector3d<real_t> crossr = cross(v1r,v2r) ;
      sumx += ($cr->$X.x+X1.x+X2.x)*crossr ;
      sumy += ($cr->$X.y+X1.y+X2.y)*crossr ;
      sumz += ($cr->$X.z+X1.z+X2.z)*crossr ;
      lvol += dot(center_r-center_l,crossr) ;
    }
    const real_t rlvol = 1./lvol ;
    $gradv3d_f(X).x = sumx*rlvol ;
    $gradv3d_f(X).y = sumy*rlvol ;
    $gradv3d_f(X).z = sumz*rlvol ;
  }

  $rule pointwise(NGT::gradv3d_f(X)<-ci->(X,cellcenter),NGTIntegratev3d(X),facecenter,
                  face2node->(NGTNodalv3d(X),pos)),
    constraint(NGTGradient,UseNGTViscous,ci->cellcenter) {
    const int sz = $face2node.size() ;
    const vector3d<real_t> center_l = $ci->$cellcenter ;
    const vector3d<real_t> center_r = $facecenter ;
    vector3d<real_t> sumx = vector3d<real_t>(0,0,0) ;
    vector3d<real_t> sumy = vector3d<real_t>(0,0,0) ;
    vector3d<real_t> sumz = vector3d<real_t>(0,0,0) ;
    real_t lvol = 0 ;

    for(int i=0;i<sz;++i) {
      int n1 = i ;
      int n2 = (i+1)%sz ;
      const vector3d<real_t> X1 = $face2node[n1]->$NGTNodalv3d(X) ;
      const vector3d<real_t> X2 = $face2node[n1]->$NGTNodalv3d(X) ;
      // 2*dot(A,n)
      const vector3d<real_t> v1l = $face2node[n1]->$pos-center_l ;
      const vector3d<real_t> v2l = $face2node[n2]->$pos-center_l ;
      const vector3d<real_t> crossl = cross(v1l,v2l) ;
      sumx -= ($ci->$X.x+X1.x+X2.x)*crossl ;
      sumy -= ($ci->$X.y+X1.y+X2.y)*crossl ;
      sumz -= ($ci->$X.z+X1.z+X2.z)*crossl ;
      const vector3d<real_t> v1r = $face2node[n1]->$pos-center_r ;
      const vector3d<real_t> v2r = $face2node[n2]->$pos-center_r ;
      const vector3d<real_t> crossr = cross(v1r,v2r) ;
      sumx += ($NGTIntegratev3d(X).x+X1.x+X2.x)*crossr ;
      sumy += ($NGTIntegratev3d(X).y+X1.y+X2.y)*crossr ;
      sumz += ($NGTIntegratev3d(X).z+X1.z+X2.z)*crossr ;
      lvol += dot(center_r-center_l,crossr) ;
    }
    const real_t rlvol = 1./lvol ;
    $gradv3d_f(X).x = sumx*rlvol ;
    $gradv3d_f(X).y = sumy*rlvol ;
    $gradv3d_f(X).z = sumz*rlvol ;
  }
}

