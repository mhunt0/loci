//#############################################################################
//#
//# Copyright 2008, 2015, Mississippi State University
//#
//# This file is part of the Loci Framework.
//#
//# The Loci Framework is free software: you can redistribute it and/or modify
//# it under the terms of the Lesser GNU General Public License as published by
//# the Free Software Foundation, either version 3 of the License, or
//# (at your option) any later version.
//#
//# The Loci Framework is distributed in the hope that it will be useful,
//# but WITHOUT ANY WARRANTY; without even the implied warranty of
//# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//# Lesser GNU General Public License for more details.
//#
//# You should have received a copy of the Lesser GNU General Public License
//# along with the Loci Framework.  If not, see <http://www.gnu.org/licenses>
//#
//#############################################################################
#ifdef USE_PETSC

//#define VERBOSE
// Standard library includes.
#include<vector>
using std::vector ;

#include <petsc.h>
#include <petscerror.h>
#include <petscksp.h>

#include <Loci>

using Loci::store ;
using Loci::const_store ;
using Loci::param ;
using Loci::const_param ;
using Loci::const_Map ;
using Loci::const_multiMap ;
using Loci::storeRepP ;
using Loci::blackbox ;
using Loci::const_blackbox ;
using Loci::pointwise_rule ;
using Loci::unit_rule ;
using Loci::apply_rule ;
using Loci::singleton_rule ;
using Loci::register_rule ;

using Loci::entitySet ;
using Loci::sequence ;
using Loci::EMPTY ;
using Loci::Entity ;

$include "FVM.lh"



#if (PETSC_VERSION_MAJOR > 3) || ((PETSC_VERSION_MAJOR == 3) && (PETSC_VERSION_MINOR > 1))
#define PETSC_32_API
#endif


#if ((PETSC_VERSION_MAJOR > 3) || (PETSC_VERSION_MAJOR == 3) && (PETSC_VERSION_MINOR > 2))
#define PETSC_33_API
#endif

#if ((PETSC_VERSION_MAJOR > 3) || (PETSC_VERSION_MAJOR == 3) && (PETSC_VERSION_MINOR > 4))
#define PETSC_35_API
#endif

// Create a namespace for the PETSC objects so there is no confusion. Note that
// there is already a type "Mat" defined by Loci.
namespace Petsc {
  typedef struct _p_Vec* Vec ;
  typedef struct _p_Mat* Mat ;
  typedef struct _p_KSP* KSP ;
} 

namespace Loci {

  typedef double real ;

//-----------------------------------------------------------------------------
// Wrapper classes for PETSC objects. These have been created primarily to
// handle memory management.

  // Wrapper for Vec. Note that we cannot check the success of the destroy in
  // the destructor since the destructor cannot return a value.
  class PETSCVector {
    private:
      bool created ;
      mutable Petsc::Vec v ;
    public:
    PETSCVector() : created(false) {}
#ifdef PETSC_32_API
    ~PETSCVector() { if(created) VecDestroy(&v) ; }
#else
    ~PETSCVector() { if(created) VecDestroy(v) ; }
#endif
    public:
      int AssemblyBegin() const {
        int ierr=VecAssemblyBegin(v) ; CHKERRQ(ierr) ; return 0 ;
      }
      int AssemblyEnd() const {
        int ierr=VecAssemblyEnd(v) ; CHKERRQ(ierr) ; return 0 ;
      }
      int Create(int localSize,int globalSize) {
        if(created) return 0 ;
#ifdef VERBOSE
        cerr << "Vector being created: " << localSize << " " << globalSize << endl ;
#endif
        int ierr=VecCreate(PETSC_COMM_WORLD,&v) ; CHKERRQ(ierr) ;
        ierr=VecSetSizes(v,localSize,globalSize) ; CHKERRQ(ierr) ;
        ierr=VecSetFromOptions(v) ; CHKERRQ(ierr) ;
#ifdef  VERBOSE
        cerr << "Vector creation finished" << endl ;
#endif
        created=true ; return 0 ;
      }
      const Petsc::Vec& Data() const { return v ; }
      int DuplicateFrom(const PETSCVector &a) {
        int ierr=VecDuplicate(a.v,&v) ; CHKERRQ(ierr) ;
        return ierr ;
      }
      int GetArray(PetscScalar **array) const {
         int ierr=VecGetArray(v,array) ; CHKERRQ(ierr) ; return ierr ;
      }
      int GetOwnershipRange(int *low,int *high) const {
        int ierr=VecGetOwnershipRange(v,low,high) ; CHKERRQ(ierr) ; return ierr ;
      }
      int RestoreArray(PetscScalar **array) const {
        int ierr=VecRestoreArray(v,array) ; CHKERRQ(ierr) ; return ierr ;
      }
      int SetValue(const int *index,const PetscScalar *value) const {
        int ierr=VecSetValues(v,1,index,value,INSERT_VALUES) ; CHKERRQ(ierr) ;
        return ierr ;
      }
  } ;

  // Wrapper for Mat. This class assumes a square matrix. Note that we cannot
  // check the success of the destroy in the destructor since the destructor
  // cannot return a value.
  class PETSCMatrix {
    private:
      bool created ;
      mutable Petsc::Mat m ;
    public:
      PETSCMatrix() : created(false) {}
#ifdef PETSC_32_API
    ~PETSCMatrix() { if(created) MatDestroy(&m) ; }
#else
    ~PETSCMatrix() { if(created) MatDestroy(m) ; }
#endif
    
    public:
      int AssemblyBegin() const {
        int ierr=MatAssemblyBegin(m,MAT_FINAL_ASSEMBLY) ;
        CHKERRQ(ierr) ; return ierr ;
      }
      int AssemblyEnd() const {
       int ierr=MatAssemblyEnd(m,MAT_FINAL_ASSEMBLY) ;
       CHKERRQ(ierr) ; return ierr ;
      }
      int Create(int numLocalRow,int numGlobalRow,int *numDiagonalNonZero,int
      *numOffDiagonalNonZero) {
        if(created) return 0 ;
        if(Loci::MPI_processes>1){
#ifdef PETSC_33_API
          int ierr=MatCreateAIJ(PETSC_COMM_WORLD,numLocalRow,numLocalRow,
            numGlobalRow,numGlobalRow,0,numDiagonalNonZero,0,
            numOffDiagonalNonZero,&m) ; CHKERRQ(ierr) ;
#else
          int ierr=MatCreateMPIAIJ(PETSC_COMM_WORLD,numLocalRow,numLocalRow,
            numGlobalRow,numGlobalRow,0,numDiagonalNonZero,0,
            numOffDiagonalNonZero,&m) ; CHKERRQ(ierr) ;
#endif
        }else{
          int ierr=MatCreateSeqAIJ(PETSC_COMM_WORLD,numGlobalRow,numGlobalRow,
            0,numDiagonalNonZero,&m) ; CHKERRQ(ierr) ;
        }
        created=true ; return 0 ;
      }
      const Petsc::Mat& Data() const { return m ; }
      int GetOwnershipRange(int *firstRow,int *lastRow) {
        int ierr=MatGetOwnershipRange(m,firstRow,lastRow) ; CHKERRQ(ierr) ;
        return 0 ;
      }
      int SetRowValues(int rowNum,int numColumn,int *columnIndices,PetscScalar
      *columnValues) const {
        int ierr=MatSetValues(m,1,&rowNum,numColumn,columnIndices,columnValues,
          INSERT_VALUES) ; CHKERRQ(ierr) ; return 0 ;
      }
  } ;

  // Wrapper for Mat. This class assumes a square matrix. Note that we cannot
  // check the success of the destroy in the destructor since the destructor
  // cannot return a value.
  class PETSCBlockMatrix {
  private:
    bool created ;
  public:
    mutable Petsc::Mat m ;
    PETSCBlockMatrix() : created(false) {}
#ifdef PETSC_32_API
    ~PETSCBlockMatrix() { if(created) MatDestroy(&m) ; }
#else
    ~PETSCBlockMatrix() { if(created) MatDestroy(m) ; }
#endif
  public:
    int AssemblyBegin() const {
      int ierr=MatAssemblyBegin(m,MAT_FINAL_ASSEMBLY) ;
      CHKERRQ(ierr) ; return ierr ;
    }
    int AssemblyEnd() const {
      int ierr=MatAssemblyEnd(m,MAT_FINAL_ASSEMBLY) ;
      CHKERRQ(ierr) ; return ierr ;
    }
    int Create(int block_size,int numLocalRow,int numGlobalRow,int *numDiagonalNonZero,int
               *numOffDiagonalNonZero) {
      if(created) return 0 ;
      if(Loci::MPI_processes>1){
#ifdef PETSC_33_API
        int ierr=MatCreateBAIJ(PETSC_COMM_WORLD,block_size,
                                  numLocalRow,numLocalRow,
                                  numGlobalRow,numGlobalRow,0,
                                  numDiagonalNonZero,0,
                                  numOffDiagonalNonZero,&m) ;
#else
        int ierr=MatCreateMPIBAIJ(PETSC_COMM_WORLD,block_size,
                                  numLocalRow,numLocalRow,
                                  numGlobalRow,numGlobalRow,0,
                                  numDiagonalNonZero,0,
                                  numOffDiagonalNonZero,&m) ;
#endif
        CHKERRQ(ierr) ;
      }else{
        int ierr=MatCreateSeqBAIJ(PETSC_COMM_WORLD,block_size,
                                  numGlobalRow,numGlobalRow,
                                  0,numDiagonalNonZero,&m) ;
        CHKERRQ(ierr) ;
      }
      created=true ; return 0 ;
    }
    const Petsc::Mat& Data() const { return m ; }
    int GetOwnershipRange(int *firstRow,int *lastRow) {
      int ierr=MatGetOwnershipRange(m,firstRow,lastRow) ; CHKERRQ(ierr) ;
      return 0 ;
    }
    int SetRowValues(int rowNum,int numColumn,int *columnIndices,PetscScalar
                     *columnValues) const {
      int ierr=MatSetValuesBlocked(m,1,&rowNum,numColumn,columnIndices,columnValues,
                            INSERT_VALUES) ; CHKERRQ(ierr) ; return 0 ;
    }
  } ;


  // Wrapper for KSP.
  class PETSCKsp {
  private:
    bool created ;
    mutable Petsc::KSP ksp ;
  public:
    PETSCKsp() : created(false) {}
#ifdef PETSC_32_API
    ~PETSCKsp() { if(created) KSPDestroy(&ksp) ; }
#else
    ~PETSCKsp() { if(created) KSPDestroy(ksp) ; }
#endif
  public:
    int Create() {
      if(created) return 0 ;
      int ierr=KSPCreate(PETSC_COMM_WORLD,&ksp) ; CHKERRQ(ierr) ;
      created=true ; return 0 ;
    }
    int GetIterationNumber() const {
      int numIterations ; KSPGetIterationNumber(ksp,&numIterations) ;
      return numIterations ;
    }
    int SetFromOptions() {
      int ierr=KSPSetFromOptions(ksp) ; CHKERRQ(ierr) ; return 0 ;
    }
    int SetOperators(const PETSCBlockMatrix &m) const {
#ifdef PETSC_35_API
      int ierr=KSPSetOperators(ksp,m.Data(),m.Data()) ;
#else
      int ierr=KSPSetOperators(ksp,m.Data(),m.Data(),SAME_NONZERO_PATTERN) ;
#endif
      CHKERRQ(ierr) ; return 0 ;
    }
    int SetOperators(const PETSCMatrix &m) const {
#ifdef PETSC_35_API
      int ierr=KSPSetOperators(ksp,m.Data(),m.Data()) ;
#else
      int ierr=KSPSetOperators(ksp,m.Data(),m.Data(),SAME_NONZERO_PATTERN) ;
#endif
      CHKERRQ(ierr) ; return 0 ;
    }
    int SetTolerances(real relativeTolerance,real absoluteTolerance,int
                      maxIterations) const {
      return KSPSetTolerances(ksp,relativeTolerance,absoluteTolerance,PETSC_DEFAULT,
                              maxIterations) ;
    }
    int Solve(const PETSCVector &b, PETSCVector &x) const {
      int ierr=KSPSolve(ksp,b.Data(),x.Data()) ; CHKERRQ(ierr) ; return ierr ;
    }
  } ;


//-----------------------------------------------------------------------------
// Rules for setting up the PETSC data.

  // Gets the number of cells assigned on all processes. This rule is
  // definitely not in the Loci spirit since we are collecting data from
  // other processes.
  $type petscNumCell param<vector<int> > ;
  $type petscLocalCell  param<entitySet>  ;

  $type petscDummy param<bool> ;
  $rule default(petscDummy) {
    $petscDummy = true ;
  }
  // Gets the number of cells assigned on all processes. This rule is
  // definitely not in the Loci spirit since we are collecting data from
  // other processes.
  $rule singleton(petscNumCell,petscLocalCell<-petscDummy),
                constraint(geom_cells),option(disable_threading) {

    // Get the collection of entities assigned to this processor
    storeRepP myEntities=
      Loci::exec_current_fact_db->get_variable("my_entities") ;
    entitySet localEntities=~EMPTY ;
    if(myEntities!=0) localEntities=(*myEntities).domain() ;
    
    entitySet localCellWithGhost=entitySet(seq) ;
    
    // Get the local cells, not including the ghost cells.
    $petscLocalCell= (localEntities & localCellWithGhost) ;

    // Distribute the number of cells to all processes.
    $petscNumCell=Loci::all_collect_sizes(($petscLocalCell).size()) ;

#ifdef VERBOSE
    for(size_t i=0;i<$petscNumCell.size();++i)
      cerr << "process,numCell: " << i << " " << $petscNumCell[i] << endl ;
#endif
  } 

  $type petscCellToRow store<int> ;
  
  $rule pointwise(petscCellToRow<-petscNumCell),
    constraint(geom_cells),
    option(disable_threading), prelude {


        // Compute the row offset for this process.
        int offset=0 ;
        for(int i=0;i<Loci::MPI_rank;++i)
          offset+=(*$petscNumCell)[i] ; 

        // Assign row number.
        sequence::const_iterator cellPtr=seq.begin() ;
        for(int i=0;i<(*$petscNumCell)[Loci::MPI_rank];++cellPtr,++i){
          $petscCellToRow[*cellPtr]=offset+i ;
        }
  } ;

  // Rule that copies petscCellToRow for periodic boundaries
  $rule pointwise(cr->petscCellToRow<-pmap->cl->petscCellToRow) {
      $cr->$petscCellToRow = $pmap->$cl->$petscCellToRow ;
  }

  $type petscNumDiagonalNonZero store<int> ;
  // Determines the number of non-zero entries in the local portion of the
  // Petsc matrix for each cell. The local portion is defined as the square
  // row/column sub-block of the PETSC matrix whose rows map to cells local
  // to the process.
  $rule pointwise(petscNumDiagonalNonZero<-petscLocalCell,upper->cr,lower->cl),constraint(geom_cells) {
    int cnt = 1 ; // Diagonal
    for(int i=0;i<$lower.size();++i) 
      if($petscLocalCell.inSet($lower[i]->$cl))
        cnt++ ;
    
    for(int i=0;i<$upper.size();++i)
      if($petscLocalCell.inSet($upper[i]->$cr))
        cnt++ ;
    $petscNumDiagonalNonZero = cnt ;
  }


  $type petscNumOffDiagonalNonZero store<int> ;
  
  $rule pointwise(petscNumOffDiagonalNonZero<-upper->cr,lower->cl,petscNumDiagonalNonZero), constraint(geom_cells) {
    
    $petscNumOffDiagonalNonZero=$upper.size()+$lower.size()+1
      -$petscNumDiagonalNonZero ;
  }

  $type petscScalarB(X) blackbox<PETSCVector> ;
  $type petscScalarA(X) blackbox<PETSCMatrix> ;


  // Sets up the PETSC right-hand-side vector. Note that this is a unit_rule,
  // since this is the only way we can have stores as input to a rule
  // outputting blackboxes.
  class PETSCSetupRHSUnit : public singleton_rule {
    private:
      const_param<vector<int> > petscNumCell ;
      blackbox<PETSCVector> b ;
    public:

      // Define input and output.
      PETSCSetupRHSUnit() {
        name_store("petscNumCell",petscNumCell) ;
        name_store("petscScalarB(X)",b) ;
        input("petscNumCell") ;
        output("petscScalarB(X)") ;
        //        constraint("PETSCLinearSolver(X),geom_cells") ;
        constraint("geom_cells") ;
        disable_threading() ;
      }

      // Do the set-up.
      void compute(const sequence & seq) {

        // Get the number of local and global cells.
        int localNumCell=(*petscNumCell)[Loci::MPI_rank],globalNumCell=0 ;
        for(size_t i=0;i<(*petscNumCell).size();++i) globalNumCell+=
          (*petscNumCell)[i] ;

        // Allocate the unknown and rhs vectors.
#ifdef VERBOSE
        cerr << "Creating RHS" << endl ;
        cerr << "localNumCell,globalNumCell:" << localNumCell << " " << globalNumCell
             << endl ;
#endif
        (*b).Create(localNumCell,globalNumCell) ;
#ifdef VERBOSE
        cerr << "Finished creating RHS" << endl ;
#endif
      }
  } ;

  register_rule<PETSCSetupRHSUnit> registerPETSCSetupRHSUnit ;

  // Sets up the PETSC matrix. Note that this is a unit_rule, since this is the
  // only way we can have stores as input to a rule outputting blackboxes.
  class PETSCSetupMatrixUnit : public unit_rule {
    private:
      const_store<int> petscNumDiagonalNonZero ;
      const_store<int> petscNumOffDiagonalNonZero ;
      const_param<vector<int> > petscNumCell ;
      blackbox<PETSCMatrix> A ;
    public:

      // Define input and output.
      PETSCSetupMatrixUnit() {
        name_store("petscNumDiagonalNonZero",petscNumDiagonalNonZero) ;
        name_store("petscNumOffDiagonalNonZero",petscNumOffDiagonalNonZero) ;
        name_store("petscNumCell",petscNumCell) ;
        name_store("petscScalarA(X)",A) ;
        input("petscNumDiagonalNonZero,petscNumOffDiagonalNonZero") ;
        input("petscNumCell") ;
        output("petscScalarA(X)") ;
        //        constraint("PETSCLinearSolver(X),geom_cells") ;
        constraint("geom_cells") ;
        disable_threading() ;
      }

      // Do the set-up.
      void compute(const sequence & seq) {

        // Get the number of local and global cells.
        int localNumCell=(*petscNumCell)[Loci::MPI_rank],globalNumCell=0 ;
        for(size_t i=0;i<(*petscNumCell).size();++i)
          globalNumCell+= (*petscNumCell)[i] ;

        // Make temporary copy of matrix allocation data.
        int count=0,*numDiagonalNonZero=new int[localNumCell] ;
        int *numOffDiagonalNonZero=new int[localNumCell] ;
        for(sequence::const_iterator cellPtr=seq.begin();cellPtr!=seq.end();
        ++cellPtr,++count){
          numDiagonalNonZero[count]=petscNumDiagonalNonZero[*cellPtr] ;
          numOffDiagonalNonZero[count]=petscNumOffDiagonalNonZero[*cellPtr] ;
        }

        // Allocate the matrix.
#ifdef VERBOSE
        cerr << "Creating matrix" << endl ;
#endif
        (*A).Create(localNumCell,globalNumCell,numDiagonalNonZero,
                    numOffDiagonalNonZero) ;
#ifdef VERBOSE
        cerr << "Finished creating matrix" << endl ;
#endif

        // Deallocate temporary copy of matrix allocation data.
        delete [] numDiagonalNonZero ; delete [] numOffDiagonalNonZero ;
      }
  } ;

  register_rule<PETSCSetupMatrixUnit> registerPETSCSetupMatrixUnit ;

  // Empty apply rule required by Loci. The data type and operator do not
  // matter since nothing is done by this rule. Keep the same inputs and
  // outputs as the unit rule, even though we don't have to.
  class PETSCSetupMatrixApply : public apply_rule<blackbox<PETSCMatrix>,
                                                  Loci::NullOp<PETSCMatrix> > {
    private:
      const_store<int> petscNumDiagonalNonZero ;
      const_store<int> petscNumOffDiagonalNonZero ;
      const_param<vector<int> > petscNumCell ;
      blackbox<PETSCMatrix> A ;
    public:

      // Define input and output.
      PETSCSetupMatrixApply() {
        name_store("petscNumDiagonalNonZero",petscNumDiagonalNonZero) ;
        name_store("petscNumOffDiagonalNonZero",petscNumOffDiagonalNonZero) ;
        name_store("petscNumCell",petscNumCell) ;
        name_store("petscScalarA(X)",A) ;
        input("petscNumDiagonalNonZero,petscNumOffDiagonalNonZero") ;
        input("petscNumCell") ;
        output("petscScalarA(X)") ;
        constraint("geom_cells") ;
        //        constraint("PETSCLinearSolver(X),geom_cells") ;
        disable_threading() ;
      }

      // Do nothing.
      void compute(const sequence & seq) {}
  } ;

  register_rule<PETSCSetupMatrixApply> registerPETSCSetupMatrixApply ;

  // Sets up the PETSC linear solver.
  class PETSCSetupSolver : public singleton_rule {
  private:
    const_param<int> maxLinearSolverIterations ;
    const_param<real> petscLinearTolerance ;
    blackbox<PETSCKsp> ksp ;
  public:

    // Define input and output.
    PETSCSetupSolver() {
      name_store("petscLinearMaxIter",maxLinearSolverIterations) ;
      name_store("petscLinearTolerance",petscLinearTolerance) ;
      name_store("petscKSP(X)",ksp) ;
      input("petscLinearMaxIter,petscLinearTolerance") ;
      output("petscKSP(X)") ;
      constraint("geom_cells") ;
      disable_threading();
    }

    // Do the set-up.
    void compute(const sequence & seq) {
#ifdef VERBOSE
      cerr << "Creating KSP" << endl ;
#endif
      (*ksp).Create() ;
      (*ksp).SetTolerances(*petscLinearTolerance,
                           1.0e-18,
                           *maxLinearSolverIterations) ;
      (*ksp).SetFromOptions() ;
#ifdef VERBOSE
      cerr << "Finished creating KSP" << endl ;
#endif
    }
  } ;

  register_rule<PETSCSetupSolver> registerPETSCSetupSolver ;

  class default_petscLinearMaxIter : public default_rule {
    param<int> petscLinearMaxIter ;
  public:
    default_petscLinearMaxIter() {
      name_store("petscLinearMaxIter",petscLinearMaxIter) ;
      output("petscLinearMaxIter") ;
      comments("Maximum Number of linear iterations used by the petsc solver") ;
    }
    virtual void compute(const sequence &seq) {
      *petscLinearMaxIter = 100 ;
    }
  } ;
  register_rule<default_petscLinearMaxIter> register_default_petscLinearMaxIter ;
  class default_petscLinearTolerance : public default_rule {
    param<real> petscLinearTolerance ;
  public:
    default_petscLinearTolerance() {
      name_store("petscLinearTolerance",petscLinearTolerance) ;
      output("petscLinearTolerance") ;
      comments("Relative tolerance used to test convergence in the petsc solver") ;
    }
    virtual void compute(const sequence &seq) {
      *petscLinearTolerance = 1e-5 ;
    }
  } ;
  register_rule<default_petscLinearTolerance> register_default_petscLinearTolerance ;
  
  // Assemble and solve the PETSC system.
  class PETSCSolveUnit : public unit_rule {
    private:
    const_param<vector<int> > petscNumCell ;
      const_multiMap upper,lower ;
      const_Map cl,cr ;
      const_store<real> xU,xL,xB,xD ;
      const_store<int> petscCellToRow ;
      const_blackbox<PETSCVector> b ;
      const_blackbox<PETSCMatrix> A ;
      const_blackbox<PETSCKsp> ksp ;
      blackbox<PETSCVector> phi ;
    private:
      int *columnIndex ;
      PetscScalar *columnValue ;
    public:

      // Define input and output.
      PETSCSolveUnit() {
        name_store("cl",cl) ;
        name_store("cr",cr) ;
        name_store("upper",upper) ;
        name_store("lower",lower) ;
        name_store("X_U",xU) ;
        name_store("X_L",xL) ;
        name_store("X_B",xB) ;
        name_store("X_D",xD) ;
        name_store("petscCellToRow",petscCellToRow) ;
        name_store("petscNumCell",petscNumCell) ;
        name_store("petscScalarB(X)",b) ;
        name_store("petscScalarA(X)",A) ;
        name_store("petscKSP(X)",ksp) ;
        name_store("petscScalarSolveBB(X)",phi) ;
        input("petscNumCell") ;
        input("upper->cr->petscCellToRow") ;
        input("lower->cl->petscCellToRow") ;
        input("upper->X_U,lower->X_L,X_B,X_D") ;
        input("petscScalarA(X),petscScalarB(X),petscKSP(X)") ;
        output("petscScalarSolveBB(X)") ;
        constraint("geom_cells") ;
        //        constraint("PETSCLinearSolver(X),geom_cells") ;
        disable_threading() ;
      }

      // Assemble and solve.
      virtual void compute(const sequence &seq) {

      int localNumCell=(*petscNumCell)[Loci::MPI_rank],globalNumCell=0 ;
      for(size_t i=0;i<(*petscNumCell).size();++i) globalNumCell+=
                                                     (*petscNumCell)[i] ;

      (*phi).Create(localNumCell,globalNumCell) ;
        // Create the solution vector.
        //        (*phi).DuplicateFrom(*b) ;

        // Allocate memory for column index and values arrays. There should
        // never be more than 100 entries.
        columnIndex=new int[100] ; columnValue=new PetscScalar[100] ;

        // Assemble the matrix.
        do_loop(seq,this,&PETSCSolveUnit::AssembleMatrix) ;
        (*A).AssemblyBegin() ; (*A).AssemblyEnd() ;
        
        // Dellocate memory.
        delete [] columnIndex ; delete [] columnValue ;

        // Assemble the rhs vector.
        do_loop(seq,this,&PETSCSolveUnit::AssembleRHS) ;
        (*b).AssemblyBegin() ; (*b).AssemblyEnd() ;

#ifdef VERBOSE
        cerr << "solving the linear system" << endl ;
#endif
        // Solve the linear system
#ifdef VERBOSE
        cerr << "calling(SetOperators)" << endl ;
#endif
        (*ksp).SetOperators(*A) ;
#ifdef VERBOSE
        cerr << "calling Solve()" << endl ;
#endif
        (*ksp).Solve(*b,*phi) ;
//cerr << "numIterations: " << (*ksp).GetIterationNumber() << endl ;
      }

      // Sets matrix values for a cell's row.
      void AssembleMatrix(Entity cell) {

        // Get the row number for this cell.
        int rowIndex=petscCellToRow[cell] ;

        // Set the diagonal entry for the row.
        columnIndex[0]=rowIndex ; columnValue[0]=xD[cell] ;
        //        cerr << "diagonal column value = " << rowIndex << ' ' << xD[cell]
        //             << endl ;

        // Set the column entries for "upper" neighbors.
        const int numUpperEntry=upper.num_elems(cell) ; int count=1 ;
        for(int i=0;i<numUpperEntry;++i,++count){
          columnIndex[count]=petscCellToRow[cr[upper[cell][i]]] ;
          columnValue[count]=xU[upper[cell][i]] ;
        }

        // Set the column entries for "lower" neighbors.
        const int numLowerEntry=lower.num_elems(cell) ;
        for(int i=0;i<numLowerEntry;++i,++count){
          columnIndex[count]=petscCellToRow[cl[lower[cell][i]]] ;
          columnValue[count]=xL[lower[cell][i]] ;
        }

        // Insert row entries into the Petsc matrix.
        (*A).SetRowValues(rowIndex,numUpperEntry+numLowerEntry+1,columnIndex,
          columnValue) ;
      }

      // Sets matrix values for a cell's row.
      void AssembleRHS(Entity cell) {
        const PetscScalar value=xB[cell] ;
        //        cout << "value = " << value << endl ;
        (*b).SetValue(&(petscCellToRow[cell]),&value) ;
      }
  } ;

  register_rule<PETSCSolveUnit> registerPETSCSolveUnit ;

  // Empty apply rule required by Loci. The data type and operator do not
  // matter since nothing is done by this rule. Keep the same inputs and
  // outputs as the unit rule, even though we don't have to.
  class PETSCSolveApply : public apply_rule<blackbox<PETSCVector>,
                                            Loci::NullOp<PETSCVector> > {
    private:
      const_multiMap upper,lower ;
      const_Map cl,cr ;
      const_store<real> xU,xL,xB,xD ;
      const_store<int> petscCellToRow ;
      const_blackbox<PETSCVector> b ;
      const_blackbox<PETSCMatrix> A ;
      const_blackbox<PETSCKsp> ksp ;
      blackbox<PETSCVector> phi ;
    public:

      // Define input and output.
      PETSCSolveApply() {
        name_store("cl",cl) ;
        name_store("cr",cr) ;
        name_store("upper",upper) ;
        name_store("lower",lower) ;
        name_store("X_U",xU) ;
        name_store("X_L",xL) ;
        name_store("X_B",xB) ;
        name_store("X_D",xD) ;
        name_store("petscCellToRow",petscCellToRow) ;
        name_store("petscScalarB(X)",b) ;
        name_store("petscScalarA(X)",A) ;
        name_store("petscKSP(X)",ksp) ;
        name_store("petscScalarSolveBB(X)",phi) ;
        input("upper->cr->petscCellToRow") ;
        input("lower->cl->petscCellToRow") ;
        input("upper->X_U,lower->X_L,X_B,X_D") ;
        input("petscScalarA(X),petscScalarB(X),petscKSP(X)") ;
        output("petscScalarSolveBB(X)") ;
        constraint("geom_cells") ;
        disable_threading() ;
        //        constraint("PETSCLinearSolver(X),geom_cells") ;
      }

      // Do nothing.
      void compute(const sequence & seq) {}
  } ;

  register_rule<PETSCSolveApply> registerPETSCSolveApply ;

  // Non-parametric rule for extracting pPrime from PETSC.
  class PETSCCopy : public pointwise_rule {
    private:
      const_blackbox<PETSCVector> petsc_X ;
      store<real> X_out ;
    public:

      // Define input and output.
      PETSCCopy() {
        name_store("petscScalarSolveBB(X)",petsc_X) ;
        name_store("petscScalarSolve(X)",X_out) ;
        input("petscScalarSolveBB(X)") ;
        output("petscScalarSolve(X)") ;
        constraint("geom_cells") ;
        //        constraint("PETSCLinearSolver(X),geom_cells") ;
        disable_threading() ;
      }

      // Copy the solution back from PETSC.
      void compute(const sequence & seq) {
        int minRowNum,maxRowNum ;
        (*petsc_X).GetOwnershipRange(&minRowNum,&maxRowNum) ;
        PetscScalar *X_Copy ; (*petsc_X).GetArray(&X_Copy) ;
        sequence::const_iterator cellPtr=seq.begin() ;
        for(int row=minRowNum;row<maxRowNum;++row,++cellPtr) {
          X_out[*cellPtr]= X_Copy[row-minRowNum] ;
          //          cerr << "dq=" << *cellPtr << ' ' << X_out[*cellPtr] << endl ;
        }
        (*petsc_X).RestoreArray(&X_Copy) ;
      }
  } ;

  register_rule<PETSCCopy> registerPETSCCopy ;



  namespace blockeds {

    typedef float real_fj ;

  class PETSCGetBlockSizeUnit : public unit_rule {
    blackbox<int> petscBlockSize ;
  public:
    PETSCGetBlockSizeUnit() {
      name_store("petscBlockSSize(X)",petscBlockSize) ;
      constraint("X_B") ;
      output("petscBlockSSize(X)") ;
    }
    void compute(const sequence &seq) {
      *petscBlockSize = 0 ;
    }
  } ;

  register_rule<PETSCGetBlockSizeUnit> registerPETSCGetBlockSizeUnit ;




    class PETSCGetBlockSizeApply : public apply_rule<blackbox<int>,
                                 Loci::NullOp<int> > {
    const_storeVec<real_fj> xB ;
    blackbox<int> petscBlockSize ;
  public:
    PETSCGetBlockSizeApply() {
      name_store("X_B",xB) ;
      name_store("petscBlockSSize(X)",petscBlockSize) ;
      input("X_B") ;
      input("petscBlockSSize(X)") ;
      output("petscBlockSSize(X)") ;
    }
    void compute(const sequence &seq) {
      *petscBlockSize = max(*petscBlockSize,xB.vecSize()) ;
    }
  } ;

  register_rule<PETSCGetBlockSizeApply> registerPETSCGetBlockSizeApply ;

  
  // Sets up the PETSC right-hand-side vector. 
  class PETSCSetupRHSUnit : public singleton_rule {
  private:
    const_param<vector<int> > petscNumCell ;
    const_blackbox<int> petscBlockSize ;
    blackbox<PETSCVector> b ;
  public:

    // Define input and output.
    PETSCSetupRHSUnit() {
      name_store("petscNumCell",petscNumCell) ;
      name_store("petscBlockedSB(X)",b) ;
      name_store("petscBlockSSize(X)",petscBlockSize) ;
      input("petscBlockSSize(X)") ;
      input("petscNumCell") ;
        
      output("petscBlockedSB(X)") ;
      constraint("geom_cells") ;
      disable_threading() ;
    }

    // Do the set-up.
    void compute(const sequence & seq) {

      // Get the number of local and global cells.
      int localNumCell=(*petscNumCell)[Loci::MPI_rank],globalNumCell=0 ;
      for(size_t i=0;i<(*petscNumCell).size();++i) globalNumCell+=
                                                     (*petscNumCell)[i] ;

      int block_size= *petscBlockSize ;

      // Allocate the unknown and rhs vectors.
#ifdef VERBOSE
      cerr << "Creating RHS" << endl ;
      cerr << "localNumCell,globalNumCell,block_size:"
           << localNumCell << " " << globalNumCell << ' ' << block_size
           << endl ;
#endif
      (*b).Create(localNumCell*block_size,globalNumCell*block_size) ;
#ifdef VERBOSE
      cerr << "Finished creating RHS" << endl ;
#endif
    }
  } ;

  register_rule<PETSCSetupRHSUnit> registerPETSCSetupRHSUnit ;

  // Sets up the PETSC matrix. Note that this is a unit_rule, since this is the
  // only way we can have stores as input to a rule outputting blackboxes.
  class PETSCSetupMatrixUnit : public unit_rule {
  private:
    const_store<int> petscNumDiagonalNonZero ;
    const_store<int> petscNumOffDiagonalNonZero ;
    const_param<vector<int> > petscNumCell ;
    const_blackbox<int> petscBlockSize ;
    blackbox<PETSCBlockMatrix> A ;
  public:

    // Define input and output.
    PETSCSetupMatrixUnit() {
      name_store("petscNumDiagonalNonZero",petscNumDiagonalNonZero) ;
      name_store("petscNumOffDiagonalNonZero",petscNumOffDiagonalNonZero) ;
      name_store("petscNumCell",petscNumCell) ;
      name_store("petscBlockedSA(X)",A) ;
      name_store("petscBlockSSize(X)",petscBlockSize) ;
      input("petscBlockSSize(X)") ;
      input("petscNumDiagonalNonZero,petscNumOffDiagonalNonZero") ;
      input("petscNumCell") ;
      output("petscBlockedSA(X)") ;
      //        constraint("PETSCLinearSolver(X),geom_cells") ;
      constraint("geom_cells") ;
      disable_threading() ;
    }

    // Do the set-up.
    void compute(const sequence & seq) {

      // Get the number of local and global cells.
      int localNumCell=(*petscNumCell)[Loci::MPI_rank],globalNumCell=0 ;
      for(size_t i=0;i<(*petscNumCell).size();++i)
        globalNumCell+= (*petscNumCell)[i] ;

      // Make temporary copy of matrix allocation data.
      int count=0,*numDiagonalNonZero=new int[localNumCell] ;
      int *numOffDiagonalNonZero=new int[localNumCell] ;
      for(sequence::const_iterator cellPtr=seq.begin();cellPtr!=seq.end();
          ++cellPtr,++count){
        numDiagonalNonZero[count]=petscNumDiagonalNonZero[*cellPtr] ;
        numOffDiagonalNonZero[count]=petscNumOffDiagonalNonZero[*cellPtr] ;
      }

      // Allocate the matrix.
#ifdef VERBOSE
      cerr << "Creating matrix" << endl ;
#endif
      int block_size = *petscBlockSize ;
      // Look here more
      (*A).Create(block_size,
                  localNumCell*block_size,
                  globalNumCell*block_size,
                  numDiagonalNonZero,
                  numOffDiagonalNonZero) ;
#ifdef VERBOSE
      cerr << "Finished creating matrix" << endl ;
#endif

      // Deallocate temporary copy of matrix allocation data.
      delete [] numDiagonalNonZero ; delete [] numOffDiagonalNonZero ;
    }
  } ;

  register_rule<PETSCSetupMatrixUnit> registerPETSCSetupMatrixUnit ;

  // Empty apply rule required by Loci. The data type and operator do not
  // matter since nothing is done by this rule. Keep the same inputs and
  // outputs as the unit rule, even though we don't have to.
  class PETSCSetupMatrixApply : public apply_rule<blackbox<PETSCBlockMatrix>,
                                Loci::NullOp<PETSCBlockMatrix> > {
  private:
    const_store<int> petscNumDiagonalNonZero ;
    const_store<int> petscNumOffDiagonalNonZero ;
    const_param<vector<int> > petscNumCell ;
    blackbox<PETSCBlockMatrix> A ;
  public:

    // Define input and output.
    PETSCSetupMatrixApply() {
      name_store("petscNumDiagonalNonZero",petscNumDiagonalNonZero) ;
      name_store("petscNumOffDiagonalNonZero",petscNumOffDiagonalNonZero) ;
      name_store("petscNumCell",petscNumCell) ;
      name_store("petscBlockedSA(X)",A) ;
      input("petscNumDiagonalNonZero,petscNumOffDiagonalNonZero") ;
      input("petscNumCell") ;
      output("petscBlockedSA(X)") ;
      constraint("geom_cells") ;
      //        constraint("PETSCLinearSolver(X),geom_cells") ;
      disable_threading() ;
    }

    // Do nothing.
    void compute(const sequence & seq) {}
  } ;

  register_rule<PETSCSetupMatrixApply> registerPETSCSetupMatrixApply ;


  
  
  // Create the output vector for the petsc solver
  class PETSCSolveUnit : public unit_rule {
    const_blackbox<int> petscBlockSize ;
    const_store<int> petscCellToRow ;
    const_param<vector<int> > petscNumCell ;
    blackbox<PETSCVector> petscSolve ;
  public:

    PETSCSolveUnit() {
      name_store("petscBlockSSize(X)",petscBlockSize) ;
      name_store("petscNumCell",petscNumCell) ;
      name_store("petscCellToRow",petscCellToRow) ;
      name_store("petscBlockedSSolveBB(X)",petscSolve) ;
      input("petscBlockSSize(X),petscNumCell,petscCellToRow") ;
      output("petscBlockedSSolveBB(X)") ;
      disable_threading() ;
    }
    void calculate(Entity cell) {
      const int bs = *petscBlockSize ;
      for(int i=0;i<bs;++i) {
        const PetscScalar value= 0 ;
        int row = petscCellToRow[cell]*bs+i ;
        (*petscSolve).SetValue(&row,&value) ;
      }
    }

    // Do nothing.
    void compute(const sequence & seq) {
      int block_size = *petscBlockSize ;
      // Create the solution vector.
      // Get the number of local and global cells.
      int localNumCell=(*petscNumCell)[Loci::MPI_rank],globalNumCell=0 ;
      for(size_t i=0;i<(*petscNumCell).size();++i) globalNumCell+=
                                                     (*petscNumCell)[i] ;

      (*petscSolve).Create(localNumCell*block_size,globalNumCell*block_size) ;

      do_loop(seq,this) ;
      (*petscSolve).AssemblyBegin() ;
      (*petscSolve).AssemblyEnd() ;
    }
  } ;

  register_rule<PETSCSolveUnit> registerPETSCSolveUnit ;


  // Assemble and solve the linear system.
  class PETSCSolveApply : public apply_rule<blackbox<PETSCVector>,
                          Loci::NullOp<PETSCVector> > {
  private:
    const_multiMap upper,lower ;
    const_Map cl,cr ;
    const_storeVec<real_fj> xB ;
    const_storeMat<real_fj> xD,xU,xL ;
    const_store<int> petscCellToRow ;
    const_blackbox<PETSCVector> b ;
    const_blackbox<PETSCBlockMatrix> A ;
    const_blackbox<PETSCKsp> ksp ;
    const_blackbox<int> petscBlockSize ;
    blackbox<PETSCVector> petscSolve ;

    int *columnIndex ;
    int block_size ;
    PetscScalar *columnValue ;
  public:

    // Define input and output.
    PETSCSolveApply() {
      name_store("cl",cl) ;
      name_store("cr",cr) ;
      name_store("upper",upper) ;
      name_store("lower",lower) ;
      name_store("X_U",xU) ;
      name_store("X_L",xL) ;
      name_store("X_B",xB) ;
      name_store("X_D",xD) ;
      name_store("petscCellToRow",petscCellToRow) ;
      name_store("petscBlockedSB(X)",b) ;
      name_store("petscBlockedSA(X)",A) ;
      name_store("petscKSP(X)",ksp) ;
      name_store("petscBlockedSSolveBB(X)",petscSolve) ;
      name_store("petscBlockSSize(X)",petscBlockSize) ;
      input("petscBlockSSize(X)") ;
      input("upper->cr->petscCellToRow") ;
      input("lower->cl->petscCellToRow") ;
      input("upper->X_U,lower->X_L,X_B,X_D") ;
      input("petscBlockedSA(X),petscBlockedSB(X),petscKSP(X)") ;
      output("petscBlockedSSolveBB(X)") ;
      constraint("geom_cells") ;
      disable_threading() ;
      //        constraint("PETSCLinearSolver(X),geom_cells") ;
    }

    // Assemble and solve.
    virtual void compute(const sequence &seq) {

      block_size = *petscBlockSize ;

      //      (*petscSolve).DuplicateFrom(*b) ;

      // Allocate memory for column index and values arrays. There should
      // never be more than 100 entries.
      columnIndex=new int[100*block_size] ; columnValue=new PetscScalar[100*block_size*block_size] ;

#ifdef VERBOSE
      cerr << "begin matrix assembly" << endl;
#endif
      // Assemble the matrix.
      do_loop(seq,this,&PETSCSolveApply::AssembleMatrix) ;
      (*A).AssemblyBegin() ;
      (*A).AssemblyEnd() ;

      //      PetscViewer viewer ;
      //      PetscViewerASCIIOpen(PETSC_COMM_WORLD,"file.mat",&viewer) ;
      //      MatView((*A).m,viewer) ;
      //      PetscViewerDestroy(viewer) ;
      //      exit(0) ;
      
      // Dellocate memory.
      delete [] columnIndex ; delete [] columnValue ;

#ifdef VERBOSE
      cerr << "begin rhs assembly" << endl ;
#endif
      // Assemble the rhs vector.
      do_loop(seq,this,&PETSCSolveApply::AssembleRHS) ;
      (*b).AssemblyBegin() ;
      (*b).AssemblyEnd() ;

#ifdef VERBOSE
      cerr << "solving the linear system" << endl ;
#endif
      // Solve the linear system
#ifdef VERBOSE
      cerr << "calling(SetOperators)" << endl ;
#endif
      (*ksp).SetOperators(*A) ;
#ifdef VERBOSE
      cerr << "calling Solve()" << endl ;
#endif
      (*ksp).Solve(*b,*petscSolve) ;
      //cerr << "numIterations: " << (*ksp).GetIterationNumber() << endl ;
    }

    // Sets matrix values for a cell's row.
    void AssembleMatrix(Entity cell) {

      // Get the row number for this cell.
      int rowIndex=petscCellToRow[cell] ;

      // Set the diagonal entry for the row.
      columnIndex[0]=rowIndex ;
      int cnt = 0 ;
      //      cout << "rowIndex = " << rowIndex << endl ;
      for(int I=0;I<block_size;++I) {
        for(int J=0;J<block_size;++J) {
          //          cout << xD[cell][I][J] << ' ' ;
          columnValue[cnt++] = xD[cell][I][J] ;
        }
        //        cout << endl ;
      }

      (*A).SetRowValues(rowIndex,1,&rowIndex,columnValue) ;

      // Set the column entries for "upper" neighbors.
      const int numUpperEntry=upper.num_elems(cell) ; int count=1 ;
      for(int i=0;i<numUpperEntry;++i,++count)
        // Do not include self references (can happen due to periodic BC's
        if(petscCellToRow[cell] != petscCellToRow[cr[upper[cell][i]]]) {
          Entity fc = upper[cell][i] ;
          columnIndex[count]=petscCellToRow[cr[fc]] ;
          cnt = 0 ;
          //        cout << "columnIndex = " << columnIndex[count] << endl ;
          for(int I=0;I<block_size;++I) {
            for(int J=0;J<block_size;++J) {
              //            cout << xU[fc][I][J] << ' ';
              columnValue[cnt++] = xU[fc][I][J] ;
            }
            //          cout << endl ;
          }
          (*A).SetRowValues(rowIndex,1,&columnIndex[count],columnValue) ;
          
        }
      
      // Set the column entries for "lower" neighbors.
      const int numLowerEntry=lower.num_elems(cell) ;
      for(int i=0;i<numLowerEntry;++i,++count){
        Entity fc = lower[cell][i] ;
        columnIndex[count]=petscCellToRow[cl[fc]] ;
        cnt = 0 ;
        //        cout << "columnIndex = " << columnIndex[count] << endl ;
        for(int I=0;I<block_size;++I) {
          for(int J=0;J<block_size;++J) {
            //            cout << xL[fc][I][J] << ' ' ;
            columnValue[cnt++] = xL[fc][I][J] ;
          }
          //          cout << endl ;
        }
        (*A).SetRowValues(rowIndex,1,&columnIndex[count],columnValue) ;
      }

      
      // Insert row entries into the Petsc matrix.
      //      (*A).SetRowValues(rowIndex,numUpperEntry+numLowerEntry+1,columnIndex,
      //                        columnValue) ;
    }

    // Sets matrix values for a cell's row.
    void AssembleRHS(Entity cell) {
      const int bs = *petscBlockSize ;
      for(int i=0;i<bs;++i) {
        const PetscScalar value=xB[cell][i] ;
        //        const PetscScalar value= 0 ;
        //        cout << "value = " << value << endl ;
        int row = petscCellToRow[cell]*bs+i ;
        (*b).SetValue(&row,&value) ;
      }
    }
  } ;

  register_rule<PETSCSolveApply> registerPETSCSolveApply ;

  class PETSCCopy : public pointwise_rule {
  private:
    const_blackbox<PETSCVector> X_solve ;
    storeVec<real> X ; // Note: must change code to reflect new vector form
    const_blackbox<int> petscBlockSize ;
  public:

    // Define input and output.
    PETSCCopy() {
      name_store("petscBlockedSSolveBB(X)",X_solve) ;
      name_store("petscBlockedSSolve(X)",X) ;
      name_store("petscBlockSSize(X)",petscBlockSize) ;
      input("petscBlockSSize(X)") ;
      input("petscBlockedSSolveBB(X)") ;
      output("petscBlockedSSolve(X)") ;
      constraint("geom_cells") ;
      disable_threading() ;
    }

    // Copy the solution back from PETSC.
    void compute(const sequence & seq) {
      int minRowNum,maxRowNum ;
      (*X_solve).GetOwnershipRange(&minRowNum,&maxRowNum) ;
      int bs = *petscBlockSize ;
      X.setVecSize(bs) ;
      PetscScalar *X_Copy ; (*X_solve).GetArray(&X_Copy) ;
      sequence::const_iterator cellPtr=seq.begin() ;
     
      for(int row=minRowNum;row<maxRowNum;++cellPtr) {
        for(int i=0;i<bs;++i,++row)
          X[*cellPtr][i] = X_Copy[row-minRowNum] ;
      }
      (*X_solve).RestoreArray(&X_Copy) ;
    }
  } ;

  register_rule<PETSCCopy> registerPETSCCopy ;
    
  }

  namespace blocked {

  class PETSCGetBlockSizeUnit : public unit_rule {
    blackbox<int> petscBlockSize ;
  public:
    PETSCGetBlockSizeUnit() {
      name_store("petscBlockSize(X)",petscBlockSize) ;
      constraint("X_B") ;
      output("petscBlockSize(X)") ;
    }
    void compute(const sequence &seq) {
      *petscBlockSize = 0 ;
    }
  } ;

  register_rule<PETSCGetBlockSizeUnit> registerPETSCGetBlockSizeUnit ;



  class PETSCGetBlockSizeApply : public apply_rule<blackbox<int>,
                                 Loci::NullOp<int> > {
    const_storeVec<real> xB ;
    blackbox<int> petscBlockSize ;
  public:
    PETSCGetBlockSizeApply() {
      name_store("X_B",xB) ;
      name_store("petscBlockSize(X)",petscBlockSize) ;
      input("X_B") ;
      input("petscBlockSize(X)") ;
      output("petscBlockSize(X)") ;
    }
    void compute(const sequence &seq) {
      *petscBlockSize = max(*petscBlockSize,xB.vecSize()) ;
    }
  } ;

  register_rule<PETSCGetBlockSizeApply> registerPETSCGetBlockSizeApply ;

  
  // Sets up the PETSC right-hand-side vector. 
  class PETSCSetupRHSUnit : public singleton_rule {
  private:
    const_param<vector<int> > petscNumCell ;
    const_blackbox<int> petscBlockSize ;
    blackbox<PETSCVector> b ;
  public:

    // Define input and output.
    PETSCSetupRHSUnit() {
      name_store("petscNumCell",petscNumCell) ;
      name_store("petscBlockedB(X)",b) ;
      name_store("petscBlockSize(X)",petscBlockSize) ;
      input("petscBlockSize(X)") ;
      input("petscNumCell") ;
        
      output("petscBlockedB(X)") ;
      constraint("geom_cells") ;
      disable_threading() ;
    }

    // Do the set-up.
    void compute(const sequence & seq) {

      // Get the number of local and global cells.
      int localNumCell=(*petscNumCell)[Loci::MPI_rank],globalNumCell=0 ;
      for(size_t i=0;i<(*petscNumCell).size();++i) globalNumCell+=
                                                     (*petscNumCell)[i] ;

      int block_size= *petscBlockSize ;

      // Allocate the unknown and rhs vectors.
#ifdef VERBOSE
      cerr << "Creating RHS" << endl ;
      cerr << "localNumCell,globalNumCell,block_size:"
           << localNumCell << " " << globalNumCell << ' ' << block_size
           << endl ;
#endif
      (*b).Create(localNumCell*block_size,globalNumCell*block_size) ;
#ifdef VERBOSE
      cerr << "Finished creating RHS" << endl ;
#endif
    }
  } ;

  register_rule<PETSCSetupRHSUnit> registerPETSCSetupRHSUnit ;

  // Sets up the PETSC matrix. Note that this is a unit_rule, since this is the
  // only way we can have stores as input to a rule outputting blackboxes.
  class PETSCSetupMatrixUnit : public unit_rule {
  private:
    const_store<int> petscNumDiagonalNonZero ;
    const_store<int> petscNumOffDiagonalNonZero ;
    const_param<vector<int> > petscNumCell ;
    const_blackbox<int> petscBlockSize ;
    blackbox<PETSCBlockMatrix> A ;
  public:

    // Define input and output.
    PETSCSetupMatrixUnit() {
      name_store("petscNumDiagonalNonZero",petscNumDiagonalNonZero) ;
      name_store("petscNumOffDiagonalNonZero",petscNumOffDiagonalNonZero) ;
      name_store("petscNumCell",petscNumCell) ;
      name_store("petscBlockedA(X)",A) ;
      name_store("petscBlockSize(X)",petscBlockSize) ;
      input("petscBlockSize(X)") ;
      input("petscNumDiagonalNonZero,petscNumOffDiagonalNonZero") ;
      input("petscNumCell") ;
      output("petscBlockedA(X)") ;
      //        constraint("PETSCLinearSolver(X),geom_cells") ;
      constraint("geom_cells") ;
      disable_threading() ;
    }

    // Do the set-up.
    void compute(const sequence & seq) {

      // Get the number of local and global cells.
      int localNumCell=(*petscNumCell)[Loci::MPI_rank],globalNumCell=0 ;
      for(size_t i=0;i<(*petscNumCell).size();++i)
        globalNumCell+= (*petscNumCell)[i] ;

      // Make temporary copy of matrix allocation data.
      int count=0,*numDiagonalNonZero=new int[localNumCell] ;
      int *numOffDiagonalNonZero=new int[localNumCell] ;
      for(sequence::const_iterator cellPtr=seq.begin();cellPtr!=seq.end();
          ++cellPtr,++count){
        numDiagonalNonZero[count]=petscNumDiagonalNonZero[*cellPtr] ;
        numOffDiagonalNonZero[count]=petscNumOffDiagonalNonZero[*cellPtr] ;
      }

      // Allocate the matrix.
#ifdef VERBOSE
      cerr << "Creating matrix" << endl ;
#endif
      int block_size = *petscBlockSize ;
      // Look here more
      (*A).Create(block_size,
                  localNumCell*block_size,
                  globalNumCell*block_size,
                  numDiagonalNonZero,
                  numOffDiagonalNonZero) ;
#ifdef VERBOSE
      cerr << "Finished creating matrix" << endl ;
#endif

      // Deallocate temporary copy of matrix allocation data.
      delete [] numDiagonalNonZero ; delete [] numOffDiagonalNonZero ;
    }
  } ;

  register_rule<PETSCSetupMatrixUnit> registerPETSCSetupMatrixUnit ;

  // Empty apply rule required by Loci. The data type and operator do not
  // matter since nothing is done by this rule. Keep the same inputs and
  // outputs as the unit rule, even though we don't have to.
  class PETSCSetupMatrixApply : public apply_rule<blackbox<PETSCBlockMatrix>,
                                Loci::NullOp<PETSCBlockMatrix> > {
  private:
    const_store<int> petscNumDiagonalNonZero ;
    const_store<int> petscNumOffDiagonalNonZero ;
    const_param<vector<int> > petscNumCell ;
    blackbox<PETSCBlockMatrix> A ;
  public:

    // Define input and output.
    PETSCSetupMatrixApply() {
      name_store("petscNumDiagonalNonZero",petscNumDiagonalNonZero) ;
      name_store("petscNumOffDiagonalNonZero",petscNumOffDiagonalNonZero) ;
      name_store("petscNumCell",petscNumCell) ;
      name_store("petscBlockedA(X)",A) ;
      input("petscNumDiagonalNonZero,petscNumOffDiagonalNonZero") ;
      input("petscNumCell") ;
      output("petscBlockedA(X)") ;
      constraint("geom_cells") ;
      //        constraint("PETSCLinearSolver(X),geom_cells") ;
      disable_threading() ;
    }

    // Do nothing.
    void compute(const sequence & seq) {}
  } ;

  register_rule<PETSCSetupMatrixApply> registerPETSCSetupMatrixApply ;


  
  
  // Create the output vector for the petsc solver
  class PETSCSolveUnit : public unit_rule {
    const_blackbox<int> petscBlockSize ;
    const_store<int> petscCellToRow ;
    const_param<vector<int> > petscNumCell ;
    blackbox<PETSCVector> petscSolve ;
  public:

    PETSCSolveUnit() {
      name_store("petscBlockSize(X)",petscBlockSize) ;
      name_store("petscNumCell",petscNumCell) ;
      name_store("petscCellToRow",petscCellToRow) ;
      name_store("petscBlockedSolveBB(X)",petscSolve) ;
      input("petscBlockSize(X),petscNumCell,petscCellToRow") ;
      output("petscBlockedSolveBB(X)") ;
      disable_threading() ;
    }
    void calculate(Entity cell) {
      const int bs = *petscBlockSize ;
      for(int i=0;i<bs;++i) {
        const PetscScalar value= 0 ;
        int row = petscCellToRow[cell]*bs+i ;
        (*petscSolve).SetValue(&row,&value) ;
      }
    }

    // Do nothing.
    void compute(const sequence & seq) {
      int block_size = *petscBlockSize ;
      // Create the solution vector.
      // Get the number of local and global cells.
      int localNumCell=(*petscNumCell)[Loci::MPI_rank],globalNumCell=0 ;
      for(size_t i=0;i<(*petscNumCell).size();++i) globalNumCell+=
                                                     (*petscNumCell)[i] ;

      (*petscSolve).Create(localNumCell*block_size,globalNumCell*block_size) ;

      do_loop(seq,this) ;
      (*petscSolve).AssemblyBegin() ;
      (*petscSolve).AssemblyEnd() ;
    }
  } ;

  register_rule<PETSCSolveUnit> registerPETSCSolveUnit ;


  // Assemble and solve the linear system.
  class PETSCSolveApply : public apply_rule<blackbox<PETSCVector>,
                          Loci::NullOp<PETSCVector> > {
  private:
    const_multiMap upper,lower ;
    const_Map cl,cr ;
    const_storeVec<real> xB ;
    const_storeMat<real> xD,xU,xL ;
    const_store<int> petscCellToRow ;
    const_blackbox<PETSCVector> b ;
    const_blackbox<PETSCBlockMatrix> A ;
    const_blackbox<PETSCKsp> ksp ;
    const_blackbox<int> petscBlockSize ;
    blackbox<PETSCVector> petscSolve ;

    int *columnIndex ;
    int block_size ;
    PetscScalar *columnValue ;
  public:

    // Define input and output.
    PETSCSolveApply() {
      name_store("cl",cl) ;
      name_store("cr",cr) ;
      name_store("upper",upper) ;
      name_store("lower",lower) ;
      name_store("X_U",xU) ;
      name_store("X_L",xL) ;
      name_store("X_B",xB) ;
      name_store("X_D",xD) ;
      name_store("petscCellToRow",petscCellToRow) ;
      name_store("petscBlockedB(X)",b) ;
      name_store("petscBlockedA(X)",A) ;
      name_store("petscKSP(X)",ksp) ;
      name_store("petscBlockedSolveBB(X)",petscSolve) ;
      name_store("petscBlockSize(X)",petscBlockSize) ;
      input("petscBlockSize(X)") ;
      input("upper->cr->petscCellToRow") ;
      input("lower->cl->petscCellToRow") ;
      input("upper->X_U,lower->X_L,X_B,X_D") ;
      input("petscBlockedA(X),petscBlockedB(X),petscKSP(X)") ;
      output("petscBlockedSolveBB(X)") ;
      constraint("geom_cells") ;
      disable_threading() ;
      //        constraint("PETSCLinearSolver(X),geom_cells") ;
    }

    // Assemble and solve.
    virtual void compute(const sequence &seq) {

      block_size = *petscBlockSize ;

      //      (*petscSolve).DuplicateFrom(*b) ;

      // Allocate memory for column index and values arrays. There should
      // never be more than 100 entries.
      columnIndex=new int[100*block_size] ; columnValue=new PetscScalar[100*block_size*block_size] ;

#ifdef VERBOSE
      cerr << "begin matrix assembly" << endl;
#endif
      // Assemble the matrix.
      do_loop(seq,this,&PETSCSolveApply::AssembleMatrix) ;
      (*A).AssemblyBegin() ;
      (*A).AssemblyEnd() ;

      //      PetscViewer viewer ;
      //      PetscViewerASCIIOpen(PETSC_COMM_WORLD,"file.mat",&viewer) ;
      //      MatView((*A).m,viewer) ;
      //      PetscViewerDestroy(viewer) ;
      //      exit(0) ;
      
      // Dellocate memory.
      delete [] columnIndex ; delete [] columnValue ;

#ifdef VERBOSE
      cerr << "begin rhs assembly" << endl ;
#endif
      // Assemble the rhs vector.
      do_loop(seq,this,&PETSCSolveApply::AssembleRHS) ;
      (*b).AssemblyBegin() ;
      (*b).AssemblyEnd() ;

#ifdef VERBOSE
      cerr << "solving the linear system" << endl ;
#endif
      // Solve the linear system
#ifdef VERBOSE
      cerr << "calling(SetOperators)" << endl ;
#endif
      (*ksp).SetOperators(*A) ;
#ifdef VERBOSE
      cerr << "calling Solve()" << endl ;
#endif
      (*ksp).Solve(*b,*petscSolve) ;
      //cerr << "numIterations: " << (*ksp).GetIterationNumber() << endl ;
    }

    // Sets matrix values for a cell's row.
    void AssembleMatrix(Entity cell) {

      // Get the row number for this cell.
      int rowIndex=petscCellToRow[cell] ;

      // Set the diagonal entry for the row.
      columnIndex[0]=rowIndex ;
      int cnt = 0 ;
      //      cout << "rowIndex = " << rowIndex << endl ;
      for(int I=0;I<block_size;++I) {
        for(int J=0;J<block_size;++J) {
          //          cout << xD[cell][I][J] << ' ' ;
          columnValue[cnt++] = xD[cell][I][J] ;
        }
        //        cout << endl ;
      }

      (*A).SetRowValues(rowIndex,1,&rowIndex,columnValue) ;

      // Set the column entries for "upper" neighbors.
      const int numUpperEntry=upper.num_elems(cell) ; int count=1 ;
      for(int i=0;i<numUpperEntry;++i,++count)
        // Do not include self references (can happen due to periodic BC's
        if(petscCellToRow[cell] != petscCellToRow[cr[upper[cell][i]]]) {
          Entity fc = upper[cell][i] ;
          columnIndex[count]=petscCellToRow[cr[fc]] ;
          cnt = 0 ;
          //        cout << "columnIndex = " << columnIndex[count] << endl ;
          for(int I=0;I<block_size;++I) {
            for(int J=0;J<block_size;++J) {
              //            cout << xU[fc][I][J] << ' ';
              columnValue[cnt++] = xU[fc][I][J] ;
            }
            //          cout << endl ;
          }
          (*A).SetRowValues(rowIndex,1,&columnIndex[count],columnValue) ;
          
        }
      
      // Set the column entries for "lower" neighbors.
      const int numLowerEntry=lower.num_elems(cell) ;
      for(int i=0;i<numLowerEntry;++i,++count){
        Entity fc = lower[cell][i] ;
        columnIndex[count]=petscCellToRow[cl[fc]] ;
        cnt = 0 ;
        //        cout << "columnIndex = " << columnIndex[count] << endl ;
        for(int I=0;I<block_size;++I) {
          for(int J=0;J<block_size;++J) {
            //            cout << xL[fc][I][J] << ' ' ;
            columnValue[cnt++] = xL[fc][I][J] ;
          }
          //          cout << endl ;
        }
        (*A).SetRowValues(rowIndex,1,&columnIndex[count],columnValue) ;
      }

      
      // Insert row entries into the Petsc matrix.
      //      (*A).SetRowValues(rowIndex,numUpperEntry+numLowerEntry+1,columnIndex,
      //                        columnValue) ;
    }

    // Sets matrix values for a cell's row.
    void AssembleRHS(Entity cell) {
      const int bs = *petscBlockSize ;
      for(int i=0;i<bs;++i) {
        const PetscScalar value=xB[cell][i] ;
        //        const PetscScalar value= 0 ;
        //        cout << "value = " << value << endl ;
        int row = petscCellToRow[cell]*bs+i ;
        (*b).SetValue(&row,&value) ;
      }
    }
  } ;

  register_rule<PETSCSolveApply> registerPETSCSolveApply ;

  class PETSCCopy : public pointwise_rule {
  private:
    const_blackbox<PETSCVector> X_solve ;
    storeVec<real> X ; // Note: must change code to reflect new vector form
    const_blackbox<int> petscBlockSize ;
  public:

    // Define input and output.
    PETSCCopy() {
      name_store("petscBlockedSolveBB(X)",X_solve) ;
      name_store("petscBlockedSolve(X)",X) ;
      name_store("petscBlockSize(X)",petscBlockSize) ;
      input("petscBlockSize(X)") ;
      input("petscBlockedSolveBB(X)") ;
      output("petscBlockedSolve(X)") ;
      constraint("geom_cells") ;
      disable_threading() ;
    }

    // Copy the solution back from PETSC.
    void compute(const sequence & seq) {
      int minRowNum,maxRowNum ;
      (*X_solve).GetOwnershipRange(&minRowNum,&maxRowNum) ;
      int bs = *petscBlockSize ;
      X.setVecSize(bs) ;
      PetscScalar *X_Copy ; (*X_solve).GetArray(&X_Copy) ;
      sequence::const_iterator cellPtr=seq.begin() ;
     
      for(int row=minRowNum;row<maxRowNum;++cellPtr) {
        for(int i=0;i<bs;++i,++row)
          X[*cellPtr][i] = X_Copy[row-minRowNum] ;
      }
      (*X_solve).RestoreArray(&X_Copy) ;
    }
  } ;

  register_rule<PETSCCopy> registerPETSCCopy ;
    
  }


}
#endif
