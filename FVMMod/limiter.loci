//#############################################################################
//#
//# Copyright 2008, 2015, Mississippi State University
//#
//# This file is part of the Loci Framework.
//#
//# The Loci Framework is free software: you can redistribute it and/or modify
//# it under the terms of the Lesser GNU General Public License as published by
//# the Free Software Foundation, either version 3 of the License, or
//# (at your option) any later version.
//#
//# The Loci Framework is distributed in the hope that it will be useful,
//# but WITHOUT ANY WARRANTY; without even the implied warranty of
//# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//# Lesser GNU General Public License for more details.
//#
//# You should have received a copy of the Lesser GNU General Public License
//# along with the Loci Framework.  If not, see <http://www.gnu.org/licenses>
//#
//#############################################################################
#include <Loci.h>
$include "FVM.lh"

using std::cerr ;
using std::endl ;

namespace Loci {
  typedef vector3d<real_t> vect3d ;
  typedef tensor3d<real_t> tens3d ;
  typedef real_t real ;

  $type firstOrderCells store<char> ;

  $rule unit(firstOrderCells),constraint(geom_cells) {
    $firstOrderCells = 0 ;
  }

  $rule apply((cl,cr)->firstOrderCells<-(cl,cr)->vol)[Loci::Maximum],
  constraint((cl,cr)->geom_cells) {
    if(max($cl->$vol,$cr->$vol) > 50.*min($cl->$vol,$cr->$vol)) {
      char tmp = 1 ;
      join($cl->$firstOrderCells,tmp) ;
      join($cr->$firstOrderCells,tmp) ;
    }
  }

  $rule apply(ci->firstOrderCells<-ci->vol)[Loci::Maximum], constraint(ref->firstOrder_BCoption,ci->vol) {
    char tmp = 1 ;
    join($ci->$firstOrderCells,tmp) ;
  }

  $rule apply((cl,cr)->firstOrderCells<-(cl,cr)->cellcenter,facecenter)[Loci::Maximum],constraint((cl,cr)->geom_cells) {
    // maximum angle between line segment connecting cellcenters and line
    // segments that connect cell centers to face centers.
    vector3d<real_t> v1 = $cr->$cellcenter-$cl->$cellcenter ;
    vector3d<real_t> v2 = $facecenter-$cl->$cellcenter ;
    vector3d<real_t> v3 = $cr->$cellcenter-$facecenter ;
    real_t nv1 = max(norm(v1),real_t(1e-20)) ;
    real_t nv2 = max(norm(v2),real_t(1e-20)) ;
    real_t nv3 = max(norm(v3),real_t(1e-20)) ;
    real_t mincosa = min(dot(v1,v2)/(nv1*nv2),dot(v1,v3)/(nv1*nv3)) ;
    if(mincosa < -.866) { // Greater than 150 degrees
      char tmp = 1 ;
      join($cl->$firstOrderCells,tmp) ;
      join($cr->$firstOrderCells,tmp) ;
    }
  }
    
  
  

  $type Kl param<real> ;
  $rule default(Kl),comments("This parameter is a smoothness parameter for the venkatakrishnan limiter.  A value of zero will not allow overshoots, while a larger value may allow some overshoots to ensure accuracy in locally smooth regions.  The typical values for this parameter range from .1 to 100") {
    $Kl = 1.0 ;
  }

  class default_limiter: public default_rule {
    param<std::string> limiter ;
  public:
    default_limiter() {
      name_store("limiter",limiter) ;
      output("limiter") ;
      comments("Limiter used in face extrapolations.  This function can take the values of 'venkatakrishnan', 'barth', 'none' for second order solutions, and 'zero' for first order solutions") ;
    }
    virtual void compute(const sequence& seq) {
      *limiter = "venkatakrishnan" ;
    }
  } ;
  register_rule<default_limiter> register_default_limiter ;

  class constraint_limiter: public constraint_rule {
    const_param<std::string> limiter ;
    Constraint V_limiter, B_limiter, N_limiter, Z_limiter,NB_limiter ;
    Constraint V2_limiter ;
  public:
    constraint_limiter() {
      name_store("limiter",limiter) ;
      name_store("V_limiter",V_limiter) ;
      name_store("V2_limiter",V2_limiter) ;
      name_store("B_limiter",B_limiter) ;
      name_store("NB_limiter",NB_limiter) ;
      name_store("N_limiter",N_limiter) ;
      name_store("Z_limiter",Z_limiter) ;
      input("limiter") ;
      output("V_limiter,V2_limiter,B_limiter,NB_limiter,N_limiter,Z_limiter") ;
    }
    virtual void compute(const sequence& seq) {
      //      std::cerr << "Setting limiter constraints!" << endl ;
      V_limiter = EMPTY ;
      V2_limiter = EMPTY ;
      B_limiter = EMPTY ;
      NB_limiter = EMPTY ;
      N_limiter = EMPTY ;
      Z_limiter = EMPTY ;
      
      if(*limiter == "venkatakrishnan" || *limiter == "V") {
        V_limiter = ~EMPTY ;
      } else if(*limiter == "V2") {
        V2_limiter = ~EMPTY ;
      } else if(*limiter == "barth" || *limiter == "B") {
        B_limiter = ~EMPTY ;
      } else if(*limiter == "nodalbarth" || *limiter == "NB") {
        NB_limiter = ~EMPTY ;
      } else if(*limiter == "none") {
        N_limiter = ~EMPTY ;
      } else if(*limiter == "zero") {
        Z_limiter = ~EMPTY ;
      } else {
        cerr << "limiter " << *limiter
             << " not supported for generalized grids" << endl ;
        cerr << "defaulting to venkatakrishnan limiter" << endl ;
        V_limiter = ~EMPTY ;
      }
    }
  } ;
  register_rule<constraint_limiter> register_constraint_limiter ;
  

  class limiterv_none : public pointwise_rule {
    const_storeVec<real> X ;
    storeVec<real> limiterv ;
  public:
    limiterv_none() {
      name_store("limiterv(X)",limiterv) ;
      name_store("X",X) ;
      constraint("geom_cells,N_limiter") ;
      input("X") ;
      output("limiterv(X)") ;
    }
    void calculate(Entity cc) {
      limiterv[cc] = mk_Scalar(1.) ;
    }
    virtual void compute(const sequence &seq) {
      limiterv.setVecSize(X.vecSize()) ;
      do_loop(seq,this) ;
    }
  } ;

  class limiterv_zero : public pointwise_rule {
    const_storeVec<real> X ;
    storeVec<real> limiterv ;
  public:
    limiterv_zero() {
      name_store("limiterv(X)",limiterv) ;
      name_store("X",X) ;
      constraint("geom_cells,Z_limiter") ;
      input("X") ;
      output("limiterv(X)") ;
    }
    void calculate(Entity cc) {
      limiterv[cc] = mk_Scalar(0.) ;
    }
    virtual void compute(const sequence &seq) {
      limiterv.setVecSize(X.vecSize()) ;
      do_loop(seq,this) ;
    }
  } ;

  
  // The following is to get the limiter of gradient approach.
  class get_limiterv : public pointwise_rule {
    storeVec<real> limiterv ;
    const_multiMap upper, lower, boundary_map ;
    const_Map cl, cr ;
    const_store<vect3d> cellcenter ;
    const_store<vect3d> facecenter ;
    const_storeVec<real> X, X_f ;
    const_storeVec<vect3d> Xgrad ;
    const_store<char> firstOrderCells ;
  public:
    get_limiterv() ;
    void calculate(Entity cc) ;
    virtual void compute(const sequence &seq) ;
  } ;

  get_limiterv::get_limiterv() {
    name_store("limiterv(X)",limiterv) ;
    name_store("cl",cl) ;
    name_store("cr",cr) ;
    name_store("upper",upper) ;
    name_store("lower",lower) ;
    name_store("boundary_map",boundary_map) ;
    name_store("facecenter",facecenter) ;
    name_store("cellcenter",cellcenter) ;
    name_store("X",X) ;
    name_store("X_f",X_f) ;
    name_store("gradv(X)",Xgrad) ;
    name_store("firstOrderCells",firstOrderCells) ;
    input("firstOrderCells") ;
    constraint("geom_cells,B_limiter") ;
    input("cellcenter,X,gradv(X)") ;
    input("upper->cr->X") ;
    input("upper->facecenter") ;
    input("lower->cl->X") ;
    input("lower->facecenter") ;
    input("boundary_map->X_f") ;
    input("boundary_map->facecenter") ;
    output("limiterv(X)") ;
  }

  void get_limiterv::calculate(Entity cc) {
    const int vs = X.vecSize() ;
    for(int i=0;i<vs;++i) {
      const real Xcc = X[cc][i] ;
      real qmax = Xcc ;
      real qmin = qmax ;
      const vect3d Xgr = Xgrad[cc][i] ;

      for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
        const int fc = *fi ;
        qmin = min(qmin,X[cr[fc]][i]) ;
        qmax = max(qmax,X[cr[fc]][i]) ;
      }
      for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
        const int fc = *fi ;
        qmin = min(qmin,X[cl[fc]][i]) ;
        qmax = max(qmax,X[cl[fc]][i]) ;
      }

      for(const int *fi=boundary_map.begin(cc);fi!=boundary_map.end(cc);++fi) {
        const int fc = *fi ;
        qmin = min(qmin,X_f[fc][i]) ;
        qmax = max(qmax,X_f[fc][i]) ;
      }

      real limi = 1.0 ;
      if(firstOrderCells[cc] != 0)
        limi = 0.0 ;
      for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
        const int fc = *fi ;
        const vect3d drl = facecenter[fc] - cellcenter[cc] ;
        real Xf = Xcc + dot(Xgr,drl) ;
        real qdif = Xf-Xcc ;
        real lim = 1.0 ;
        if(qdif > 0)
          lim = min(real(1.0),(qmax-Xcc)/(qdif+1e-100)) ;
        if(qdif < 0)
          lim = min(real(1.0),(qmin-Xcc)/(qdif-1e-100)) ;
        limi = min (limi,lim) ;
      }
     
      for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
        const int fc = *fi ;
        const vect3d drl = facecenter[fc] - cellcenter[cc] ;
        real Xf = Xcc + dot(Xgr,drl) ;
        real qdif = Xf-Xcc ;
        real lim = 1.0 ;
        if(qdif > 0)
          lim = min(real(1.0),(qmax-Xcc)/(qdif+1e-100)) ;
        if(qdif < 0)
          lim = min(real(1.0),(qmin-Xcc)/(qdif-1e-100)) ;
        limi = min (limi,lim) ;
      }

      for(const int *fi=boundary_map.begin(cc);fi!=boundary_map.end(cc);++fi) {
        const int fc = *fi ;
        const vect3d drl = facecenter[fc] - cellcenter[cc] ;
        real Xf = Xcc + dot(Xgr,drl) ;
        real qdif = Xf-Xcc ;
        real lim = 1.0 ;
        if(qdif > 0)
          lim = min(real(1.0),(qmax-Xcc)/(qdif+1e-100)) ;
        if(qdif < 0)
          lim = min(real(1.0),(qmin-Xcc)/(qdif-1e-100)) ;
        limi = min (limi,lim) ;
      }
      
      limiterv[cc][i] = limi ;
    }
  }

  void get_limiterv::compute(const sequence &seq) {
    limiterv.setVecSize(X.vecSize()) ;
    do_loop(seq,this) ;
  }



  register_rule<limiterv_none> register_limiterv_none ;
  register_rule<limiterv_zero> register_limiterv_zero ;
  register_rule<get_limiterv> register_get_limiterv ;

  // The following is to get the limiter of gradient approach.
  class get_limiter_none_scalar : public pointwise_rule {
    store<real> limiter ;
  public:
    get_limiter_none_scalar() {
      name_store("limiters(X)",limiter) ;
      constraint("geom_cells,N_limiter") ;
      output("limiters(X)") ;
    }
    void calculate(Entity cc) {
      limiter[cc] = 1.0 ;
    }
    virtual void compute(const sequence &seq) {
      do_loop(seq,this) ;
    }
  } ;

  register_rule<get_limiter_none_scalar> register_get_limiter_none_scalar ;

  class get_limiter_zero_scalar : public pointwise_rule {
    store<real> limiter ;
  public:
    get_limiter_zero_scalar() {
      name_store("limiters(X)",limiter) ;
      constraint("geom_cells,Z_limiter") ;
      output("limiters(X)") ;
    }
    void calculate(Entity cc) {
      limiter[cc] = 0. ; 
    }
    virtual void compute(const sequence &seq) {
      do_loop(seq,this) ;
    }
  } ;
  
  register_rule<get_limiter_zero_scalar> register_get_limiter_zero_scalar ;

  class get_limiter_scalar : public pointwise_rule {
    store<real> limiter ;
    const_multiMap upper, lower, boundary_map ;
    const_Map cl, cr ;
    const_store<vect3d> cellcenter ;
    const_store<vect3d> facecenter ;
    const_store<real> X, X_f ;
    const_store<vect3d> Xgrad ;
    const_store<char> firstOrderCells ;
  public:
    get_limiter_scalar() ;
    void calculate(Entity cc) ;
    virtual void compute(const sequence &seq) ;
  } ;

  get_limiter_scalar::get_limiter_scalar() {
    name_store("limiters(X)",limiter) ;
    name_store("cl",cl) ;
    name_store("cr",cr) ;
    name_store("upper",upper) ;
    name_store("lower",lower) ;
    name_store("boundary_map",boundary_map) ;
    name_store("facecenter",facecenter) ;
    name_store("cellcenter",cellcenter) ;
    name_store("X",X) ;
    name_store("X_f",X_f) ;
    name_store("grads(X)",Xgrad) ;
    name_store("firstOrderCells",firstOrderCells) ;
    input("firstOrderCells") ;

    constraint("geom_cells,B_limiter") ;
    input("cellcenter,X,grads(X)") ;
    input("upper->cr->X") ;
    input("upper->facecenter") ;
    input("lower->cl->X") ;
    input("boundary_map->X_f") ;
    input("lower->facecenter") ;
    output("limiters(X)") ;
  }

  void get_limiter_scalar::calculate(Entity cc) {

    const real Xcc = X[cc] ;
    real qmax = Xcc ;
    real qmin = qmax ;
    const vect3d Xgr = Xgrad[cc] ;

    for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
      const int fc = *fi ;
      qmin = min(qmin,X[cr[fc]]) ;
      qmax = max(qmax,X[cr[fc]]) ;
    }
    for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
      const int fc = *fi ;
      qmin = min(qmin,X[cl[fc]]) ;
      qmax = max(qmax,X[cl[fc]]) ;
    }
    for(const int *fi=boundary_map.begin(cc);fi!=boundary_map.end(cc);++fi) {
      const int fc = *fi ;
      qmin = min(qmin,X_f[fc]) ;
      qmax = max(qmax,X_f[fc]) ;
    }

    real limi = 1.0 ;
    if(firstOrderCells[cc] != 0)
      limi = 0.0 ;
    
    for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
      const int fc = *fi ;
      const vect3d drl = facecenter[fc] - cellcenter[cc] ;
      real Xf = Xcc + dot(Xgr,drl) ;
      real qdif = Xf-Xcc ;
      real lim = 1.0 ;
      if(qdif > 0)
        lim = min(real(1.0),(qmax-Xcc)/(qdif+1e-100)) ;
      if(qdif < 0)
        lim = min(real(1.0),(qmin-Xcc)/(qdif-1e-100)) ;
      limi = min (limi,lim) ;
    }
    
    for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
      const int fc = *fi ;
      const vect3d drl = facecenter[fc] - cellcenter[cc] ;
      real Xf = Xcc + dot(Xgr,drl) ;
      real qdif = Xf-Xcc ;
      real lim = 1.0 ;
      if(qdif > 0)
        lim = min(real(1.0),(qmax-Xcc)/(qdif+1e-100)) ;
      if(qdif < 0)
        lim = min(real(1.0),(qmin-Xcc)/(qdif-1e-100)) ;
      limi = min (limi,lim) ;
    }
    
    limiter[cc] = limi ;
  }

  void get_limiter_scalar::compute(const sequence &seq) {
    do_loop(seq,this) ;
  }


  register_rule<get_limiter_scalar> register_get_limiter_scalar ;



  // The following is to get the limiter of gradient approach.
  class get_limiter3d_none : public pointwise_rule {
    store<vect3d> limiter3d ;
  public:
    get_limiter3d_none() {
      name_store("limiterv3d(X)",limiter3d) ;
      constraint("geom_cells,N_limiter") ;
      output("limiterv3d(X)") ;
    }
    void calculate(Entity cc) {
      limiter3d[cc] = vect3d(1.0,1.0,1.0) ;
    }
    virtual void compute(const sequence &seq) {
      do_loop(seq,this) ;
    }
  } ;

  register_rule<get_limiter3d_none> register_get_limiter3d_none ;

  class get_limiter3d_zero : public pointwise_rule {
    store<vect3d> limiter3d ;
  public:
    get_limiter3d_zero() {
      name_store("limiterv3d(X)",limiter3d) ;
      constraint("geom_cells,Z_limiter") ;
      output("limiterv3d(X)") ;
    }
    void calculate(Entity cc) {
      limiter3d[cc] = vect3d(0.,0.,0.) ; 
    }
    virtual void compute(const sequence &seq) {
      do_loop(seq,this) ;
    }
  } ;
  
  register_rule<get_limiter3d_zero> register_get_limiter3d_zero ;

  class get_limiter3d : public pointwise_rule {
    store<vect3d> limiter3d ;
    const_multiMap upper, lower, boundary_map ;
    const_Map cl, cr ;
    const_store<vect3d> cellcenter ;
    const_store<vect3d> facecenter ;
    const_store<vect3d> X, X_f ;
    const_store<tens3d> Xgrad ;
    const_store<char> firstOrderCells ;
  public:
    get_limiter3d() ;
    void calculate(Entity cc) ;
    virtual void compute(const sequence &seq) ;
  } ;

  get_limiter3d::get_limiter3d() {
    name_store("limiterv3d(X)",limiter3d) ;
    name_store("cl",cl) ;
    name_store("cr",cr) ;
    name_store("upper",upper) ;
    name_store("lower",lower) ;
    name_store("boundary_map",boundary_map) ;
    name_store("facecenter",facecenter) ;
    name_store("cellcenter",cellcenter) ;
    name_store("X",X) ;
    name_store("X_f",X_f) ;
    name_store("gradv3d(X)",Xgrad) ;
    name_store("firstOrderCells",firstOrderCells) ;
    input("firstOrderCells") ;

    constraint("geom_cells,B_limiter") ;
    input("cellcenter,X,gradv3d(X)") ;
    input("upper->cr->X") ;
    input("upper->facecenter") ;
    input("lower->cl->X") ;
    input("boundary_map->X_f") ;
    input("lower->facecenter") ;
    output("limiterv3d(X)") ;
  }

  void get_limiter3d::calculate(Entity cc) {

    const vect3d Xcc = X[cc] ;
    vect3d qmax = Xcc ;
    vect3d qmin = qmax ;
    const tens3d Xgr = Xgrad[cc] ;

    for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
      const int fc = *fi ;
      qmin.x = min(qmin.x,X[cr[fc]].x) ;
      qmin.y = min(qmin.y,X[cr[fc]].y) ;
      qmin.z = min(qmin.z,X[cr[fc]].z) ;
      qmax.x = max(qmax.x,X[cr[fc]].x) ;
      qmax.y = max(qmax.y,X[cr[fc]].y) ;
      qmax.z = max(qmax.z,X[cr[fc]].z) ;
    }
    for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
      const int fc = *fi ;
      qmin.x = min(qmin.x,X[cl[fc]].x) ;
      qmin.y = min(qmin.y,X[cl[fc]].y) ;
      qmin.z = min(qmin.z,X[cl[fc]].z) ;
      qmax.x = max(qmax.x,X[cl[fc]].x) ;
      qmax.y = max(qmax.y,X[cl[fc]].y) ;
      qmax.z = max(qmax.z,X[cl[fc]].z) ;
    }
    for(const int *fi=boundary_map.begin(cc);fi!=boundary_map.end(cc);++fi) {
      const int fc = *fi ;
      qmin.x = min(qmin.x,X_f[fc].x) ;
      qmin.y = min(qmin.y,X_f[fc].y) ;
      qmin.z = min(qmin.z,X_f[fc].z) ;
      qmax.x = max(qmax.x,X_f[fc].x) ;
      qmax.y = max(qmax.y,X_f[fc].y) ;
      qmax.z = max(qmax.z,X_f[fc].z) ;
    }

    vect3d limi = vect3d(1.0,1.0,1.0) ;
    if(firstOrderCells[cc] != 0)
      limi = vect3d(0.0,0.0,0.0) ;
    
    for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
      const int fc = *fi ;
      const vect3d drl = facecenter[fc] - cellcenter[cc] ;
      vect3d Xf = Xcc + vect3d(dot(Xgr.x,drl),dot(Xgr.y,drl),dot(Xgr.z,drl)) ;
      vect3d qdif = Xf-Xcc ;
      vect3d lim = vect3d(1.0,1.0,1.0) ;
      if(qdif.x > 0)
        lim.x = min(real(1.0),(qmax.x-Xcc.x)/(qdif.x+1e-100)) ;
      if(qdif.x < 0)
        lim.x = min(real(1.0),(qmin.x-Xcc.x)/(qdif.x-1e-100)) ;
      if(qdif.y > 0)
        lim.y = min(real(1.0),(qmax.y-Xcc.y)/(qdif.y+1e-100)) ;
      if(qdif.y < 0)
        lim.y = min(real(1.0),(qmin.y-Xcc.y)/(qdif.y-1e-100)) ;
      if(qdif.z > 0)
        lim.z = min(real(1.0),(qmax.z-Xcc.z)/(qdif.z+1e-100)) ;
      if(qdif.z < 0)
        lim.z = min(real(1.0),(qmin.z-Xcc.z)/(qdif.z-1e-100)) ;
      limi.x = min (limi.x,lim.x) ;
      limi.y = min (limi.y,lim.y) ;
      limi.z = min (limi.z,lim.z) ;
    }
    
    for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
      const int fc = *fi ;
      const vect3d drl = facecenter[fc] - cellcenter[cc] ;
      vect3d Xf = Xcc + vect3d(dot(Xgr.x,drl),dot(Xgr.y,drl),dot(Xgr.z,drl)) ;
      vect3d qdif = Xf-Xcc ;
      vect3d lim = vect3d(1.0,1.0,1.0) ;
      if(qdif.x > 0)
        lim.x = min(real(1.0),(qmax.x-Xcc.x)/(qdif.x+1e-100)) ;
      if(qdif.x < 0)
        lim.x = min(real(1.0),(qmin.x-Xcc.x)/(qdif.x-1e-100)) ;
      if(qdif.y > 0)
        lim.y = min(real(1.0),(qmax.y-Xcc.y)/(qdif.y+1e-100)) ;
      if(qdif.y < 0)
        lim.y = min(real(1.0),(qmin.y-Xcc.y)/(qdif.y-1e-100)) ;
      if(qdif.z > 0)
        lim.z = min(real(1.0),(qmax.z-Xcc.z)/(qdif.z+1e-100)) ;
      if(qdif.z < 0)
        lim.z = min(real(1.0),(qmin.z-Xcc.z)/(qdif.z-1e-100)) ;
      limi.x = min (limi.x,lim.x) ;
      limi.y = min (limi.y,lim.y) ;
      limi.z = min (limi.z,lim.z) ;
    }
    
    limiter3d[cc] = limi ;
  }

  void get_limiter3d::compute(const sequence &seq) {
    do_loop(seq,this) ;
  }


  register_rule<get_limiter3d> register_get_limiter3d ;


    class periodic_limiters : public pointwise_rule {
    store<real_t> limiters ;
    const_Map pmap,cl,cr ;
  public:
    periodic_limiters() {
      name_store("limiters(X)",limiters) ;
      name_store("pmap",pmap) ;
      name_store("cl",cl) ;
      name_store("cr",cr) ;
      input("pmap->cl->limiters(X)") ;
      output("cr->limiters(X)") ;
      constraint("periodicFaces,cl->X") ;
    }
    void calculate(Entity pf) {
      limiters[cr[pf]] = limiters[cl[pmap[pf]]] ;
    }
    void compute(const sequence &seq) {
      do_loop(seq,this) ;
    }
  } ;

  register_rule<periodic_limiters> periodic_limiters ;

  class periodic_limiterv : public pointwise_rule {
    storeVec<real_t > limiterv ;
    const_Map pmap,cl,cr ;
  public:
    periodic_limiterv() {
      name_store("limiterv(X)",limiterv) ;
      name_store("pmap",pmap) ;
      name_store("cl",cl) ;
      name_store("cr",cr) ;
      input("pmap->cl->limiterv(X)") ;
      output("cr->limiterv(X)") ;
      constraint("periodicFaces,cl->X") ;
    }
    void calculate(Entity pf) {
      for(int i=0;i<limiterv.vecSize();++i)
        limiterv[cr[pf]][i] = limiterv[cl[pmap[pf]]][i] ;
    }
    void compute(const sequence &seq) {
      do_loop(seq,this) ;
    }
  } ;


  register_rule<periodic_limiterv> periodic_limiterv ;

  class periodic_limiterv3d : public pointwise_rule {
    store<vector3d<real_t> > limiterv3d ;
    const_Map pmap,cl,cr ;
  public:
    periodic_limiterv3d() {
      name_store("limiterv3d(X)",limiterv3d) ;
      name_store("pmap",pmap) ;
      name_store("cl",cl) ;
      name_store("cr",cr) ;
      input("pmap->cl->limiterv3d(X)") ;
      output("cr->limiterv3d(X)") ;
      constraint("periodicFaces,cl->X") ;
    }
    void calculate(Entity pf) {
      limiterv3d[cr[pf]] = limiterv3d[cl[pmap[pf]]] ;
    }
    void compute(const sequence &seq) {
      do_loop(seq,this) ;
    }
  } ;

  register_rule<periodic_limiterv3d> periodic_limiterv3d ;


  // Nodal Barth Limiter
  $type NGTNodalMax(X) store<real_t> ;
  $type NGTNodalMin(X) store<real_t> ;
  $type X store<real_t> ;
  $type X_f store<real_t> ;

  using std::max ;
  using std::min ;
  using std::cout ;
  
  $rule unit(NGTNodalMax(X)), constraint(pos) {
    $NGTNodalMax(X) = std::numeric_limits<real_t>::min() ;
  }
  $rule apply(face2node->NGTNodalMax(X)<-cl->X)[Loci::Maximum] {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$NGTNodalMax(X),$cl->$X) ;
  }
  $rule apply(face2node->NGTNodalMax(X)<-cr->X)[Loci::Maximum] {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$NGTNodalMax(X),$cr->$X) ;
  }
  $rule apply(face2node->NGTNodalMax(X)<-X_f)[Loci::Maximum],constraint(ci->X) {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$NGTNodalMax(X),$X_f) ;
  }

  $rule unit(NGTNodalMin(X)), constraint(pos) {
    $NGTNodalMin(X) = std::numeric_limits<real_t>::max() ;
  }
  $rule apply(face2node->NGTNodalMin(X)<-cl->X)[Loci::Minimum] {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$NGTNodalMin(X),$cl->$X) ;
  }
  $rule apply(face2node->NGTNodalMin(X)<-cr->X)[Loci::Minimum] {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$NGTNodalMin(X),$cr->$X) ;
  }
  $rule apply(face2node->NGTNodalMin(X)<-X_f)[Loci::Minimum],constraint(ci->X) {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$NGTNodalMin(X),$X_f) ;
  }

  $type NGTNodalv3dMax(X) store<vector3d<real_t> > ;
  $type NGTNodalv3dMin(X) store<vector3d<real_t> > ;
  $type X store<vector3d<real_t> > ;
  $type X_f store<vector3d<real_t> > ;

  inline vector3d<real_t> max(const vector3d<real_t> &v1,
                              const vector3d<real_t> &v2) {
    return vector3d<real_t>(std::max(v1.x,v2.x),
                            std::max(v1.y,v2.y),
                            std::max(v1.z,v2.z)) ;
  }

  inline vector3d<real_t> min(const vector3d<real_t> &v1,
                              const vector3d<real_t> &v2) {
    return vector3d<real_t>(std::min(v1.x,v2.x),
                            std::min(v1.y,v2.y),
                            std::min(v1.z,v2.z)) ;
  }
  

  $rule unit(NGTNodalv3dMax(X)), constraint(pos) {
    const real_t mn = std::numeric_limits<real_t>::min() ;
    $NGTNodalv3dMax(X) = vector3d<real_t>(mn,mn,mn) ;
  }
  $rule apply(face2node->NGTNodalv3dMax(X)<-cl->X)[Loci::Maximum] {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$NGTNodalv3dMax(X),$cl->$X) ;
  }
  $rule apply(face2node->NGTNodalv3dMax(X)<-cr->X)[Loci::Maximum] {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$NGTNodalv3dMax(X),$cr->$X) ;
  }
  $rule apply(face2node->NGTNodalv3dMax(X)<-X_f)[Loci::Maximum],constraint(ci->X) {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$NGTNodalv3dMax(X),$X_f) ;
  }

  $rule unit(NGTNodalv3dMin(X)), constraint(pos) {
    const real_t mx = std::numeric_limits<real_t>::max() ;
    $NGTNodalv3dMin(X) = vector3d<real_t>(mx,mx,mx) ;
  }
  $rule apply(face2node->NGTNodalv3dMin(X)<-cl->X)[Loci::Minimum] {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$NGTNodalv3dMin(X),$cl->$X) ;
  }
  $rule apply(face2node->NGTNodalv3dMin(X)<-cr->X)[Loci::Minimum] {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$NGTNodalv3dMin(X),$cr->$X) ;
  }
  $rule apply(face2node->NGTNodalv3dMin(X)<-X_f)[Loci::Minimum],constraint(ci->X) {
    int nsz = $face2node.size() ;
    for(int i=0;i<nsz;++i)
      join($face2node[i]->$NGTNodalv3dMin(X),$X_f) ;
  }



  $type NGTNodalvMax(X) storeVec<real_t> ;
  $type NGTNodalvMin(X) storeVec<real_t> ;
  $type X storeVec<real_t> ;
  $type X_f storeVec<real_t> ;
  $type vecSize(X) param<int> ;


  $rule unit(NGTNodalvMax(X)<-vecSize(X)), constraint(pos), prelude {
    $NGTNodalvMax(X).setVecSize(*$vecSize(X)) ;
  } compute {
    $NGTNodalvMax(X) = mk_Scalar(std::numeric_limits<real_t>::min()) ;
  }
  $rule apply(face2node->NGTNodalvMax(X)<-cl->X)[Loci::Maximum] {
    const int sz = $face2node.size() ;
    for(int i=0;i<sz;++i)
      join($face2node[i]->$NGTNodalvMax(X),$cl->$X) ;
  }
  $rule apply(face2node->NGTNodalvMax(X)<-cr->X)[Loci::Maximum] {
    const int sz = $face2node.size() ;
    for(int i=0;i<sz;++i)
      join($face2node[i]->$NGTNodalvMax(X),$cr->$X) ;
  }
  $rule apply(face2node->NGTNodalvMax(X)<-X_f)[Loci::Maximum],
    constraint(ci->X) {
    const int sz = $face2node.size() ;
    for(int i=0;i<sz;++i)
      join($face2node[i]->$NGTNodalvMax(X),$X_f) ;
  }

  $rule unit(NGTNodalvMin(X)<-vecSize(X)), constraint(pos), prelude {
    $NGTNodalvMin(X).setVecSize(*$vecSize(X)) ;
  } compute {
    $NGTNodalvMin(X) = mk_Scalar(std::numeric_limits<real_t>::max()) ;
  }
  $rule apply(face2node->NGTNodalvMin(X)<-cl->X)[Loci::Minimum] {
    const int sz = $face2node.size() ;
    for(int i=0;i<sz;++i)
      join($face2node[i]->$NGTNodalvMin(X),$cl->$X) ;
  }
  $rule apply(face2node->NGTNodalvMin(X)<-cr->X)[Loci::Minimum] {
    const int sz = $face2node.size() ;
    for(int i=0;i<sz;++i)
      join($face2node[i]->$NGTNodalvMin(X),$cr->$X) ;
  }
  $rule apply(face2node->NGTNodalvMin(X)<-X_f)[Loci::Minimum],
    constraint(ci->X) {
    const int sz = $face2node.size() ;
    for(int i=0;i<sz;++i)
      join($face2node[i]->$NGTNodalvMin(X),$X_f) ;
  }

  class nodal_barth_scalar : public pointwise_rule {

    store<real> limiter ;
    const_multiMap upper, lower, boundary_map ;
    const_multiMap face2node ;
    const_store<real> X ;
    const_store<vect3d> pos,cellcenter ;
    const_store<real> nodMax,nodMin ;
    const_store<vect3d> Xgrad ;
    const_store<char> firstOrderCells ;
  public:
    nodal_barth_scalar() ;
    void calculate(Entity cc) ;
    virtual void compute(const sequence &seq) ;
  } ;

  nodal_barth_scalar::nodal_barth_scalar() {
    name_store("limiters(X)",limiter) ;
    name_store("upper",upper) ;
    name_store("lower",lower) ;
    name_store("boundary_map",boundary_map) ;
    name_store("cellcenter",cellcenter) ;
    name_store("face2node",face2node) ;
    name_store("pos",pos) ;
    name_store("X",X) ;
    name_store("NGTNodalMax(X)",nodMax) ;
    name_store("NGTNodalMin(X)",nodMin) ;
    name_store("grads(X)",Xgrad) ;
    name_store("firstOrderCells",firstOrderCells) ;
    input("firstOrderCells") ;

    constraint("geom_cells,NB_limiter") ;
    input("cellcenter,X,grads(X)") ;
    input("upper->face2node->(pos,NGTNodalMax(X),NGTNodalMin(X))") ;
    input("lower->face2node->(pos,NGTNodalMax(X),NGTNodalMin(X))") ;
    input("boundary_map->face2node->(pos,NGTNodalMax(X),NGTNodalMin(X))") ;
    output("limiters(X)") ;
  }

  void nodal_barth_scalar::calculate(Entity cc) {

    const real Xcc = X[cc] ;
    const vect3d Xgr = Xgrad[cc] ;
    const vect3d cent = cellcenter[cc] ;
    real lim = 1.0 ;
    if(firstOrderCells[cc] != 0)
      lim = 0 ;
    
    for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
      const int fc = *fi ;
      int fsz = face2node[fc].size() ;
      for(int i=0;i<fsz;++i) {
        const int nd = face2node[fc][i] ;
        const vect3d drl = pos[nd] - cent ;
        real Xf = Xcc + dot(Xgr,drl) ;
        real qdif = Xf-Xcc ;
        if(qdif > 0)
          lim = min(lim,(nodMax[nd]-Xcc)/(qdif+1e-100)) ;
        if(qdif < 0)
          lim = min(lim,(nodMin[nd]-Xcc)/(qdif-1e-100)) ;
      }
    }
    
    for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
      const int fc = *fi ;
      int fsz = face2node[fc].size() ;
      for(int i=0;i<fsz;++i) {
        const int nd = face2node[fc][i] ;
        const vect3d drl = pos[nd] - cent ;
        real Xf = Xcc + dot(Xgr,drl) ;
        real qdif = Xf-Xcc ;
        if(qdif > 0)
          lim = min(lim,(nodMax[nd]-Xcc)/(qdif+1e-100)) ;
        if(qdif < 0)
          lim = min(lim,(nodMin[nd]-Xcc)/(qdif-1e-100)) ;
      }
    }    
    limiter[cc] = lim ;
  }

  void nodal_barth_scalar::compute(const sequence &seq) {
    do_loop(seq,this) ;
  }


  register_rule<nodal_barth_scalar> register_nodal_barth_scalar ;

  class nodal_barth_3d : public pointwise_rule {
    store<vect3d> limiter3d ;
    const_multiMap upper, lower, boundary_map ;
    const_multiMap face2node ;
    const_store<vect3d> cellcenter ;
    const_store<vect3d> pos ;
    const_store<vect3d> nodMax,nodMin ;
    const_store<vect3d> X ;
    const_store<tens3d> Xgrad ;
    const_store<char> firstOrderCells ;
  public:
    nodal_barth_3d() ;
    void calculate(Entity cc) ;
    virtual void compute(const sequence &seq) ;
  } ;

  nodal_barth_3d::nodal_barth_3d() {
    name_store("limiterv3d(X)",limiter3d) ;
    name_store("upper",upper) ;
    name_store("lower",lower) ;
    name_store("boundary_map",boundary_map) ;
    name_store("cellcenter",cellcenter) ;
    name_store("face2node",face2node) ;
    name_store("pos",pos) ;
    name_store("NGTNodalv3dMax(X)",nodMax) ;
    name_store("NGTNodalv3dMin(X)",nodMin) ;
    name_store("X",X) ;
    name_store("gradv3d(X)",Xgrad) ;
    name_store("firstOrderCells",firstOrderCells) ;
    input("firstOrderCells") ;

    constraint("geom_cells,NB_limiter") ;
    input("cellcenter,X,gradv3d(X)") ;
    input("upper->face2node->(pos,NGTNodalv3dMax(X),NGTNodalv3dMin(X))") ;
    input("lower->face2node->(pos,NGTNodalv3dMax(X),NGTNodalv3dMin(X))") ;
    input("boundary_map->face2node->(pos,NGTNodalv3dMax(X),NGTNodalv3dMin(X))") ;

    output("limiterv3d(X)") ;
  }

  void nodal_barth_3d::calculate(Entity cc) {

    const vect3d Xcc = X[cc] ;
    const tens3d Xgr = Xgrad[cc] ;
    const vect3d cent = cellcenter[cc] ;

    vect3d lim = vect3d(1.0,1.0,1.0) ;
    if(firstOrderCells[cc] != 0)
      lim = vect3d(0.0,0.0,0.0) ;
    for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
      const int fc = *fi ;
      int fsz = face2node[fc].size() ;
      for(int i=0;i<fsz;++i) {
        const int nd = face2node[fc][i] ;
        const vect3d drl = pos[nd] - cent ;
        vect3d Xf = Xcc + vect3d(dot(Xgr.x,drl),dot(Xgr.y,drl),dot(Xgr.z,drl)) ;
        vect3d qdif = Xf-Xcc ;
        if(qdif.x > 0)
          lim.x = min(lim.x,(nodMax[nd].x-Xcc.x)/(qdif.x+1e-100)) ;
        if(qdif.x < 0)
          lim.x = min(lim.x,(nodMin[nd].x-Xcc.x)/(qdif.x-1e-100)) ;
        if(qdif.y > 0)
          lim.y = min(lim.y,(nodMax[nd].y-Xcc.y)/(qdif.y+1e-100)) ;
        if(qdif.y < 0)
          lim.y = min(lim.y,(nodMin[nd].y-Xcc.y)/(qdif.y-1e-100)) ;
        if(qdif.z > 0)
          lim.z = min(lim.z,(nodMax[nd].z-Xcc.z)/(qdif.z+1e-100)) ;
        if(qdif.z < 0)
          lim.z = min(lim.z,(nodMin[nd].z-Xcc.z)/(qdif.z-1e-100)) ;
      }
    }
    
    for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
      const int fc = *fi ;
      int fsz = face2node[fc].size() ;
      for(int i=0;i<fsz;++i) {
        const int nd = face2node[fc][i] ;
        const vect3d drl = pos[nd] - cent ;
        vect3d Xf = Xcc + vect3d(dot(Xgr.x,drl),dot(Xgr.y,drl),dot(Xgr.z,drl)) ;
        vect3d qdif = Xf-Xcc ;
        if(qdif.x > 0)
          lim.x = min(lim.x,(nodMax[nd].x-Xcc.x)/(qdif.x+1e-100)) ;
        if(qdif.x < 0)
          lim.x = min(lim.x,(nodMin[nd].x-Xcc.x)/(qdif.x-1e-100)) ;
        if(qdif.y > 0)
          lim.y = min(lim.y,(nodMax[nd].y-Xcc.y)/(qdif.y+1e-100)) ;
        if(qdif.y < 0)
          lim.y = min(lim.y,(nodMin[nd].y-Xcc.y)/(qdif.y-1e-100)) ;
        if(qdif.z > 0)
          lim.z = min(lim.z,(nodMax[nd].z-Xcc.z)/(qdif.z+1e-100)) ;
        if(qdif.z < 0)
          lim.z = min(lim.z,(nodMin[nd].z-Xcc.z)/(qdif.z-1e-100)) ;
      }
    }
    
    limiter3d[cc] = lim ;
  }

  void nodal_barth_3d::compute(const sequence &seq) {
    do_loop(seq,this) ;
  }


  register_rule<nodal_barth_3d> register_nodal_barth_3d ;

  class nodal_barth_vec : public pointwise_rule {
    storeVec<real> limiterv ;
    const_multiMap upper, lower, boundary_map ;
    const_Map cl, cr ;
    const_store<vect3d> cellcenter ;
    const_store<vect3d> facecenter ;
    const_storeVec<real> X, X_f ;
    const_storeVec<vect3d> Xgrad ;
    const_store<char> firstOrderCells ;
  public:
    nodal_barth_vec() ;
    void calculate(Entity cc) ;
    virtual void compute(const sequence &seq) ;
  } ;

  nodal_barth_vec::nodal_barth_vec() {
    name_store("limiterv(X)",limiterv) ;
    name_store("cl",cl) ;
    name_store("cr",cr) ;
    name_store("upper",upper) ;
    name_store("lower",lower) ;
    name_store("boundary_map",boundary_map) ;
    name_store("facecenter",facecenter) ;
    name_store("cellcenter",cellcenter) ;
    name_store("X",X) ;
    name_store("X_f",X_f) ;
    name_store("gradv(X)",Xgrad) ;
    name_store("firstOrderCells",firstOrderCells) ;
    input("firstOrderCells") ;

    constraint("geom_cells,NB_limiter") ;
    input("cellcenter,X,gradv(X)") ;
    input("upper->cr->X") ;
    input("upper->facecenter") ;
    input("lower->cl->X") ;
    input("lower->facecenter") ;
    input("boundary_map->X_f") ;
    input("boundary_map->facecenter") ;
    output("limiterv(X)") ;
  }

  void nodal_barth_vec::calculate(Entity cc) {
    const int vs = X.vecSize() ;
    for(int i=0;i<vs;++i) {
      const real Xcc = X[cc][i] ;
      real qmax = Xcc ;
      real qmin = qmax ;
      const vect3d Xgr = Xgrad[cc][i] ;

      for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
        const int fc = *fi ;
        qmin = min(qmin,X[cr[fc]][i]) ;
        qmax = max(qmax,X[cr[fc]][i]) ;
      }
      for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
        const int fc = *fi ;
        qmin = min(qmin,X[cl[fc]][i]) ;
        qmax = max(qmax,X[cl[fc]][i]) ;
      }

      for(const int *fi=boundary_map.begin(cc);fi!=boundary_map.end(cc);++fi) {
        const int fc = *fi ;
        qmin = min(qmin,X_f[fc][i]) ;
        qmax = max(qmax,X_f[fc][i]) ;
      }

      real limi = 1.0 ;
      if(firstOrderCells[cc] != 0)
        limi = 0.0 ;
      for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
        const int fc = *fi ;
        const vect3d drl = facecenter[fc] - cellcenter[cc] ;
        real Xf = Xcc + dot(Xgr,drl) ;
        real qdif = Xf-Xcc ;
        real lim = 1.0 ;
        if(qdif > 0)
          lim = min(real(1.0),(qmax-Xcc)/(qdif+1e-100)) ;
        if(qdif < 0)
          lim = min(real(1.0),(qmin-Xcc)/(qdif-1e-100)) ;
        limi = min (limi,lim) ;
      }
     
      for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
        const int fc = *fi ;
        const vect3d drl = facecenter[fc] - cellcenter[cc] ;
        real Xf = Xcc + dot(Xgr,drl) ;
        real qdif = Xf-Xcc ;
        real lim = 1.0 ;
        if(qdif > 0)
          lim = min(real(1.0),(qmax-Xcc)/(qdif+1e-100)) ;
        if(qdif < 0)
          lim = min(real(1.0),(qmin-Xcc)/(qdif-1e-100)) ;
        limi = min (limi,lim) ;
      }

      for(const int *fi=boundary_map.begin(cc);fi!=boundary_map.end(cc);++fi) {
        const int fc = *fi ;
        const vect3d drl = facecenter[fc] - cellcenter[cc] ;
        real Xf = Xcc + dot(Xgr,drl) ;
        real qdif = Xf-Xcc ;
        real lim = 1.0 ;
        if(qdif > 0)
          lim = min(real(1.0),(qmax-Xcc)/(qdif+1e-100)) ;
        if(qdif < 0)
          lim = min(real(1.0),(qmin-Xcc)/(qdif-1e-100)) ;
        limi = min (limi,lim) ;
      }
      
      limiterv[cc][i] = limi ;
    }
  }

  void nodal_barth_vec::compute(const sequence &seq) {
    limiterv.setVecSize(X.vecSize()) ;
    do_loop(seq,this) ;
  }

  register_rule<nodal_barth_vec> register_nodal_barth_vec ;


  inline real vlimit(real Xcc, real qmin, real qmax, real qdif, real eps2,
		     real ref) {
#ifdef REFLIM
    // old way of preventing div zero errors
    if(fabs(qdif)<=ref*1e-4) return 1.0 ;
#endif
    // delta +
    const real delp = (qdif>0.0)?qmin-Xcc:qmax-Xcc;
    // delta -
    const real delm = -qdif ;
    // numerator of limiter
    const real num = ((delp*delp+eps2)*delm+ 2.0*delm*delm*delp)  ;
    // denominator of limiter
    const real den = (delm*(delp*delp+2.0*delm*delm+delm*delp+eps2)) ;
    // make the limiting case of 0/0 work as expected
    const real e = (den >= 0.0?1.0e-30:-1.0e-30) ;
    return (num+e)/(den+e) ;
  }
    
  // The following is another way to get the limiter of gradient approach.
  class limiter_mixture_V : public pointwise_rule {
    storeVec<real> limiterv ;
    const_store<real> vol ;
    const_multiMap upper,lower,boundary_map ;
    const_Map cl, cr ;
    const_store<vect3d> cellcenter ;
    const_store<vect3d> facecenter ;
    const_storeVec<real> X, X_f ;
    const_storeVec<vect3d> Xgrad ;
    const_param<real> Kl ;
    const_param<real> grid_vol ;
    const_store<char> firstOrderCells ;
    real Kl3 ;
  public:
    limiter_mixture_V() ;
    void calculate(Entity cc) ;
    virtual void compute(const sequence &seq) ;
  } ;

  limiter_mixture_V::limiter_mixture_V() {
    name_store("Kl",Kl) ;
    name_store("vol",vol) ;
    name_store("limiterv(X)",limiterv) ;
    name_store("cl",cl) ;
    name_store("cr",cr) ;
    name_store("upper",upper) ;
    name_store("lower",lower) ;
    name_store("boundary_map",boundary_map) ;
    name_store("facecenter",facecenter) ;
    name_store("cellcenter",cellcenter) ;
    name_store("X",X) ;
    name_store("X_f",X_f) ;
    name_store("gradv(X)",Xgrad) ;
    name_store("grid_vol",grid_vol) ;
    name_store("firstOrderCells",firstOrderCells) ;
    input("firstOrderCells") ;
    
    constraint("geom_cells,V_limiter") ;
    input("Kl,grid_vol") ;
    input("cellcenter,X,gradv(X),vol") ;
    input("upper->cr->X") ;
    input("upper->facecenter") ;
    input("lower->cl->X") ;
    input("lower->facecenter") ;
    input("boundary_map->X_f") ;
    output("limiterv(X)") ;
  }

  void limiter_mixture_V::calculate(Entity cc) {
    const vect3d &cctr = cellcenter[cc] ;
    real ref = 0.0 ;
    const int vs = X.vecSize() ;
    
    for(int i=0;i<vs;++i)
      ref += fabs(X[cc][i]) ;
    ref = max(ref,real_t(1e-5)) ;

    const real refsq = ref*ref ;
    for(int i=0;i<vs;++i) {
      const real &Xcc = X[cc][i] ;
      real qmax = Xcc ;
      real qmin = qmax ;
      const vect3d &Xgr = Xgrad[cc][i] ;
      // Epsilon squared is equal to (Kl D)^3 where D is the diameter of
      // a sphere with the same volume as the given cell.
      const real epsilon2 = Kl3*vol[cc]*refsq ;
      
      for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
        const int fc = *fi ;
        qmin = min(qmin,X[cr[fc]][i]) ;
        qmax = max(qmax,X[cr[fc]][i]) ;
      }
      for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
        const int fc = *fi ;
        qmin = min(qmin,X[cl[fc]][i]) ;
        qmax = max(qmax,X[cl[fc]][i]) ;
      }
      for(const int *fi=boundary_map.begin(cc);fi!=boundary_map.end(cc);++fi) {
        const int fc = *fi ;
        qmin = min(qmin,X_f[fc][i]) ;
        qmax = max(qmax,X_f[fc][i]) ;
      }
      real limi = 1.0 ;
      if(firstOrderCells[cc] != 0)
        limi = 0.0 ;
      
      for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
        const int fc = *fi ;
        real Xf = Xcc + dot(Xgr,(facecenter[fc]-cctr)) ;
        real qdif = Xcc -Xf ;
        limi = min(limi,vlimit(Xcc,qmin,qmax,qdif,epsilon2,ref)) ;
      }
      for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
        const int fc = *fi ;
        real Xf = Xcc + dot(Xgr,(facecenter[fc]-cctr)) ;
        real qdif = Xcc -Xf ;
        limi = min(limi,vlimit(Xcc,qmin,qmax,qdif,epsilon2,ref)) ;
      }
      limiterv[cc][i] = limi ;
    }
  }

  const double pi = M_PI ;

  void limiter_mixture_V::compute(const sequence &seq) {
    Kl3 = (*Kl)*(*Kl)*(*Kl)*6./pi/(*grid_vol) ;
    limiterv.setVecSize(X.vecSize()) ;
    do_loop(seq,this) ;
  }
  
  register_rule<limiter_mixture_V> register_limiter_mixture_V ;
  
  // The following is another way to get the limiter of gradient approach.
  class limiter_scalar_V : public pointwise_rule {
    store<real> grad_limiter ;
    const_store<real> vol ;
    const_multiMap upper,lower,boundary_map ;
    const_Map cl, cr ;
    const_store<vect3d> cellcenter ;
    const_store<vect3d> facecenter ;
    const_store<real> X, X_f ;
    const_store<vect3d> Xgrad ;
    const_param<real> Kl ;
    const_param<real> grid_vol ;
    const_store<char> firstOrderCells ;
    real Kl3 ;
  public:
    limiter_scalar_V() ;
    void calculate(Entity cc) ;
    virtual void compute(const sequence &seq) ;
  } ;

  limiter_scalar_V::limiter_scalar_V() {
    name_store("Kl",Kl) ;
    name_store("vol",vol) ;
    name_store("limiters(X)",grad_limiter) ;
    name_store("cl",cl) ;
    name_store("cr",cr) ;
    name_store("upper",upper) ;
    name_store("lower",lower) ;
    name_store("boundary_map",boundary_map) ;
    name_store("facecenter",facecenter) ;
    name_store("cellcenter",cellcenter) ;
    name_store("X",X) ;
    name_store("X_f",X_f) ;
    name_store("grads(X)",Xgrad) ;
    name_store("grid_vol",grid_vol) ;
    name_store("firstOrderCells",firstOrderCells) ;
    input("firstOrderCells") ;
    
    constraint("geom_cells,V_limiter") ;
    input("Kl,grid_vol") ;
    input("cellcenter,X,grads(X),vol") ;
    input("upper->cr->X") ;
    input("upper->facecenter") ;
    input("lower->cl->X") ;
    input("lower->facecenter") ;
    input("boundary_map->X_f") ;
    output("limiters(X)") ;
  }

  void limiter_scalar_V::calculate(Entity cc) {
    const vect3d &cctr = cellcenter[cc] ;

    real refsq = X[cc]*X[cc] ;
    int numrefs = 1 ;

    const real &Xcc = X[cc] ;
    real qmax = Xcc ;
    real qmin = qmax ;
    const vect3d &Xgr = Xgrad[cc];
    // Epsilon squared is equal to (Kl D)^3 where D is the diameter of
    // a sphere with the same volume as the given cell.
      
    for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
      const int fc = *fi ;
      const real Xr = X[cr[fc]] ;
      qmin = min(qmin,Xr) ;
      qmax = max(qmax,Xr) ;
      refsq += Xr*Xr ;
      numrefs++ ;
    }
    for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
      const int fc = *fi ;
      const real Xl = X[cl[fc]] ;
      qmin = min(qmin,Xl) ;
      qmax = max(qmax,Xl) ;
      refsq += Xl*Xl ;
      numrefs++ ;
    }
    for(const int *fi=boundary_map.begin(cc);fi!=boundary_map.end(cc);++fi) {
      const int fc = *fi ;
      const real Xf = X_f[fc] ;
      qmin = min(qmin,Xf) ;
      qmax = max(qmax,Xf) ;
      refsq += Xf*Xf ;
      numrefs++ ;
    }
    const real ref = 1e-20+sqrt(refsq)/numrefs ;
     
    const real epsilon2 = Kl3*vol[cc]*ref*ref ;
    real limi = 1.0 ;
    if(firstOrderCells[cc] != 0)
      limi=0.0 ;
    
    for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
      const int fc = *fi ;
      real Xf = Xcc + dot(Xgr,(facecenter[fc]-cctr)) ;
      real qdif = Xcc -Xf ;
      limi = min(limi,vlimit(Xcc,qmin,qmax,qdif,epsilon2,ref)) ;
    }
    for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
      const int fc = *fi ;
      real Xf = Xcc + dot(Xgr,(facecenter[fc]-cctr)) ;
      real qdif = Xcc -Xf ;
      limi = min(limi,vlimit(Xcc,qmin,qmax,qdif,epsilon2,ref)) ;
    }
    grad_limiter[cc] = limi ;
  }

  void limiter_scalar_V::compute(const sequence &seq) {
    Kl3 = (*Kl)*(*Kl)*(*Kl)*6./pi/(*grid_vol) ;
    do_loop(seq,this) ;
  }

  register_rule<limiter_scalar_V> register_limiter_scalar_V ;
  
  // The following is another way to get the limiter3d of gradient approach.
  class limiter_v3d_V : public pointwise_rule {
    store<vect3d> grad_limiter3d ;
    const_store<real> vol ;
    const_multiMap upper,lower,boundary_map ;
    const_Map cl, cr ;
    const_store<vect3d> cellcenter ;
    const_store<vect3d> facecenter ;
    const_store<vect3d> X, X_f ;
    const_store<tens3d> Xgrad ;
    const_param<real> Kl ;
    const_param<real> grid_vol ;
    const_store<char> firstOrderCells ;
    real Kl3 ;
  public:
    limiter_v3d_V() ;
    void calculate(Entity cc) ;
    virtual void compute(const sequence &seq) ;
  } ;

  limiter_v3d_V::limiter_v3d_V() {
    name_store("Kl",Kl) ;
    name_store("vol",vol) ;
    name_store("limiterv3d(X)",grad_limiter3d) ;
    name_store("cl",cl) ;
    name_store("cr",cr) ;
    name_store("upper",upper) ;
    name_store("lower",lower) ;
    name_store("boundary_map",boundary_map) ;
    name_store("facecenter",facecenter) ;
    name_store("cellcenter",cellcenter) ;
    name_store("X",X) ;
    name_store("X_f",X_f) ;
    name_store("gradv3d(X)",Xgrad) ;
    name_store("grid_vol",grid_vol) ;
    name_store("firstOrderCells",firstOrderCells) ;
    input("firstOrderCells") ;
    
    constraint("geom_cells,V_limiter") ;
    input("Kl,grid_vol") ;
    input("cellcenter,X,gradv3d(X),vol") ;
    input("upper->cr->X") ;
    input("upper->facecenter") ;
    input("lower->cl->X") ;
    input("lower->facecenter") ;
    input("boundary_map->X_f") ;
    output("limiterv3d(X)") ;
  }

  void limiter_v3d_V::calculate(Entity cc) {
    real refsq = dot(X[cc],X[cc]) ;
    int numrefs = 1 ;

    const vect3d Xcc = X[cc] ;
    vect3d qmax = Xcc ;
    vect3d qmin = qmax ;
    const tens3d &Xgr = Xgrad[cc];
    // Epsilon squared is equal to (Kl D)^3 where D is the diameter of
    // a sphere with the same volume as the given cell.
      
    for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
      const Entity fc = *fi ;
      const vect3d Xr = X[cr[fc]] ;
      qmin.x = min(qmin.x,Xr.x) ;
      qmin.y = min(qmin.y,Xr.y) ;
      qmin.z = min(qmin.z,Xr.z) ;
      qmax.x = max(qmax.x,Xr.x) ;
      qmax.y = max(qmax.y,Xr.y) ;
      qmax.z = max(qmax.z,Xr.z) ;
      refsq += dot(Xr,Xr) ;
      numrefs++ ;
    }
    for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
      const Entity fc = *fi ;
      const vect3d Xl = X[cl[fc]] ;
      qmin.x = min(qmin.x,Xl.x) ;
      qmin.y = min(qmin.y,Xl.y) ;
      qmin.z = min(qmin.z,Xl.z) ;
      qmax.x = max(qmax.x,Xl.x) ;
      qmax.y = max(qmax.y,Xl.y) ;
      qmax.z = max(qmax.z,Xl.z) ;
      refsq += dot(Xl,Xl) ;
      numrefs++ ;
    }
    for(const int *fi=boundary_map.begin(cc);fi!=boundary_map.end(cc);++fi) {
      const int fc = *fi ;
      const vect3d Xf = X_f[fc] ;
      qmin.x = min(qmin.x,Xf.x) ;
      qmin.y = min(qmin.y,Xf.y) ;
      qmin.z = min(qmin.z,Xf.z) ;
      qmax.x = max(qmax.x,Xf.x) ;
      qmax.y = max(qmax.y,Xf.y) ;
      qmax.z = max(qmax.z,Xf.z) ;
      refsq += dot(Xf,Xf) ;
      numrefs++ ;
    }
    const real ref = 1e-20+sqrt(refsq)/numrefs ;
     
    const real epsilon2 = Kl3*vol[cc]*ref*ref ;
    vect3d limi = vect3d(1.0,1.0,1.0) ;
    if(firstOrderCells[cc] != 0)
      limi = vect3d(0.0,0.0,0.0) ;
    
    for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
      const int fc = *fi ;
      const vect3d drl = facecenter[fc] - cellcenter[cc] ;
      vect3d Xf = Xcc + vect3d(dot(Xgr.x,drl),dot(Xgr.y,drl),dot(Xgr.z,drl)) ;
      vect3d qdif = Xcc -Xf ;

      limi.x = min(limi.x,vlimit(Xcc.x,qmin.x,qmax.x,qdif.x,epsilon2,ref)) ;
      limi.y = min(limi.y,vlimit(Xcc.y,qmin.y,qmax.y,qdif.y,epsilon2,ref)) ;
      limi.z = min(limi.z,vlimit(Xcc.z,qmin.z,qmax.z,qdif.z,epsilon2,ref)) ;
    }
    for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
      const int fc = *fi ;
      const vect3d drl = facecenter[fc] - cellcenter[cc] ;
      vect3d Xf = Xcc + vect3d(dot(Xgr.x,drl),dot(Xgr.y,drl),dot(Xgr.z,drl)) ;
      vect3d qdif = Xcc -Xf ;

      limi.x = min(limi.x,vlimit(Xcc.x,qmin.x,qmax.x,qdif.x,epsilon2,ref)) ;
      limi.y = min(limi.y,vlimit(Xcc.y,qmin.y,qmax.y,qdif.y,epsilon2,ref)) ;
      limi.z = min(limi.z,vlimit(Xcc.z,qmin.z,qmax.z,qdif.z,epsilon2,ref)) ;
    }
    grad_limiter3d[cc] = limi ;
  }

  void limiter_v3d_V::compute(const sequence &seq) {
    Kl3 = (*Kl)*(*Kl)*(*Kl)*6./pi/(*grid_vol) ;
    do_loop(seq,this) ;
  }

  register_rule<limiter_v3d_V> register_vlimiter_v3d_V ;
  
  // V2 version of venkatakrishnan limiter, limit to original gradient points
  // not face centers.  This should be less compressive.
  
  // The following is another way to get the limiter of gradient approach.
  class limiter_mixture_V2 : public pointwise_rule {
    storeVec<real> limiterv ;
    const_store<real> vol ;
    const_multiMap upper,lower,boundary_map ;
    const_Map cl, cr ;
    const_store<vect3d> cellcenter ;
    const_store<vect3d> facecenter ;
    const_storeVec<real> X, X_f ;
    const_storeVec<vect3d> Xgrad ;
    const_param<real> Kl ;
    const_param<real> grid_vol ;
    const_store<char> firstOrderCells ;
    real Kl3 ;
  public:
    limiter_mixture_V2() ;
    void calculate(Entity cc) ;
    virtual void compute(const sequence &seq) ;
  } ;

  limiter_mixture_V2::limiter_mixture_V2() {
    name_store("Kl",Kl) ;
    name_store("vol",vol) ;
    name_store("limiterv(X)",limiterv) ;
    name_store("cl",cl) ;
    name_store("cr",cr) ;
    name_store("upper",upper) ;
    name_store("lower",lower) ;
    name_store("boundary_map",boundary_map) ;
    name_store("facecenter",facecenter) ;
    name_store("cellcenter",cellcenter) ;
    name_store("X",X) ;
    name_store("X_f",X_f) ;
    name_store("gradv(X)",Xgrad) ;
    name_store("grid_vol",grid_vol) ;
    name_store("firstOrderCells",firstOrderCells) ;
    input("firstOrderCells") ;
    
    constraint("geom_cells,V2_limiter") ;
    input("Kl,grid_vol") ;
    input("cellcenter,X,gradv(X),vol") ;
    input("upper->cr->X") ;
    input("upper->cr->cellcenter") ;
    input("lower->cl->X") ;
    input("lower->cl->cellcenter") ;
    input("boundary_map->X_f") ;
    input("boundary_map->facecenter") ;
    output("limiterv(X)") ;
  }

  void limiter_mixture_V2::calculate(Entity cc) {
    const vect3d &cctr = cellcenter[cc] ;
    real ref = 0.0 ;
    const int vs = X.vecSize() ;
    
    for(int i=0;i<vs;++i)
      ref += fabs(X[cc][i]) ;
    ref = max(ref,real_t(1e-5)) ;

    const real refsq = ref*ref ;
    for(int i=0;i<vs;++i) {
      const real &Xcc = X[cc][i] ;
      real qmax = Xcc ;
      real qmin = qmax ;
      const vect3d &Xgr = Xgrad[cc][i] ;
      // Epsilon squared is equal to (Kl D)^3 where D is the diameter of
      // a sphere with the same volume as the given cell.
      const real epsilon2 = Kl3*vol[cc]*refsq ;
      
      for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
        const int fc = *fi ;
        qmin = min(qmin,X[cr[fc]][i]) ;
        qmax = max(qmax,X[cr[fc]][i]) ;
      }
      for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
        const int fc = *fi ;
        qmin = min(qmin,X[cl[fc]][i]) ;
        qmax = max(qmax,X[cl[fc]][i]) ;
      }
      for(const int *fi=boundary_map.begin(cc);fi!=boundary_map.end(cc);++fi) {
        const int fc = *fi ;
        qmin = min(qmin,X_f[fc][i]) ;
        qmax = max(qmax,X_f[fc][i]) ;
      }
      real limi = 1.0 ;
      if(firstOrderCells[cc] != 0)
        limi = 0.0 ;
      
      for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
        const int fc = *fi ;
        real Xf = Xcc + dot(Xgr,(cellcenter[cr[fc]]-cctr)) ;
        real qdif = Xcc -Xf ;
	limi = min(limi,vlimit(Xcc,qmin,qmax,qdif,epsilon2,ref)) ;
      }
      for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
        const int fc = *fi ;
        real Xf = Xcc + dot(Xgr,(cellcenter[cl[fc]]-cctr)) ;
        real qdif = Xcc -Xf ;
	limi = min(limi,vlimit(Xcc,qmin,qmax,qdif,epsilon2,ref)) ;
      }
      for(const int *fi=boundary_map.begin(cc);fi!=boundary_map.end(cc);++fi) {
        const int fc = *fi ;
        real Xf = Xcc + dot(Xgr,(facecenter[fc]-cctr)) ;
        real qdif = Xcc -Xf ;
	limi = min(limi,vlimit(Xcc,qmin,qmax,qdif,epsilon2,ref)) ;
      }
      limiterv[cc][i] = limi ;
    }
  }


  void limiter_mixture_V2::compute(const sequence &seq) {
    Kl3 = (*Kl)*(*Kl)*(*Kl)*6./pi/(*grid_vol) ;
    limiterv.setVecSize(X.vecSize()) ;
    do_loop(seq,this) ;
  }
  
  register_rule<limiter_mixture_V2> register_limiter_mixture_V2 ;
  
  // The following is another way to get the limiter of gradient approach.
  class limiter_scalar_V2 : public pointwise_rule {
    store<real> grad_limiter ;
    const_store<real> vol ;
    const_multiMap upper,lower,boundary_map ;
    const_Map cl, cr ;
    const_store<vect3d> cellcenter ;
    const_store<vect3d> facecenter ;
    const_store<real> X, X_f ;
    const_store<vect3d> Xgrad ;
    const_param<real> Kl ;
    const_param<real> grid_vol ;
    const_store<char> firstOrderCells ;
    real Kl3 ;
  public:
    limiter_scalar_V2() ;
    void calculate(Entity cc) ;
    virtual void compute(const sequence &seq) ;
  } ;

  limiter_scalar_V2::limiter_scalar_V2() {
    name_store("Kl",Kl) ;
    name_store("vol",vol) ;
    name_store("limiters(X)",grad_limiter) ;
    name_store("cl",cl) ;
    name_store("cr",cr) ;
    name_store("upper",upper) ;
    name_store("lower",lower) ;
    name_store("boundary_map",boundary_map) ;
    name_store("facecenter",facecenter) ;
    name_store("cellcenter",cellcenter) ;
    name_store("X",X) ;
    name_store("X_f",X_f) ;
    name_store("grads(X)",Xgrad) ;
    name_store("grid_vol",grid_vol) ;
    name_store("firstOrderCells",firstOrderCells) ;
    input("firstOrderCells") ;
    
    constraint("geom_cells,V2_limiter") ;
    input("Kl,grid_vol") ;
    input("cellcenter,X,grads(X),vol") ;
    input("upper->cr->X") ;
    input("upper->cr->cellcenter") ;
    input("lower->cl->X") ;
    input("lower->cl->cellcenter") ;
    input("boundary_map->X_f") ;
    input("boundary_map->facecenter") ;
    output("limiters(X)") ;
  }

  void limiter_scalar_V2::calculate(Entity cc) {
    const vect3d &cctr = cellcenter[cc] ;

    real refsq = X[cc]*X[cc] ;
    int numrefs = 1 ;

    const real &Xcc = X[cc] ;
    real qmax = Xcc ;
    real qmin = qmax ;
    const vect3d &Xgr = Xgrad[cc];
    // Epsilon squared is equal to (Kl D)^3 where D is the diameter of
    // a sphere with the same volume as the given cell.
      
    for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
      const int fc = *fi ;
      const real Xr = X[cr[fc]] ;
      qmin = min(qmin,Xr) ;
      qmax = max(qmax,Xr) ;
      refsq += Xr*Xr ;
      numrefs++ ;
    }
    for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
      const int fc = *fi ;
      const real Xl = X[cl[fc]] ;
      qmin = min(qmin,Xl) ;
      qmax = max(qmax,Xl) ;
      refsq += Xl*Xl ;
      numrefs++ ;
    }
    for(const int *fi=boundary_map.begin(cc);fi!=boundary_map.end(cc);++fi) {
      const int fc = *fi ;
      const real Xf = X_f[fc] ;
      qmin = min(qmin,Xf) ;
      qmax = max(qmax,Xf) ;
      refsq += Xf*Xf ;
      numrefs++ ;
    }
    const real ref = 1e-20+sqrt(refsq)/numrefs ;
     
    const real epsilon2 = Kl3*vol[cc]*ref*ref ;
    real limi = 1.0 ;
    if(firstOrderCells[cc] != 0)
      limi=0.0 ;
    
    for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
      const int fc = *fi ;
      real Xf = Xcc + dot(Xgr,(cellcenter[cr[fc]]-cctr)) ;
      real qdif = Xcc -Xf ;
      limi = min(limi,vlimit(Xcc,qmin,qmax,qdif,epsilon2,ref)) ;
    }
    for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
      const int fc = *fi ;
      real Xf = Xcc + dot(Xgr,(cellcenter[cl[fc]]-cctr)) ;
      real qdif = Xcc -Xf ;
      limi = min(limi,vlimit(Xcc,qmin,qmax,qdif,epsilon2,ref)) ;
    }
    for(const int *fi=boundary_map.begin(cc);fi!=boundary_map.end(cc);++fi) {
      const int fc = *fi ;
      real Xf = Xcc + dot(Xgr,(facecenter[fc]-cctr)) ;
      real qdif = Xcc -Xf ;
      limi = min(limi,vlimit(Xcc,qmin,qmax,qdif,epsilon2,ref)) ;
    }
    grad_limiter[cc] = limi ;
  }

  void limiter_scalar_V2::compute(const sequence &seq) {
    Kl3 = (*Kl)*(*Kl)*(*Kl)*6./pi/(*grid_vol) ;
    do_loop(seq,this) ;
  }

  register_rule<limiter_scalar_V2> register_limiter_scalar_V2 ;
  
  // The following is another way to get the limiter3d of gradient approach.
  class limiter_v3d_V2 : public pointwise_rule {
    store<vect3d> grad_limiter3d ;
    const_store<real> vol ;
    const_multiMap upper,lower,boundary_map ;
    const_Map cl, cr ;
    const_store<vect3d> cellcenter ;
    const_store<vect3d> facecenter ;
    const_store<vect3d> X, X_f ;
    const_store<tens3d> Xgrad ;
    const_param<real> Kl ;
    const_param<real> grid_vol ;
    const_store<char> firstOrderCells ;
    real Kl3 ;
  public:
    limiter_v3d_V2() ;
    void calculate(Entity cc) ;
    virtual void compute(const sequence &seq) ;
  } ;

  limiter_v3d_V2::limiter_v3d_V2() {
    name_store("Kl",Kl) ;
    name_store("vol",vol) ;
    name_store("limiterv3d(X)",grad_limiter3d) ;
    name_store("cl",cl) ;
    name_store("cr",cr) ;
    name_store("upper",upper) ;
    name_store("lower",lower) ;
    name_store("boundary_map",boundary_map) ;
    name_store("facecenter",facecenter) ;
    name_store("cellcenter",cellcenter) ;
    name_store("X",X) ;
    name_store("X_f",X_f) ;
    name_store("gradv3d(X)",Xgrad) ;
    name_store("grid_vol",grid_vol) ;
    name_store("firstOrderCells",firstOrderCells) ;
    input("firstOrderCells") ;
    
    constraint("geom_cells,V2_limiter") ;
    input("Kl,grid_vol") ;
    input("cellcenter,X,gradv3d(X),vol") ;
    input("upper->cr->X") ;
    input("upper->cr->cellcenter") ;
    input("lower->cl->X") ;
    input("lower->cl->cellcenter") ;
    input("boundary_map->X_f") ;
    input("boundary_map->facecenter") ;
    output("limiterv3d(X)") ;
  }

  void limiter_v3d_V2::calculate(Entity cc) {
    real refsq = dot(X[cc],X[cc]) ;
    int numrefs = 1 ;

    const vect3d Xcc = X[cc] ;
    vect3d qmax = Xcc ;
    vect3d qmin = qmax ;
    const tens3d &Xgr = Xgrad[cc];
    // Epsilon squared is equal to (Kl D)^3 where D is the diameter of
    // a sphere with the same volume as the given cell.
      
    for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
      const Entity fc = *fi ;
      const vect3d Xr = X[cr[fc]] ;
      qmin.x = min(qmin.x,Xr.x) ;
      qmin.y = min(qmin.y,Xr.y) ;
      qmin.z = min(qmin.z,Xr.z) ;
      qmax.x = max(qmax.x,Xr.x) ;
      qmax.y = max(qmax.y,Xr.y) ;
      qmax.z = max(qmax.z,Xr.z) ;
      refsq += dot(Xr,Xr) ;
      numrefs++ ;
    }
    for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
      const Entity fc = *fi ;
      const vect3d Xl = X[cl[fc]] ;
      qmin.x = min(qmin.x,Xl.x) ;
      qmin.y = min(qmin.y,Xl.y) ;
      qmin.z = min(qmin.z,Xl.z) ;
      qmax.x = max(qmax.x,Xl.x) ;
      qmax.y = max(qmax.y,Xl.y) ;
      qmax.z = max(qmax.z,Xl.z) ;
      refsq += dot(Xl,Xl) ;
      numrefs++ ;
    }
    for(const int *fi=boundary_map.begin(cc);fi!=boundary_map.end(cc);++fi) {
      const int fc = *fi ;
      const vect3d Xf = X_f[fc] ;
      qmin.x = min(qmin.x,Xf.x) ;
      qmin.y = min(qmin.y,Xf.y) ;
      qmin.z = min(qmin.z,Xf.z) ;
      qmax.x = max(qmax.x,Xf.x) ;
      qmax.y = max(qmax.y,Xf.y) ;
      qmax.z = max(qmax.z,Xf.z) ;
      refsq += dot(Xf,Xf) ;
      numrefs++ ;
    }
    const real ref = 1e-20+sqrt(refsq)/numrefs ;
     
    const real epsilon2 = Kl3*vol[cc]*ref*ref ;
    vect3d limi = vect3d(1.0,1.0,1.0) ;
    if(firstOrderCells[cc] != 0)
      limi = vect3d(0.0,0.0,0.0) ;
    
    for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
      const int fc = *fi ;
      const vect3d drl = cellcenter[cr[fc]] - cellcenter[cc] ;
      vect3d Xf = Xcc + vect3d(dot(Xgr.x,drl),dot(Xgr.y,drl),dot(Xgr.z,drl)) ;
      vect3d qdif = Xcc -Xf ;

      limi.x = min(limi.x,vlimit(Xcc.x,qmin.x,qmax.x,qdif.x,epsilon2,ref)) ;
      limi.y = min(limi.y,vlimit(Xcc.y,qmin.y,qmax.y,qdif.y,epsilon2,ref)) ;
      limi.z = min(limi.z,vlimit(Xcc.z,qmin.z,qmax.z,qdif.z,epsilon2,ref)) ;
    }
    for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
      const int fc = *fi ;
      const vect3d drl = cellcenter[cl[fc]] - cellcenter[cc] ;
      vect3d Xf = Xcc + vect3d(dot(Xgr.x,drl),dot(Xgr.y,drl),dot(Xgr.z,drl)) ;
      vect3d qdif = Xcc -Xf ;

      limi.x = min(limi.x,vlimit(Xcc.x,qmin.x,qmax.x,qdif.x,epsilon2,ref)) ;
      limi.y = min(limi.y,vlimit(Xcc.y,qmin.y,qmax.y,qdif.y,epsilon2,ref)) ;
      limi.z = min(limi.z,vlimit(Xcc.z,qmin.z,qmax.z,qdif.z,epsilon2,ref)) ;
    }
    for(const int *fi=boundary_map.begin(cc);fi!=boundary_map.end(cc);++fi) {
      const int fc = *fi ;

      const vect3d drl = facecenter[fc] - cellcenter[cc] ;
      vect3d Xf = Xcc + vect3d(dot(Xgr.x,drl),dot(Xgr.y,drl),dot(Xgr.z,drl)) ;
      vect3d qdif = Xcc -Xf ;

      limi.x = min(limi.x,vlimit(Xcc.x,qmin.x,qmax.x,qdif.x,epsilon2,ref)) ;
      limi.y = min(limi.y,vlimit(Xcc.y,qmin.y,qmax.y,qdif.y,epsilon2,ref)) ;
      limi.z = min(limi.z,vlimit(Xcc.z,qmin.z,qmax.z,qdif.z,epsilon2,ref)) ;
    }
    grad_limiter3d[cc] = limi ;
  }

  void limiter_v3d_V2::compute(const sequence &seq) {
    Kl3 = (*Kl)*(*Kl)*(*Kl)*6./pi/(*grid_vol) ;
    do_loop(seq,this) ;
  }

  register_rule<limiter_v3d_V2> register_vlimiter_v3d_V2 ;
}
