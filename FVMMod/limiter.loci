//#############################################################################
//#
//# Copyright 2008, Mississippi State University
//#
//# This file is part of the Loci Framework.
//#
//# The Loci Framework is free software: you can redistribute it and/or modify
//# it under the terms of the Lesser GNU General Public License as published by
//# the Free Software Foundation, either version 3 of the License, or
//# (at your option) any later version.
//#
//# The Loci Framework is distributed in the hope that it will be useful,
//# but WITHOUT ANY WARRANTY; without even the implied warranty of
//# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//# Lesser GNU General Public License for more details.
//#
//# You should have received a copy of the Lesser GNU General Public License
//# along with the Loci Framework.  If not, see <http://www.gnu.org/licenses>
//#
//#############################################################################
#include <Loci.h>
$include "FVM.lh"

using std::cerr ;
using std::endl ;

namespace Loci {
  typedef vector3d<real_t> vect3d ;
  typedef tensor3d<real_t> tens3d ;
  typedef real_t real ;

  $type firstOrderCells store<char> ;

  $rule unit(firstOrderCells),constraint(geom_cells) {
    $firstOrderCells = 0 ;
  }

  $rule apply((cl,cr)->firstOrderCells<-(cl,cr)->vol)[Loci::Maximum],
  constraint((cl,cr)->geom_cells) {
    if(max($cl->$vol,$cr->$vol) > 50.*min($cl->$vol,$cr->$vol)) {
      char tmp = 1 ;
      join($cl->$firstOrderCells,tmp) ;
      join($cr->$firstOrderCells,tmp) ;
    }
  }

  $rule apply(ci->firstOrderCells<-ci->vol)[Loci::Maximum], constraint(ref->firstOrder_BCoption,ci->vol) {
    char tmp = 1 ;
    join($ci->$firstOrderCells,tmp) ;
  }

  $rule apply((cl,cr)->firstOrderCells<-(cl,cr)->cellcenter,facecenter)[Loci::Maximum],constraint((cl,cr)->geom_cells) {
    // maximum angle between line segment connecting cellcenters and line
    // segments that connect cell centers to face centers.
    vector3d<double> v1 = $cr->$cellcenter-$cl->$cellcenter ;
    vector3d<double> v2 = $facecenter-$cl->$cellcenter ;
    vector3d<double> v3 = $cr->$cellcenter-$facecenter ;
    double nv1 = norm(v1) ;
    double nv2 = norm(v2) ;
    double nv3 = norm(v3) ;
    double mincosa = min(dot(v1,v2)/(nv1*nv2),dot(v1,v3)/(nv1*nv3)) ;
    if(mincosa < -.866) { // Greater than 150 degrees
      char tmp = 1 ;
      join($cl->$firstOrderCells,tmp) ;
      join($cr->$firstOrderCells,tmp) ;
    }
  }
    
  
  

  $type Kl param<real> ;
  $rule default(Kl),comments("This parameter is a smoothness parameter for the venkatakrishnan limiter.  A value of zero will not allow overshoots, while a larger value may allow some overshoots to ensure accuracy in locally smooth regions.  The typical values for this parameter range from .1 to 100") {
    $Kl = 1.0 ;
  }

  class default_limiter: public default_rule {
    param<std::string> limiter ;
  public:
    default_limiter() {
      name_store("limiter",limiter) ;
      output("limiter") ;
      comments("Limiter used in face extrapolations.  This function can take the values of 'venkatakrishnan', 'barth', 'none' for second order solutions, and 'zero' for first order solutions") ;
    }
    virtual void compute(const sequence& seq) {
      *limiter = "venkatakrishnan" ;
    }
  } ;
  register_rule<default_limiter> register_default_limiter ;

  class constraint_limiter: public constraint_rule {
    const_param<std::string> limiter ;
    Constraint V_limiter, B_limiter, N_limiter, Z_limiter,NB_limiter ;
  public:
    constraint_limiter() {
      name_store("limiter",limiter) ;
      name_store("V_limiter",V_limiter) ;
      name_store("B_limiter",B_limiter) ;
      name_store("NB_limiter",NB_limiter) ;
      name_store("N_limiter",N_limiter) ;
      name_store("Z_limiter",Z_limiter) ;
      input("limiter") ;
      output("V_limiter,B_limiter,NB_limiter,N_limiter,Z_limiter") ;
    }
    virtual void compute(const sequence& seq) {
      //      std::cerr << "Setting limiter constraints!" << endl ;
      V_limiter = EMPTY ;
      B_limiter = EMPTY ;
      NB_limiter = EMPTY ;
      N_limiter = EMPTY ;
      Z_limiter = EMPTY ;
      
      if(*limiter == "venkatakrishnan" || *limiter == "V") {
        V_limiter = ~EMPTY ;
      } else if(*limiter == "barth" || *limiter == "B") {
        B_limiter = ~EMPTY ;
      } else if(*limiter == "nodalbarth" || *limiter == "NB") {
        NB_limiter = ~EMPTY ;
      } else if(*limiter == "none") {
        N_limiter = ~EMPTY ;
      } else if(*limiter == "zero") {
        Z_limiter = ~EMPTY ;
      } else {
        cerr << "limiter " << *limiter
             << " not supported for generalized grids" << endl ;
        cerr << "defaulting to venkatakrishnan limiter" << endl ;
        V_limiter = ~EMPTY ;
      }
    }
  } ;
  register_rule<constraint_limiter> register_constraint_limiter ;
  

  class limiterv_none : public pointwise_rule {
    const_storeVec<real> X ;
    storeVec<real> limiterv ;
  public:
    limiterv_none() {
      name_store("limiterv(X)",limiterv) ;
      name_store("X",X) ;
      constraint("geom_cells,N_limiter") ;
      input("X") ;
      output("limiterv(X)") ;
    }
    void calculate(Entity cc) {
      limiterv[cc] = mk_Scalar(1.) ;
    }
    virtual void compute(const sequence &seq) {
      limiterv.setVecSize(X.vecSize()) ;
      do_loop(seq,this) ;
    }
  } ;

  class limiterv_zero : public pointwise_rule {
    const_storeVec<real> X ;
    storeVec<real> limiterv ;
  public:
    limiterv_zero() {
      name_store("limiterv(X)",limiterv) ;
      name_store("X",X) ;
      constraint("geom_cells,Z_limiter") ;
      input("X") ;
      output("limiterv(X)") ;
    }
    void calculate(Entity cc) {
      limiterv[cc] = mk_Scalar(0.) ;
    }
    virtual void compute(const sequence &seq) {
      limiterv.setVecSize(X.vecSize()) ;
      do_loop(seq,this) ;
    }
  } ;

  
  // The following is to get the limiter of gradient approach.
  class get_limiterv : public pointwise_rule {
    storeVec<real> limiterv ;
    const_multiMap upper, lower, boundary_map ;
    const_Map cl, cr ;
    const_store<vect3d> cellcenter ;
    const_store<vect3d> facecenter ;
    const_storeVec<real> X, X_f ;
    const_storeVec<vect3d> Xgrad ;
    const_store<char> firstOrderCells ;
  public:
    get_limiterv() ;
    void calculate(Entity cc) ;
    virtual void compute(const sequence &seq) ;
  } ;

  get_limiterv::get_limiterv() {
    name_store("limiterv(X)",limiterv) ;
    name_store("cl",cl) ;
    name_store("cr",cr) ;
    name_store("upper",upper) ;
    name_store("lower",lower) ;
    name_store("boundary_map",boundary_map) ;
    name_store("facecenter",facecenter) ;
    name_store("cellcenter",cellcenter) ;
    name_store("X",X) ;
    name_store("X_f",X_f) ;
    name_store("gradv(X)",Xgrad) ;
    name_store("firstOrderCells",firstOrderCells) ;
    input("firstOrderCells") ;
    constraint("geom_cells,B_limiter") ;
    input("cellcenter,X,gradv(X)") ;
    input("upper->cr->X") ;
    input("upper->facecenter") ;
    input("lower->cl->X") ;
    input("lower->facecenter") ;
    input("boundary_map->X_f") ;
    input("boundary_map->facecenter") ;
    output("limiterv(X)") ;
  }

  void get_limiterv::calculate(Entity cc) {
    const int vs = X.vecSize() ;
    for(int i=0;i<vs;++i) {
      const real Xcc = X[cc][i] ;
      real qmax = Xcc ;
      real qmin = qmax ;
      const vect3d Xgr = Xgrad[cc][i] ;

      for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
        const int fc = *fi ;
        qmin = min(qmin,X[cr[fc]][i]) ;
        qmax = max(qmax,X[cr[fc]][i]) ;
      }
      for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
        const int fc = *fi ;
        qmin = min(qmin,X[cl[fc]][i]) ;
        qmax = max(qmax,X[cl[fc]][i]) ;
      }

      for(const int *fi=boundary_map.begin(cc);fi!=boundary_map.end(cc);++fi) {
        const int fc = *fi ;
        qmin = min(qmin,X_f[fc][i]) ;
        qmax = max(qmax,X_f[fc][i]) ;
      }

      real limi = 1.0 ;
      if(firstOrderCells[cc] != 0)
        limi = 0.0 ;
      for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
        const int fc = *fi ;
        const vect3d drl = facecenter[fc] - cellcenter[cc] ;
        real Xf = Xcc + dot(Xgr,drl) ;
        real qdif = Xf-Xcc ;
        real lim = 1.0 ;
        if(qdif > 0)
          lim = min(real(1.0),(qmax-Xcc)/(qdif+1e-100)) ;
        if(qdif < 0)
          lim = min(real(1.0),(qmin-Xcc)/(qdif-1e-100)) ;
        limi = min (limi,lim) ;
      }
     
      for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
        const int fc = *fi ;
        const vect3d drl = facecenter[fc] - cellcenter[cc] ;
        real Xf = Xcc + dot(Xgr,drl) ;
        real qdif = Xf-Xcc ;
        real lim = 1.0 ;
        if(qdif > 0)
          lim = min(real(1.0),(qmax-Xcc)/(qdif+1e-100)) ;
        if(qdif < 0)
          lim = min(real(1.0),(qmin-Xcc)/(qdif-1e-100)) ;
        limi = min (limi,lim) ;
      }

      for(const int *fi=boundary_map.begin(cc);fi!=boundary_map.end(cc);++fi) {
        const int fc = *fi ;
        const vect3d drl = facecenter[fc] - cellcenter[cc] ;
        real Xf = Xcc + dot(Xgr,drl) ;
        real qdif = Xf-Xcc ;
        real lim = 1.0 ;
        if(qdif > 0)
          lim = min(real(1.0),(qmax-Xcc)/(qdif+1e-100)) ;
        if(qdif < 0)
          lim = min(real(1.0),(qmin-Xcc)/(qdif-1e-100)) ;
        limi = min (limi,lim) ;
      }
      
      limiterv[cc][i] = limi ;
    }
  }

  void get_limiterv::compute(const sequence &seq) {
    limiterv.setVecSize(X.vecSize()) ;
    do_loop(seq,this) ;
  }


  // The following is another way to get the limiter of gradient approach.
  class get_grad_vlimiter : public pointwise_rule {
    storeVec<real> limiterv ;
    const_store<real> vol ;
    const_multiMap upper,lower,boundary_map ;
    const_Map cl, cr ;
    const_store<vect3d> cellcenter ;
    const_store<vect3d> facecenter ;
    const_storeVec<real> X, X_f ;
    const_storeVec<vect3d> Xgrad ;
    const_param<real> Kl ;
    const_param<real> grid_vol ;
    const_store<char> firstOrderCells ;
    real Kl3 ;
  public:
    get_grad_vlimiter() ;
    void calculate(Entity cc) ;
    virtual void compute(const sequence &seq) ;
  } ;

  get_grad_vlimiter::get_grad_vlimiter() {
    name_store("Kl",Kl) ;
    name_store("vol",vol) ;
    name_store("limiterv(X)",limiterv) ;
    name_store("cl",cl) ;
    name_store("cr",cr) ;
    name_store("upper",upper) ;
    name_store("lower",lower) ;
    name_store("boundary_map",boundary_map) ;
    name_store("facecenter",facecenter) ;
    name_store("cellcenter",cellcenter) ;
    name_store("X",X) ;
    name_store("X_f",X_f) ;
    name_store("gradv(X)",Xgrad) ;
    name_store("grid_vol",grid_vol) ;
    name_store("firstOrderCells",firstOrderCells) ;
    input("firstOrderCells") ;
    
    constraint("geom_cells,V_limiter") ;
    input("Kl,grid_vol") ;
    input("cellcenter,X,gradv(X),vol") ;
    input("upper->cr->X") ;
    input("upper->facecenter") ;
    input("lower->cl->X") ;
    input("lower->facecenter") ;
    input("boundary_map->X_f") ;
    output("limiterv(X)") ;
  }

  void get_grad_vlimiter::calculate(Entity cc) {
    const vect3d &cctr = cellcenter[cc] ;
    real ref = 0.0 ;
    const int vs = X.vecSize() ;
    
    for(int i=0;i<vs;++i)
      ref += X[cc][i] ;
    ref = max(ref,1e-5) ;

    const real refsq = ref*ref ;
    for(int i=0;i<vs;++i) {
      const real &Xcc = X[cc][i] ;
      real qmax = Xcc ;
      real qmin = qmax ;
      const vect3d &Xgr = Xgrad[cc][i] ;
      // Epsilon squared is equal to (Kl D)^3 where D is the diameter of
      // a sphere with the same volume as the given cell.
      const real epsilon2 = Kl3*vol[cc]*refsq ;
      
      for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
        const int fc = *fi ;
        qmin = min(qmin,X[cr[fc]][i]) ;
        qmax = max(qmax,X[cr[fc]][i]) ;
      }
      for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
        const int fc = *fi ;
        qmin = min(qmin,X[cl[fc]][i]) ;
        qmax = max(qmax,X[cl[fc]][i]) ;
      }
      for(const int *fi=boundary_map.begin(cc);fi!=boundary_map.end(cc);++fi) {
        const int fc = *fi ;
        qmin = min(qmin,X_f[fc][i]) ;
        qmax = max(qmax,X_f[fc][i]) ;
      }
      real limi = 1.0 ;
      if(firstOrderCells[cc] != 0)
        limi = 0.0 ;
      
      for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
        const int fc = *fi ;
        real Xf = Xcc + dot(Xgr,(facecenter[fc]-cctr)) ;
        real qdif = Xcc -Xf ;
        real lim = 1.0 ;
        
        if(fabs(qdif)<=ref*1e-4) lim = 1.0 ;
        else {
          const real deltap = (qdif>0.0)?qmin-Xcc:qmax-Xcc;
          const real deltam = -qdif ;
          lim = ((deltap*deltap+epsilon2)*deltam+ 2.0*deltam*deltam*deltap) /
            (deltam*(deltap*deltap+2.0*deltam*deltam+deltam*deltap+epsilon2)) ;
        }
        limi = min(limi,lim) ;
      }
      for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
        const int fc = *fi ;
        real Xf = Xcc + dot(Xgr,(facecenter[fc]-cctr)) ;
        real qdif = Xcc -Xf ;
        real lim = 1.0 ;
        if(fabs(qdif)<=ref*1e-4) lim = 1.0 ;
        else {
          const real deltap =(qdif>0.0)?qmin-Xcc:qmax-Xcc;
          const real deltam =-qdif ;
          lim = ((deltap*deltap+epsilon2)*deltam+ 2.0*deltam*deltam*deltap) /
            (deltam*(deltap*deltap+2.0*deltam*deltam+deltam*deltap+epsilon2)) ;
        }
        limi = min(limi,lim) ;
      }
      limiterv[cc][i] = limi ;
    }
  }

  const double pi = M_PI ;

  void get_grad_vlimiter::compute(const sequence &seq) {
    Kl3 = (*Kl)*(*Kl)*(*Kl)*6./pi/(*grid_vol) ;
    limiterv.setVecSize(X.vecSize()) ;
    do_loop(seq,this) ;
  }

  register_rule<limiterv_none> register_limiterv_none ;
  register_rule<limiterv_zero> register_limiterv_zero ;
  register_rule<get_limiterv> register_get_limiterv ;
  register_rule<get_grad_vlimiter> register_get_grad_vlimiter ;

  // The following is to get the limiter of gradient approach.
  class get_limiter_none_scalar : public pointwise_rule {
    store<real> limiter ;
  public:
    get_limiter_none_scalar() {
      name_store("limiters(X)",limiter) ;
      constraint("geom_cells,N_limiter") ;
      output("limiters(X)") ;
    }
    void calculate(Entity cc) {
      limiter[cc] = 1.0 ;
    }
    virtual void compute(const sequence &seq) {
      do_loop(seq,this) ;
    }
  } ;

  register_rule<get_limiter_none_scalar> register_get_limiter_none_scalar ;

  class get_limiter_zero_scalar : public pointwise_rule {
    store<real> limiter ;
  public:
    get_limiter_zero_scalar() {
      name_store("limiters(X)",limiter) ;
      constraint("geom_cells,Z_limiter") ;
      output("limiters(X)") ;
    }
    void calculate(Entity cc) {
      limiter[cc] = 0. ; 
    }
    virtual void compute(const sequence &seq) {
      do_loop(seq,this) ;
    }
  } ;
  
  register_rule<get_limiter_zero_scalar> register_get_limiter_zero_scalar ;

  class get_limiter_scalar : public pointwise_rule {
    store<real> limiter ;
    const_multiMap upper, lower, boundary_map ;
    const_Map cl, cr ;
    const_store<vect3d> cellcenter ;
    const_store<vect3d> facecenter ;
    const_store<real> X, X_f ;
    const_store<vect3d> Xgrad ;
    const_store<char> firstOrderCells ;
    int vs ;
  public:
    get_limiter_scalar() ;
    void calculate(Entity cc) ;
    virtual void compute(const sequence &seq) ;
  } ;

  get_limiter_scalar::get_limiter_scalar() {
    name_store("limiters(X)",limiter) ;
    name_store("cl",cl) ;
    name_store("cr",cr) ;
    name_store("upper",upper) ;
    name_store("lower",lower) ;
    name_store("boundary_map",boundary_map) ;
    name_store("facecenter",facecenter) ;
    name_store("cellcenter",cellcenter) ;
    name_store("X",X) ;
    name_store("X_f",X_f) ;
    name_store("grads(X)",Xgrad) ;
    name_store("firstOrderCells",firstOrderCells) ;
    input("firstOrderCells") ;

    constraint("geom_cells,B_limiter") ;
    input("cellcenter,X,grads(X)") ;
    input("upper->cr->X") ;
    input("upper->facecenter") ;
    input("lower->cl->X") ;
    input("boundary_map->X_f") ;
    input("lower->facecenter") ;
    output("limiters(X)") ;
  }

  void get_limiter_scalar::calculate(Entity cc) {

    const real Xcc = X[cc] ;
    real qmax = Xcc ;
    real qmin = qmax ;
    const vect3d Xgr = Xgrad[cc] ;

    for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
      const int fc = *fi ;
      qmin = min(qmin,X[cr[fc]]) ;
      qmax = max(qmax,X[cr[fc]]) ;
    }
    for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
      const int fc = *fi ;
      qmin = min(qmin,X[cl[fc]]) ;
      qmax = max(qmax,X[cl[fc]]) ;
    }
    for(const int *fi=boundary_map.begin(cc);fi!=boundary_map.end(cc);++fi) {
      const int fc = *fi ;
      qmin = min(qmin,X_f[fc]) ;
      qmax = max(qmax,X_f[fc]) ;
    }

    real limi = 1.0 ;
    if(firstOrderCells[cc] != 0)
      limi = 0.0 ;
    
    for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
      const int fc = *fi ;
      const vect3d drl = facecenter[fc] - cellcenter[cc] ;
      real Xf = Xcc + dot(Xgr,drl) ;
      real qdif = Xf-Xcc ;
      real lim = 1.0 ;
      if(qdif > 0)
        lim = min(real(1.0),(qmax-Xcc)/(qdif+1e-100)) ;
      if(qdif < 0)
        lim = min(real(1.0),(qmin-Xcc)/(qdif-1e-100)) ;
      limi = min (limi,lim) ;
    }
    
    for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
      const int fc = *fi ;
      const vect3d drl = facecenter[fc] - cellcenter[cc] ;
      real Xf = Xcc + dot(Xgr,drl) ;
      real qdif = Xf-Xcc ;
      real lim = 1.0 ;
      if(qdif > 0)
        lim = min(real(1.0),(qmax-Xcc)/(qdif+1e-100)) ;
      if(qdif < 0)
        lim = min(real(1.0),(qmin-Xcc)/(qdif-1e-100)) ;
      limi = min (limi,lim) ;
    }
    
    limiter[cc] = limi ;
  }

  void get_limiter_scalar::compute(const sequence &seq) {
    do_loop(seq,this) ;
  }


  register_rule<get_limiter_scalar> register_get_limiter_scalar ;

  // The following is another way to get the limiter of gradient approach.
  class get_vlimiter_scalar : public pointwise_rule {
    store<real> grad_limiter ;
    const_store<real> vol ;
    const_multiMap upper,lower,boundary_map ;
    const_Map cl, cr ;
    const_store<vect3d> cellcenter ;
    const_store<vect3d> facecenter ;
    const_store<real> X, X_f ;
    const_store<vect3d> Xgrad ;
    const_param<real> Kl ;
    const_param<real> grid_vol ;
    const_store<char> firstOrderCells ;
    real Kl3 ;
  public:
    get_vlimiter_scalar() ;
    void calculate(Entity cc) ;
    virtual void compute(const sequence &seq) ;
  } ;

  get_vlimiter_scalar::get_vlimiter_scalar() {
    name_store("Kl",Kl) ;
    name_store("vol",vol) ;
    name_store("limiters(X)",grad_limiter) ;
    name_store("cl",cl) ;
    name_store("cr",cr) ;
    name_store("upper",upper) ;
    name_store("lower",lower) ;
    name_store("boundary_map",boundary_map) ;
    name_store("facecenter",facecenter) ;
    name_store("cellcenter",cellcenter) ;
    name_store("X",X) ;
    name_store("X_f",X_f) ;
    name_store("grads(X)",Xgrad) ;
    name_store("grid_vol",grid_vol) ;
    name_store("firstOrderCells",firstOrderCells) ;
    input("firstOrderCells") ;
    
    constraint("geom_cells,V_limiter") ;
    input("Kl,grid_vol") ;
    input("cellcenter,X,grads(X),vol") ;
    input("upper->cr->X") ;
    input("upper->facecenter") ;
    input("lower->cl->X") ;
    input("lower->facecenter") ;
    input("boundary_map->X_f") ;
    output("limiters(X)") ;
  }

  void get_vlimiter_scalar::calculate(Entity cc) {
    const vect3d &cctr = cellcenter[cc] ;

    real refsq = X[cc]*X[cc] ;
    int numrefs = 1 ;

    const real &Xcc = X[cc] ;
    real qmax = Xcc ;
    real qmin = qmax ;
    const vect3d &Xgr = Xgrad[cc];
    // Epsilon squared is equal to (Kl D)^3 where D is the diameter of
    // a sphere with the same volume as the given cell.
      
    for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
      const int fc = *fi ;
      const real Xr = X[cr[fc]] ;
      qmin = min(qmin,Xr) ;
      qmax = max(qmax,Xr) ;
      refsq += Xr*Xr ;
      numrefs++ ;
    }
    for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
      const int fc = *fi ;
      const real Xl = X[cl[fc]] ;
      qmin = min(qmin,Xl) ;
      qmax = max(qmax,Xl) ;
      refsq += Xl*Xl ;
      numrefs++ ;
    }
    for(const int *fi=boundary_map.begin(cc);fi!=boundary_map.end(cc);++fi) {
      const int fc = *fi ;
      const real Xf = X_f[fc] ;
      qmin = min(qmin,Xf) ;
      qmax = max(qmax,Xf) ;
      refsq += Xf*Xf ;
      numrefs++ ;
    }
    const real ref = 1e-20+sqrt(refsq)/numrefs ;
     
    const real epsilon2 = Kl3*vol[cc]*ref*ref ;
    real limi = 1.0 ;
    if(firstOrderCells[cc] != 0)
      limi=0.0 ;
    
    for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
      const int fc = *fi ;
      real Xf = Xcc + dot(Xgr,(facecenter[fc]-cctr)) ;
      real qdif = Xcc -Xf ;
      real lim = 1.0 ;
        
      if(fabs(qdif)<=ref*1e-4) lim = 1.0 ;
      else {
        const real deltap = (qdif>0.0)?qmin-Xcc:qmax-Xcc;
        const real deltam = -qdif ;
        lim = ((deltap*deltap+epsilon2)*deltam+ 2.0*deltam*deltam*deltap) /
          (deltam*(deltap*deltap+2.0*deltam*deltam+deltam*deltap+epsilon2)) ;
      }
      limi = min(limi,lim) ;
    }
    for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
      const int fc = *fi ;
      real Xf = Xcc + dot(Xgr,(facecenter[fc]-cctr)) ;
      real qdif = Xcc -Xf ;
      real lim = 1.0 ;
      if(fabs(qdif)<=ref*1e-4) lim = 1.0 ;
      else {
        const real deltap =(qdif>0.0)?qmin-Xcc:qmax-Xcc;
        const real deltam =-qdif ;
        lim = ((deltap*deltap+epsilon2)*deltam+ 2.0*deltam*deltam*deltap) /
          (deltam*(deltap*deltap+2.0*deltam*deltam+deltam*deltap+epsilon2)) ;
      }
      limi = min(limi,lim) ;
    }
    grad_limiter[cc] = limi ;
  }

  void get_vlimiter_scalar::compute(const sequence &seq) {
    Kl3 = (*Kl)*(*Kl)*(*Kl)*6./pi/(*grid_vol) ;
    do_loop(seq,this) ;
  }

  register_rule<get_vlimiter_scalar> register_vlimiter_scalar ;


  // The following is to get the limiter of gradient approach.
  class get_limiter3d_none : public pointwise_rule {
    store<vect3d> limiter3d ;
  public:
    get_limiter3d_none() {
      name_store("limiterv3d(X)",limiter3d) ;
      constraint("geom_cells,N_limiter") ;
      output("limiterv3d(X)") ;
    }
    void calculate(Entity cc) {
      limiter3d[cc] = vect3d(1.0,1.0,1.0) ;
    }
    virtual void compute(const sequence &seq) {
      do_loop(seq,this) ;
    }
  } ;

  register_rule<get_limiter3d_none> register_get_limiter3d_none ;

  class get_limiter3d_zero : public pointwise_rule {
    store<vect3d> limiter3d ;
  public:
    get_limiter3d_zero() {
      name_store("limiterv3d(X)",limiter3d) ;
      constraint("geom_cells,Z_limiter") ;
      output("limiterv3d(X)") ;
    }
    void calculate(Entity cc) {
      limiter3d[cc] = vect3d(0.,0.,0.) ; 
    }
    virtual void compute(const sequence &seq) {
      do_loop(seq,this) ;
    }
  } ;
  
  register_rule<get_limiter3d_zero> register_get_limiter3d_zero ;

  class get_limiter3d : public pointwise_rule {
    store<vect3d> limiter3d ;
    const_multiMap upper, lower, boundary_map ;
    const_Map cl, cr ;
    const_store<vect3d> cellcenter ;
    const_store<vect3d> facecenter ;
    const_store<vect3d> X, X_f ;
    const_store<tens3d> Xgrad ;
    const_store<char> firstOrderCells ;
    int vs ;
  public:
    get_limiter3d() ;
    void calculate(Entity cc) ;
    virtual void compute(const sequence &seq) ;
  } ;

  get_limiter3d::get_limiter3d() {
    name_store("limiterv3d(X)",limiter3d) ;
    name_store("cl",cl) ;
    name_store("cr",cr) ;
    name_store("upper",upper) ;
    name_store("lower",lower) ;
    name_store("boundary_map",boundary_map) ;
    name_store("facecenter",facecenter) ;
    name_store("cellcenter",cellcenter) ;
    name_store("X",X) ;
    name_store("X_f",X_f) ;
    name_store("gradv3d(X)",Xgrad) ;
    name_store("firstOrderCells",firstOrderCells) ;
    input("firstOrderCells") ;

    constraint("geom_cells,B_limiter") ;
    input("cellcenter,X,gradv3d(X)") ;
    input("upper->cr->X") ;
    input("upper->facecenter") ;
    input("lower->cl->X") ;
    input("boundary_map->X_f") ;
    input("lower->facecenter") ;
    output("limiterv3d(X)") ;
  }

  void get_limiter3d::calculate(Entity cc) {

    const vect3d Xcc = X[cc] ;
    vect3d qmax = Xcc ;
    vect3d qmin = qmax ;
    const tens3d Xgr = Xgrad[cc] ;

    for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
      const int fc = *fi ;
      qmin.x = min(qmin.x,X[cr[fc]].x) ;
      qmin.y = min(qmin.y,X[cr[fc]].y) ;
      qmin.z = min(qmin.z,X[cr[fc]].z) ;
      qmax.x = max(qmax.x,X[cr[fc]].x) ;
      qmax.y = max(qmax.y,X[cr[fc]].y) ;
      qmax.z = max(qmax.z,X[cr[fc]].z) ;
    }
    for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
      const int fc = *fi ;
      qmin.x = min(qmin.x,X[cl[fc]].x) ;
      qmin.y = min(qmin.y,X[cl[fc]].y) ;
      qmin.z = min(qmin.z,X[cl[fc]].z) ;
      qmax.x = max(qmax.x,X[cl[fc]].x) ;
      qmax.y = max(qmax.y,X[cl[fc]].y) ;
      qmax.z = max(qmax.z,X[cl[fc]].z) ;
    }
    for(const int *fi=boundary_map.begin(cc);fi!=boundary_map.end(cc);++fi) {
      const int fc = *fi ;
      qmin.x = min(qmin.x,X_f[fc].x) ;
      qmin.y = min(qmin.y,X_f[fc].y) ;
      qmin.z = min(qmin.z,X_f[fc].z) ;
      qmax.x = max(qmax.x,X_f[fc].x) ;
      qmax.y = max(qmax.y,X_f[fc].y) ;
      qmax.z = max(qmax.z,X_f[fc].z) ;
    }

    vect3d limi = vect3d(1.0,1.0,1.0) ;
    if(firstOrderCells[cc] != 0)
      limi = vect3d(0.0,0.0,0.0) ;
    
    for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
      const int fc = *fi ;
      const vect3d drl = facecenter[fc] - cellcenter[cc] ;
      vect3d Xf = Xcc + vect3d(dot(Xgr.x,drl),dot(Xgr.y,drl),dot(Xgr.z,drl)) ;
      vect3d qdif = Xf-Xcc ;
      vect3d lim = vect3d(1.0,1.0,1.0) ;
      if(qdif.x > 0)
        lim.x = min(real(1.0),(qmax.x-Xcc.x)/(qdif.x+1e-100)) ;
      if(qdif.x < 0)
        lim.x = min(real(1.0),(qmin.x-Xcc.x)/(qdif.x-1e-100)) ;
      if(qdif.y > 0)
        lim.y = min(real(1.0),(qmax.y-Xcc.y)/(qdif.y+1e-100)) ;
      if(qdif.y < 0)
        lim.y = min(real(1.0),(qmin.y-Xcc.y)/(qdif.y-1e-100)) ;
      if(qdif.z > 0)
        lim.z = min(real(1.0),(qmax.z-Xcc.z)/(qdif.z+1e-100)) ;
      if(qdif.z < 0)
        lim.z = min(real(1.0),(qmin.z-Xcc.z)/(qdif.z-1e-100)) ;
      limi.x = min (limi.x,lim.x) ;
      limi.y = min (limi.y,lim.y) ;
      limi.z = min (limi.z,lim.z) ;
    }
    
    for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
      const int fc = *fi ;
      const vect3d drl = facecenter[fc] - cellcenter[cc] ;
      vect3d Xf = Xcc + vect3d(dot(Xgr.x,drl),dot(Xgr.y,drl),dot(Xgr.z,drl)) ;
      vect3d qdif = Xf-Xcc ;
      vect3d lim = vect3d(1.0,1.0,1.0) ;
      if(qdif.x > 0)
        lim.x = min(real(1.0),(qmax.x-Xcc.x)/(qdif.x+1e-100)) ;
      if(qdif.x < 0)
        lim.x = min(real(1.0),(qmin.x-Xcc.x)/(qdif.x-1e-100)) ;
      if(qdif.y > 0)
        lim.y = min(real(1.0),(qmax.y-Xcc.y)/(qdif.y+1e-100)) ;
      if(qdif.y < 0)
        lim.y = min(real(1.0),(qmin.y-Xcc.y)/(qdif.y-1e-100)) ;
      if(qdif.z > 0)
        lim.z = min(real(1.0),(qmax.z-Xcc.z)/(qdif.z+1e-100)) ;
      if(qdif.z < 0)
        lim.z = min(real(1.0),(qmin.z-Xcc.z)/(qdif.z-1e-100)) ;
      limi.x = min (limi.x,lim.x) ;
      limi.y = min (limi.y,lim.y) ;
      limi.z = min (limi.z,lim.z) ;
    }
    
    limiter3d[cc] = limi ;
  }

  void get_limiter3d::compute(const sequence &seq) {
    do_loop(seq,this) ;
  }


  register_rule<get_limiter3d> register_get_limiter3d ;

  // The following is another way to get the limiter3d of gradient approach.
  class get_vlimiter3d : public pointwise_rule {
    store<vect3d> grad_limiter3d ;
    const_store<real> vol ;
    const_multiMap upper,lower,boundary_map ;
    const_Map cl, cr ;
    const_store<vect3d> cellcenter ;
    const_store<vect3d> facecenter ;
    const_store<vect3d> X, X_f ;
    const_store<tens3d> Xgrad ;
    const_param<real> Kl ;
    const_param<real> grid_vol ;
    const_store<char> firstOrderCells ;
    real Kl3 ;
  public:
    get_vlimiter3d() ;
    void calculate(Entity cc) ;
    virtual void compute(const sequence &seq) ;
  } ;

  get_vlimiter3d::get_vlimiter3d() {
    name_store("Kl",Kl) ;
    name_store("vol",vol) ;
    name_store("limiterv3d(X)",grad_limiter3d) ;
    name_store("cl",cl) ;
    name_store("cr",cr) ;
    name_store("upper",upper) ;
    name_store("lower",lower) ;
    name_store("boundary_map",boundary_map) ;
    name_store("facecenter",facecenter) ;
    name_store("cellcenter",cellcenter) ;
    name_store("X",X) ;
    name_store("X_f",X_f) ;
    name_store("gradv3d(X)",Xgrad) ;
    name_store("grid_vol",grid_vol) ;
    name_store("firstOrderCells",firstOrderCells) ;
    input("firstOrderCells") ;
    
    constraint("geom_cells,V_limiter") ;
    input("Kl,grid_vol") ;
    input("cellcenter,X,gradv3d(X),vol") ;
    input("upper->cr->X") ;
    input("upper->facecenter") ;
    input("lower->cl->X") ;
    input("lower->facecenter") ;
    input("boundary_map->X_f") ;
    output("limiterv3d(X)") ;
  }

  void get_vlimiter3d::calculate(Entity cc) {
    real refsq = dot(X[cc],X[cc]) ;
    int numrefs = 1 ;

    const vect3d Xcc = X[cc] ;
    vect3d qmax = Xcc ;
    vect3d qmin = qmax ;
    const tens3d &Xgr = Xgrad[cc];
    // Epsilon squared is equal to (Kl D)^3 where D is the diameter of
    // a sphere with the same volume as the given cell.
      
    for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
      const Entity fc = *fi ;
      const vect3d Xr = X[cr[fc]] ;
      qmin.x = min(qmin.x,Xr.x) ;
      qmin.y = min(qmin.y,Xr.y) ;
      qmin.z = min(qmin.z,Xr.z) ;
      qmax.x = max(qmax.x,Xr.x) ;
      qmax.y = max(qmax.y,Xr.y) ;
      qmax.z = max(qmax.z,Xr.z) ;
      refsq += dot(Xr,Xr) ;
      numrefs++ ;
    }
    for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
      const Entity fc = *fi ;
      const vect3d Xl = X[cl[fc]] ;
      qmin.x = min(qmin.x,Xl.x) ;
      qmin.y = min(qmin.y,Xl.y) ;
      qmin.z = min(qmin.z,Xl.z) ;
      qmax.x = max(qmax.x,Xl.x) ;
      qmax.y = max(qmax.y,Xl.y) ;
      qmax.z = max(qmax.z,Xl.z) ;
      refsq += dot(Xl,Xl) ;
      numrefs++ ;
    }
    for(const int *fi=boundary_map.begin(cc);fi!=boundary_map.end(cc);++fi) {
      const int fc = *fi ;
      const vect3d Xf = X_f[fc] ;
      qmin.x = min(qmin.x,Xf.x) ;
      qmin.y = min(qmin.y,Xf.y) ;
      qmin.z = min(qmin.z,Xf.z) ;
      qmax.x = max(qmax.x,Xf.x) ;
      qmax.y = max(qmax.y,Xf.y) ;
      qmax.z = max(qmax.z,Xf.z) ;
      refsq += dot(Xf,Xf) ;
      numrefs++ ;
    }
    const real ref = 1e-20+sqrt(refsq)/numrefs ;
     
    const real epsilon2 = Kl3*vol[cc]*ref*ref ;
    vect3d limi = vect3d(1.0,1.0,1.0) ;
    if(firstOrderCells[cc] != 0)
      limi = vect3d(0.0,0.0,0.0) ;
    
    for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
      const int fc = *fi ;
      const vect3d drl = facecenter[fc] - cellcenter[cc] ;
      vect3d Xf = Xcc + vect3d(dot(Xgr.x,drl),dot(Xgr.y,drl),dot(Xgr.z,drl)) ;
      vect3d qdif = Xcc -Xf ;

      vect3d lim = vect3d(1.0,1.0,1.0) ;
        
      if(fabs(qdif.x) > ref*1e-4) {
        const real deltap = (qdif.x>0.0)?qmin.x-Xcc.x:qmax.x-Xcc.x;
        const real deltam = -qdif.x ;
        lim.x = ((deltap*deltap+epsilon2)*deltam+ 2.0*deltam*deltam*deltap) /
          (deltam*(deltap*deltap+2.0*deltam*deltam+deltam*deltap+epsilon2)) ;
      }
      if(fabs(qdif.y) > ref*1e-4) {
        const real deltap = (qdif.y>0.0)?qmin.y-Xcc.y:qmax.y-Xcc.y;
        const real deltam = -qdif.y ;
        lim.y = ((deltap*deltap+epsilon2)*deltam+ 2.0*deltam*deltam*deltap) /
          (deltam*(deltap*deltap+2.0*deltam*deltam+deltam*deltap+epsilon2)) ;
      }
      if(fabs(qdif.z) > ref*1e-4) {
        const real deltap = (qdif.z>0.0)?qmin.z-Xcc.z:qmax.z-Xcc.z;
        const real deltam = -qdif.z ;
        lim.z = ((deltap*deltap+epsilon2)*deltam+ 2.0*deltam*deltam*deltap) /
          (deltam*(deltap*deltap+2.0*deltam*deltam+deltam*deltap+epsilon2)) ;
      }
      limi.x = min(limi.x,lim.x) ;
      limi.y = min(limi.y,lim.y) ;
      limi.z = min(limi.z,lim.z) ;
    }
    for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
      const int fc = *fi ;
      const vect3d drl = facecenter[fc] - cellcenter[cc] ;
      vect3d Xf = Xcc + vect3d(dot(Xgr.x,drl),dot(Xgr.y,drl),dot(Xgr.z,drl)) ;
      vect3d qdif = Xcc -Xf ;

      vect3d lim = vect3d(1.0,1.0,1.0) ;

      if(fabs(qdif.x) > ref*1e-4) {
        const real deltap = (qdif.x>0.0)?qmin.x-Xcc.x:qmax.x-Xcc.x;
        const real deltam = -qdif.x ;
        lim.x = ((deltap*deltap+epsilon2)*deltam+ 2.0*deltam*deltam*deltap) /
          (deltam*(deltap*deltap+2.0*deltam*deltam+deltam*deltap+epsilon2)) ;
      }
      if(fabs(qdif.y) > ref*1e-4) {
        const real deltap = (qdif.y>0.0)?qmin.y-Xcc.y:qmax.y-Xcc.y;
        const real deltam = -qdif.y ;
        lim.y = ((deltap*deltap+epsilon2)*deltam+ 2.0*deltam*deltam*deltap) /
          (deltam*(deltap*deltap+2.0*deltam*deltam+deltam*deltap+epsilon2)) ;
      }
      if(fabs(qdif.z) > ref*1e-4) {
        const real deltap = (qdif.z>0.0)?qmin.z-Xcc.z:qmax.z-Xcc.z;
        const real deltam = -qdif.z ;
        lim.z = ((deltap*deltap+epsilon2)*deltam+ 2.0*deltam*deltam*deltap) /
          (deltam*(deltap*deltap+2.0*deltam*deltam+deltam*deltap+epsilon2)) ;
      }
      limi.x = min(limi.x,lim.x) ;
      limi.y = min(limi.y,lim.y) ;
      limi.z = min(limi.z,lim.z) ;
    }
    grad_limiter3d[cc] = limi ;
  }

  void get_vlimiter3d::compute(const sequence &seq) {
    Kl3 = (*Kl)*(*Kl)*(*Kl)*6./pi/(*grid_vol) ;
    do_loop(seq,this) ;
  }

  register_rule<get_vlimiter3d> register_vlimiter3d ;

    class periodic_limiters : public pointwise_rule {
    store<real_t> limiters ;
    const_Map pmap,cl,cr ;
  public:
    periodic_limiters() {
      name_store("limiters(X)",limiters) ;
      name_store("pmap",pmap) ;
      name_store("cl",cl) ;
      name_store("cr",cr) ;
      input("pmap->cl->limiters(X)") ;
      output("cr->limiters(X)") ;
      constraint("periodicFaces,cl->X") ;
    }
    void calculate(Entity pf) {
      limiters[cr[pf]] = limiters[cl[pmap[pf]]] ;
    }
    void compute(const sequence &seq) {
      do_loop(seq,this) ;
    }
  } ;

  register_rule<periodic_limiters> periodic_limiters ;

  class periodic_limiterv : public pointwise_rule {
    storeVec<real_t > limiterv ;
    const_Map pmap,cl,cr ;
  public:
    periodic_limiterv() {
      name_store("limiterv(X)",limiterv) ;
      name_store("pmap",pmap) ;
      name_store("cl",cl) ;
      name_store("cr",cr) ;
      input("pmap->cl->limiterv(X)") ;
      output("cr->limiterv(X)") ;
      constraint("periodicFaces,cl->X") ;
    }
    void calculate(Entity pf) {
      for(int i=0;i<limiterv.vecSize();++i)
        limiterv[cr[pf]][i] = limiterv[cl[pmap[pf]]][i] ;
    }
    void compute(const sequence &seq) {
      do_loop(seq,this) ;
    }
  } ;


  register_rule<periodic_limiterv> periodic_limiterv ;

  class periodic_limiterv3d : public pointwise_rule {
    store<vector3d<real_t> > limiterv3d ;
    const_Map pmap,cl,cr ;
  public:
    periodic_limiterv3d() {
      name_store("limiterv3d(X)",limiterv3d) ;
      name_store("pmap",pmap) ;
      name_store("cl",cl) ;
      name_store("cr",cr) ;
      input("pmap->cl->limiterv3d(X)") ;
      output("cr->limiterv3d(X)") ;
      constraint("periodicFaces,cl->X") ;
    }
    void calculate(Entity pf) {
      limiterv3d[cr[pf]] = limiterv3d[cl[pmap[pf]]] ;
    }
    void compute(const sequence &seq) {
      do_loop(seq,this) ;
    }
  } ;

  register_rule<periodic_limiterv3d> periodic_limiterv3d ;


  // Nodal Barth Limiter
  class nodal_barth_scalar : public pointwise_rule {

    store<real> limiter ;
    const_multiMap upper, lower, boundary_map ;
    const_multiMap face2node ;
    const_store<real> X ;
    const_store<vect3d> pos,cellcenter ;
    const_store<real> nodMax,nodMin ;
    const_store<vect3d> Xgrad ;
    const_store<char> firstOrderCells ;
    int vs ;
  public:
    nodal_barth_scalar() ;
    void calculate(Entity cc) ;
    virtual void compute(const sequence &seq) ;
  } ;

  nodal_barth_scalar::nodal_barth_scalar() {
    name_store("limiters(X)",limiter) ;
    name_store("upper",upper) ;
    name_store("lower",lower) ;
    name_store("boundary_map",boundary_map) ;
    name_store("cellcenter",cellcenter) ;
    name_store("face2node",face2node) ;
    name_store("pos",pos) ;
    name_store("X",X) ;
    name_store("NGTNodalMax(X)",nodMax) ;
    name_store("NGTNodalMin(X)",nodMin) ;
    name_store("grads(X)",Xgrad) ;
    name_store("firstOrderCells",firstOrderCells) ;
    input("firstOrderCells") ;

    constraint("geom_cells,NB_limiter") ;
    input("cellcenter,X,grads(X)") ;
    input("upper->face2node->(pos,NGTNodalMax(X),NGTNodalMin(X))") ;
    input("lower->face2node->(pos,NGTNodalMax(X),NGTNodalMin(X))") ;
    input("boundary_map->face2node->(pos,NGTNodalMax(X),NGTNodalMin(X))") ;
    output("limiters(X)") ;
  }

  void nodal_barth_scalar::calculate(Entity cc) {

    const real Xcc = X[cc] ;
    const vect3d Xgr = Xgrad[cc] ;
    const vect3d cent = cellcenter[cc] ;
    real lim = 1.0 ;
    if(firstOrderCells[cc] != 0)
      lim = 0 ;
    
    for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
      const int fc = *fi ;
      int fsz = face2node[fc].size() ;
      for(int i=0;i<fsz;++i) {
        const int nd = face2node[fc][i] ;
        const vect3d drl = pos[nd] - cent ;
        real Xf = Xcc + dot(Xgr,drl) ;
        real qdif = Xf-Xcc ;
        if(qdif > 0)
          lim = min(lim,(nodMax[nd]-Xcc)/(qdif+1e-100)) ;
        if(qdif < 0)
          lim = min(lim,(nodMin[nd]-Xcc)/(qdif-1e-100)) ;
      }
    }
    
    for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
      const int fc = *fi ;
      int fsz = face2node[fc].size() ;
      for(int i=0;i<fsz;++i) {
        const int nd = face2node[fc][i] ;
        const vect3d drl = pos[nd] - cent ;
        real Xf = Xcc + dot(Xgr,drl) ;
        real qdif = Xf-Xcc ;
        if(qdif > 0)
          lim = min(lim,(nodMax[nd]-Xcc)/(qdif+1e-100)) ;
        if(qdif < 0)
          lim = min(lim,(nodMin[nd]-Xcc)/(qdif-1e-100)) ;
      }
    }    
    limiter[cc] = lim ;
  }

  void nodal_barth_scalar::compute(const sequence &seq) {
    do_loop(seq,this) ;
  }


  register_rule<nodal_barth_scalar> register_nodal_barth_scalar ;

  class nodal_barth_3d : public pointwise_rule {
    store<vect3d> limiter3d ;
    const_multiMap upper, lower, boundary_map ;
    const_multiMap face2node ;
    const_store<vect3d> cellcenter ;
    const_store<vect3d> pos ;
    const_store<vect3d> nodMax,nodMin ;
    const_store<vect3d> X ;
    const_store<tens3d> Xgrad ;
    const_store<char> firstOrderCells ;
    int vs ;
  public:
    nodal_barth_3d() ;
    void calculate(Entity cc) ;
    virtual void compute(const sequence &seq) ;
  } ;

  nodal_barth_3d::nodal_barth_3d() {
    name_store("limiterv3d(X)",limiter3d) ;
    name_store("upper",upper) ;
    name_store("lower",lower) ;
    name_store("boundary_map",boundary_map) ;
    name_store("cellcenter",cellcenter) ;
    name_store("face2node",face2node) ;
    name_store("pos",pos) ;
    name_store("NGTNodalv3dMax(X)",nodMax) ;
    name_store("NGTNodalv3dMin(X)",nodMin) ;
    name_store("X",X) ;
    name_store("gradv3d(X)",Xgrad) ;
    name_store("firstOrderCells",firstOrderCells) ;
    input("firstOrderCells") ;

    constraint("geom_cells,NB_limiter") ;
    input("cellcenter,X,gradv3d(X)") ;
    input("upper->face2node->(pos,NGTNodalv3dMax(X),NGTNodalv3dMin(X))") ;
    input("lower->face2node->(pos,NGTNodalv3dMax(X),NGTNodalv3dMin(X))") ;
    input("boundary_map->face2node->(pos,NGTNodalv3dMax(X),NGTNodalv3dMin(X))") ;

    output("limiterv3d(X)") ;
  }

  void nodal_barth_3d::calculate(Entity cc) {

    const vect3d Xcc = X[cc] ;
    const tens3d Xgr = Xgrad[cc] ;
    const vect3d cent = cellcenter[cc] ;

    vect3d lim = vect3d(1.0,1.0,1.0) ;
    if(firstOrderCells[cc] != 0)
      lim = vect3d(0.0,0.0,0.0) ;
    for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
      const int fc = *fi ;
      int fsz = face2node[fc].size() ;
      for(int i=0;i<fsz;++i) {
        const int nd = face2node[fc][i] ;
        const vect3d drl = pos[nd] - cent ;
        vect3d Xf = Xcc + vect3d(dot(Xgr.x,drl),dot(Xgr.y,drl),dot(Xgr.z,drl)) ;
        vect3d qdif = Xf-Xcc ;
        if(qdif.x > 0)
          lim.x = min(lim.x,(nodMax[nd].x-Xcc.x)/(qdif.x+1e-100)) ;
        if(qdif.x < 0)
          lim.x = min(lim.x,(nodMin[nd].x-Xcc.x)/(qdif.x-1e-100)) ;
        if(qdif.y > 0)
          lim.y = min(lim.y,(nodMax[nd].y-Xcc.y)/(qdif.y+1e-100)) ;
        if(qdif.y < 0)
          lim.y = min(lim.y,(nodMin[nd].y-Xcc.y)/(qdif.y-1e-100)) ;
        if(qdif.z > 0)
          lim.z = min(lim.z,(nodMax[nd].z-Xcc.z)/(qdif.z+1e-100)) ;
        if(qdif.z < 0)
          lim.z = min(lim.z,(nodMin[nd].z-Xcc.z)/(qdif.z-1e-100)) ;
      }
    }
    
    for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
      const int fc = *fi ;
      int fsz = face2node[fc].size() ;
      for(int i=0;i<fsz;++i) {
        const int nd = face2node[fc][i] ;
        const vect3d drl = pos[nd] - cent ;
        vect3d Xf = Xcc + vect3d(dot(Xgr.x,drl),dot(Xgr.y,drl),dot(Xgr.z,drl)) ;
        vect3d qdif = Xf-Xcc ;
        if(qdif.x > 0)
          lim.x = min(lim.x,(nodMax[nd].x-Xcc.x)/(qdif.x+1e-100)) ;
        if(qdif.x < 0)
          lim.x = min(lim.x,(nodMin[nd].x-Xcc.x)/(qdif.x-1e-100)) ;
        if(qdif.y > 0)
          lim.y = min(lim.y,(nodMax[nd].y-Xcc.y)/(qdif.y+1e-100)) ;
        if(qdif.y < 0)
          lim.y = min(lim.y,(nodMin[nd].y-Xcc.y)/(qdif.y-1e-100)) ;
        if(qdif.z > 0)
          lim.z = min(lim.z,(nodMax[nd].z-Xcc.z)/(qdif.z+1e-100)) ;
        if(qdif.z < 0)
          lim.z = min(lim.z,(nodMin[nd].z-Xcc.z)/(qdif.z-1e-100)) ;
      }
    }
    
    limiter3d[cc] = lim ;
  }

  void nodal_barth_3d::compute(const sequence &seq) {
    do_loop(seq,this) ;
  }


  register_rule<nodal_barth_3d> register_nodal_barth_3d ;

  class nodal_barth_vec : public pointwise_rule {
    storeVec<real> limiterv ;
    const_multiMap upper, lower, boundary_map ;
    const_Map cl, cr ;
    const_store<vect3d> cellcenter ;
    const_store<vect3d> facecenter ;
    const_storeVec<real> X, X_f ;
    const_storeVec<vect3d> Xgrad ;
    const_store<char> firstOrderCells ;
  public:
    nodal_barth_vec() ;
    void calculate(Entity cc) ;
    virtual void compute(const sequence &seq) ;
  } ;

  nodal_barth_vec::nodal_barth_vec() {
    name_store("limiterv(X)",limiterv) ;
    name_store("cl",cl) ;
    name_store("cr",cr) ;
    name_store("upper",upper) ;
    name_store("lower",lower) ;
    name_store("boundary_map",boundary_map) ;
    name_store("facecenter",facecenter) ;
    name_store("cellcenter",cellcenter) ;
    name_store("X",X) ;
    name_store("X_f",X_f) ;
    name_store("gradv(X)",Xgrad) ;
    name_store("firstOrderCells",firstOrderCells) ;
    input("firstOrderCells") ;

    constraint("geom_cells,NB_limiter") ;
    input("cellcenter,X,gradv(X)") ;
    input("upper->cr->X") ;
    input("upper->facecenter") ;
    input("lower->cl->X") ;
    input("lower->facecenter") ;
    input("boundary_map->X_f") ;
    input("boundary_map->facecenter") ;
    output("limiterv(X)") ;
  }

  void nodal_barth_vec::calculate(Entity cc) {
    const int vs = X.vecSize() ;
    for(int i=0;i<vs;++i) {
      const real Xcc = X[cc][i] ;
      real qmax = Xcc ;
      real qmin = qmax ;
      const vect3d Xgr = Xgrad[cc][i] ;

      for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
        const int fc = *fi ;
        qmin = min(qmin,X[cr[fc]][i]) ;
        qmax = max(qmax,X[cr[fc]][i]) ;
      }
      for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
        const int fc = *fi ;
        qmin = min(qmin,X[cl[fc]][i]) ;
        qmax = max(qmax,X[cl[fc]][i]) ;
      }

      for(const int *fi=boundary_map.begin(cc);fi!=boundary_map.end(cc);++fi) {
        const int fc = *fi ;
        qmin = min(qmin,X_f[fc][i]) ;
        qmax = max(qmax,X_f[fc][i]) ;
      }

      real limi = 1.0 ;
      if(firstOrderCells[cc] != 0)
        limi = 0.0 ;
      for(const int *fi=upper.begin(cc);fi!=upper.end(cc);++fi) {
        const int fc = *fi ;
        const vect3d drl = facecenter[fc] - cellcenter[cc] ;
        real Xf = Xcc + dot(Xgr,drl) ;
        real qdif = Xf-Xcc ;
        real lim = 1.0 ;
        if(qdif > 0)
          lim = min(real(1.0),(qmax-Xcc)/(qdif+1e-100)) ;
        if(qdif < 0)
          lim = min(real(1.0),(qmin-Xcc)/(qdif-1e-100)) ;
        limi = min (limi,lim) ;
      }
     
      for(const int *fi=lower.begin(cc);fi!=lower.end(cc);++fi) {
        const int fc = *fi ;
        const vect3d drl = facecenter[fc] - cellcenter[cc] ;
        real Xf = Xcc + dot(Xgr,drl) ;
        real qdif = Xf-Xcc ;
        real lim = 1.0 ;
        if(qdif > 0)
          lim = min(real(1.0),(qmax-Xcc)/(qdif+1e-100)) ;
        if(qdif < 0)
          lim = min(real(1.0),(qmin-Xcc)/(qdif-1e-100)) ;
        limi = min (limi,lim) ;
      }

      for(const int *fi=boundary_map.begin(cc);fi!=boundary_map.end(cc);++fi) {
        const int fc = *fi ;
        const vect3d drl = facecenter[fc] - cellcenter[cc] ;
        real Xf = Xcc + dot(Xgr,drl) ;
        real qdif = Xf-Xcc ;
        real lim = 1.0 ;
        if(qdif > 0)
          lim = min(real(1.0),(qmax-Xcc)/(qdif+1e-100)) ;
        if(qdif < 0)
          lim = min(real(1.0),(qmin-Xcc)/(qdif-1e-100)) ;
        limi = min (limi,lim) ;
      }
      
      limiterv[cc][i] = limi ;
    }
  }

  void nodal_barth_vec::compute(const sequence &seq) {
    limiterv.setVecSize(X.vecSize()) ;
    do_loop(seq,this) ;
  }

  register_rule<nodal_barth_vec> register_nodal_barth_vec ;
    
}
