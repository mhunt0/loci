//#############################################################################
//#
//# Copyright 2008, 2015, Mississippi State University
//#
//# This file is part of the Loci Framework.
//#
//# The Loci Framework is free software: you can redistribute it and/or modify
//# it under the terms of the Lesser GNU General Public License as published by
//# the Free Software Foundation, either version 3 of the License, or
//# (at your option) any later version.
//#
//# The Loci Framework is distributed in the hope that it will be useful,
//# but WITHOUT ANY WARRANTY; without even the implied warranty of
//# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//# Lesser GNU General Public License for more details.
//#
//# You should have received a copy of the Lesser GNU General Public License
//# along with the Loci Framework.  If not, see <http://www.gnu.org/licenses>
//#
//#############################################################################
#include <Loci.h>
$include "FVM.lh"

#include <vector>
#include <algorithm>
using std::vector ;
using std::sort ;
using std::unique ;


namespace Loci {
  typedef vector3d<real_t> vect3d ;
  typedef real_t real ;

  $type sim_nodes param<bool> ;

  $rule singleton(face2node->sim_nodes),constraint(face2node->pos) {
    $sim_nodes = true ;
  }

  $type vecSize(X) param<int> ;
  $type X storeVec<real_t> ;

  $rule unit(vecSize(X)), constraint(UNIVERSE) {
    $vecSize(X) = 0 ;
  }


  $rule apply(vecSize(X)<-X)[Loci::Maximum], prelude {
    join(*$vecSize(X),$X.vecSize()) ;
  } ;

  $type nodalw_sum store<float> ;

  $rule unit(nodalw_sum), constraint(pos) {
    $nodalw_sum = 0 ;
  }

  $rule apply((upper,lower,boundary_map)->face2node->nodalw_sum<-(upper,lower,boundary_map)->face2node->nodalw_sum,cellcenter,(upper,lower,boundary_map)->face2node->pos)[Loci::Summation],constraint(geom_cells) {
    int sztot = 0 ;
    
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      sztot += fi->$face2node.size() ;
    
    vector<Entity> node_list(sztot) ;
    int cnt = 0 ;
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;

    sort(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ne = unique(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ns = node_list.begin() ;
    for(vector<Entity>::iterator vi = ns;vi!=ne;++vi) {
      const real_t weight = 1./norm(vi->$pos-$cellcenter) ;
      join(vi->$nodalw_sum,realToFloat(weight)) ;
    }

  }


  $type nodal_sum(X) storeVec<float> ;
  $rule unit(nodal_sum(X)<-vecSize(X)),constraint(pos),prelude {
    $nodal_sum(X).setVecSize(*$vecSize(X)) ;
  } compute {
    $nodal_sum(X) = mk_Scalar(0.0) ;
  }

  $rule apply((upper,lower,boundary_map)->face2node->nodal_sum(X)<-
	      (upper,lower,boundary_map)->face2node->pos,cellcenter,X)
  [Loci::Summation],constraint(geom_cells) {
    int sztot = 0 ;
    
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      sztot += fi->$face2node.size() ;
    
    vector<Entity> node_list(sztot) ;
    int cnt = 0 ;
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;

    sort(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ne = unique(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ns = node_list.begin() ;
    const int vs = $*X.vecSize() ;
    for(vector<int>::iterator vi = ns;vi!=ne;++vi) {
      int nd = *vi ;
      const real weight = 1./norm($*pos[nd]-$cellcenter) ;
      for(int i=0;i<vs;++i)
        $*nodal_sum(X)[nd][i] += realToFloat(weight*$X[i]) ;
    }
  }
    

  $type cell2node_v(X) storeVec<float> ;

  $rule pointwise(cell2node_v(X)<-nodal_sum(X),nodalw_sum),constraint(pos),
    prelude {
    $cell2node_v(X).setVecSize($nodal_sum(X).vecSize()) ;
  } compute {
    double rsum = 1./(double($nodalw_sum)+1e-20) ;
    for(int i=0;i<$*nodal_sum(X).vecSize();++i) {
      $cell2node_v(X)[i] = $nodal_sum(X)[i]*rsum ;
    }
  }

  $type boundary_node param<bool> ;
  
  $rule singleton(face2node->boundary_node),constraint(ci,no_symmetry_BC) {
  }

  $type boundary_nodalw_sum store<float> ;
  
  $rule unit(boundary_nodalw_sum),constraint(pos) {
    $boundary_nodalw_sum = 0 ;
  }

  $rule apply(face2node->boundary_nodalw_sum<-face2node->(pos,boundary_nodalw_sum),facecenter)[Loci::Summation],constraint(ci,no_symmetry_BC) {
    int fsz = $face2node.size() ;
    for(int i=0;i<fsz;++i) {
      const real weight = 1./norm($face2node[i]->$pos-$facecenter) ;
      $face2node[i]->$boundary_nodalw_sum += realToFloat(weight) ;
    }
  }

  $type boundary_nodal_sum(X) storeVec<float> ;
  
  $rule unit(boundary_nodal_sum(X)<-vecSize(X)), prelude {
    $boundary_nodal_sum(X).setVecSize(*$vecSize(X)) ;
  } compute {
    $boundary_nodal_sum(X) = mk_Scalar(0.0) ;
  }

  $type X_f storeVec<real> ;
  
  $rule apply(face2node->boundary_nodal_sum(X)<-face2node->(pos,boundary_nodal_sum(X)),X_f,facecenter)[Loci::Summation],constraint(ci,no_symmetry_BC) {
    int fsz = $face2node.size() ;
    for(int i=0;i<fsz;++i) {
      const real weight = 1./norm($face2node[i]->$pos-$facecenter) ;
      for(int j=0;j<$*boundary_nodal_sum(X).vecSize();++j)
	$face2node[i]->$boundary_nodal_sum(X)[j] += realToFloat($X_f[j]*weight) ;
    }
  }

  $rule pointwise(boundary::cell2node_v(X)<-boundary_nodalw_sum,boundary_nodal_sum(X)),constraint(boundary_node), prelude {
    $cell2node_v(X).setVecSize($boundary_nodal_sum(X).vecSize()) ;
  } compute {
      double rsum = 1./(double($boundary_nodalw_sum)+1e-20) ;
      for(int i=0;i<$*boundary_nodal_sum(X).vecSize();++i) {
        $cell2node_v(X)[i] = $boundary_nodal_sum(X)[i]*rsum ;
      }
  }

  $type c2n_scalar_sum(X) store<float> ;

  $rule unit(c2n_scalar_sum(X) ), constraint(pos)  { $c2n_scalar_sum(X) = 0 ; }

  $type X store<real> ;

  $rule apply((upper,lower,boundary_map)->face2node->c2n_scalar_sum(X) <-
	      (upper,lower,boundary_map)->face2node->pos,cellcenter,X)[Loci::Summation],
    constraint(geom_cells) {
    int sztot = 0 ;
    
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      sztot += fi->$face2node.size() ;
    
    vector<Entity> node_list(sztot) ;
    int cnt = 0 ;
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;

    sort(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ne = unique(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ns = node_list.begin() ;

    for(vector<int>::iterator vi = ns;vi!=ne;++vi) {
      int nd = *vi ;
      const real weight = 1./norm($*pos[nd]-$cellcenter) ;
      join($*c2n_scalar_sum(X)[nd],realToFloat($X*weight)) ;
    }
  } 

  $rule pointwise(cell2node(X)<-c2n_scalar_sum(X),nodalw_sum),constraint(pos) {
    double rsum = 1./(double($nodalw_sum)+1e-20) ;
    $cell2node(X) = $c2n_scalar_sum(X)*rsum ;
  }   

  $type boundary_scalar_sum(X) store<float> ;
  $rule unit(boundary_scalar_sum(X)), constraint(pos) {
    $boundary_scalar_sum(X) = 0 ;
  }

  $type X_f store<real_t> ;
  $rule apply(face2node->boundary_scalar_sum(X)<-
	      face2node->pos,X_f,facecenter)[Loci::Summation],
    constraint(ci->X,no_symmetry_BC) {
    int fsz = $face2node.size() ;
    for(int i=0;i<fsz;++i) {
      const real weight = 1./norm($face2node[i]->$pos-$facecenter) ;
      $face2node[i]->$boundary_scalar_sum(X) += realToFloat($X_f*weight) ;
    }
  }

  $rule pointwise(boundary::cell2node(X)<-boundary_scalar_sum(X),boundary_nodalw_sum),constraint(boundary_node) {
      double rsum = 1./(double($boundary_nodalw_sum)+1e-20) ;
      $cell2node(X) = $boundary_scalar_sum(X)*rsum ;
  }

  $type c2n_v3d_sum(X) store<vector3d<float> > ;
  
  $rule unit(c2n_v3d_sum(X)),constraint(pos) {
    $c2n_v3d_sum(X) = vector3d<float>(0.,0.,0.) ;
  }

  $type X store<vect3d> ;
  
  $rule apply((upper,lower,boundary_map)->face2node->c2n_v3d_sum(X)<-
	      X,cellcenter,(upper,lower,boundary_map)->face2node->pos)[Loci::Summation],
    constraint(geom_cells) {
    int sztot = 0 ;
    
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      sztot += fi->$face2node.size() ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      sztot += fi->$face2node.size() ;
    
    vector<Entity> node_list(sztot) ;
    int cnt = 0 ;
    for(const Entity *fi=$upper.begin();fi!=$upper.end();++fi)
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$lower.begin();fi!=$lower.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;
    for(const Entity *fi=$boundary_map.begin();fi!=$boundary_map.end();++fi) 
      for(const Entity *ni=fi->$face2node.begin();ni!=fi->$face2node.end();++ni)
        node_list[cnt++] = *ni ;

    sort(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ne = unique(node_list.begin(),node_list.end()) ;
    vector<Entity>::iterator ns = node_list.begin() ;

    for(vector<int>::iterator vi = ns;vi!=ne;++vi) {
      int nd = *vi ;
      const real weight = 1./norm($*pos[nd]-$cellcenter) ;
      vector3d<float> v(realToFloat($X.x*weight),
			realToFloat($X.y*weight),
			realToFloat($X.z*weight)) ;
      join($*c2n_v3d_sum(X)[nd],v) ;
    }
  }

  $type cell2node_v3d(X) store<vector3d<float> > ;
  $rule pointwise(cell2node_v3d(X)<-c2n_v3d_sum(X),nodalw_sum) {
    double rsum = 1./(double($nodalw_sum)+1e-20) ;
    $cell2node_v3d(X) = $c2n_v3d_sum(X)*rsum ;
  }
  $type boundary_v3d_sum(X) store<vector3d<float> > ;
  
  $rule unit(boundary_v3d_sum(X)),constraint(pos) {
    $boundary_v3d_sum(X) = vector3d<float>(0.0,0.0,0.0) ;
  }

  $type X_f store<vect3d> ;
  
  $rule apply(face2node->boundary_v3d_sum(X)<-face2node->pos,X_f,facecenter)[Loci::Summation],constraint(ci,no_symmetry_BC) {
    int fsz = $face2node.size();
    for(int i=0;i<fsz;++i) {
      const real weight = 1./norm($face2node[i]->$pos-$facecenter) ;
      vector3d<float> v(realToFloat($X_f.x*weight),
			realToFloat($X_f.y*weight),
			realToFloat($X_f.z*weight)) ;
      $face2node[i]->$boundary_v3d_sum(X) += v ;
    }
  }

  $rule pointwise(boundary::cell2node_v3d(X)<-
		  boundary_v3d_sum(X),boundary_nodalw_sum),
    constraint(boundary_node) {
      double rsum = 1./(double($boundary_nodalw_sum)+1e-20) ;
      $cell2node_v3d(X) = $boundary_v3d_sum(X)*rsum ;
  }

  class scalar_error_unit : public unit_rule {
    store<float> node_error ;
  public:
    scalar_error_unit() {
      name_store("scalar_node_error(L,R)",node_error) ;
      constraint("pos") ;
      output("scalar_node_error(L,R)") ;
    }
    void calculate(Entity e) {
      node_error[e] = 0. ;
    }
    void compute(const sequence &seq) {
      do_loop(seq,this) ;
    }
  } ;

  register_rule<scalar_error_unit> register_scalar_error_unit ;

  class scalar_error_apply: public apply_rule<store<float>,
                            Loci::Maximum<float> > {

    const_store<real_t> L,R ;
    const_multiMap face2node ;
    store<float> node_error ;
  public:
    scalar_error_apply() {
      name_store("face2node",face2node) ;
      name_store("L",L) ;
      name_store("R",R) ;
      name_store("scalar_node_error(L,R)",node_error) ;
      input("L,R") ;
      input("face2node->scalar_node_error(L,R)") ;
      output("face2node->scalar_node_error(L,R)") ;
    }
    void calculate(Entity e) {
      float err = realToFloat(fabs(L[e]-R[e])) ;
      for(const Entity *n = face2node.begin(e);n!=face2node.end(e);++n) {
        join(node_error[*n],err) ;
      }
    }
    void compute(const sequence &seq) {
      do_loop(seq,this) ;
    }
  } ;

  register_rule<scalar_error_apply> register_scalar_error_apply ;

  class scalar_cell_error_unit : public unit_rule {
    store<real_t> node_error ;
  public:
    scalar_cell_error_unit() {
      name_store("scalar_cell_error(L,R)",node_error) ;
      constraint("geom_cells") ;
      output("scalar_cell_error(L,R)") ;
    }
    void calculate(Entity e) {
      node_error[e] = 0. ;
    }
    void compute(const sequence &seq) {
      do_loop(seq,this) ;
    }
  } ;

  register_rule<scalar_cell_error_unit> register_scalar_cell_error_unit ;

  class scalar_cell_error_apply: public apply_rule<store<real_t>,
                            Loci::Maximum<real_t> > {

    const_store<real_t> L,R ;
    const_Map cl,cr ;
    store<real_t> node_error ;
  public:
    scalar_cell_error_apply() {
      name_store("cl",cl) ;
      name_store("cr",cr) ;
      name_store("L",L) ;
      name_store("R",R) ;
      name_store("scalar_cell_error(L,R)",node_error) ;
      input("L,R") ;
      constraint("(cl,cr)->geom_cells") ;
      input("(cl,cr)->scalar_cell_error(L,R)") ;
      output("(cl,cr)->scalar_cell_error(L,R)") ;
    }
    void calculate(Entity e) {
      real_t err = fabs(L[e]-R[e]) ;
      join(node_error[cl[e]],err) ;
      join(node_error[cr[e]],err) ;
    }
    void compute(const sequence &seq) {
      do_loop(seq,this) ;
    }
  } ;

  register_rule<scalar_cell_error_apply> register_scalar_cell_error_apply ;


  class face2nodeMax_unit : public unit_rule {
    store<float> nodeval ;
  public:
    face2nodeMax_unit() {
      name_store("face2nodeMax(X)",nodeval) ;
      constraint("pos") ;
      output("face2nodeMax(X)") ;
    }
    void calculate(Entity e) {
      nodeval[e] = 0. ;
    }
    void compute(const sequence &seq) {
      do_loop(seq,this) ;
    }
  } ;

  register_rule<face2nodeMax_unit> register_face2nodeMax_unit ;

  class face2nodeMax_apply: public apply_rule<store<float>,
                            Loci::Maximum<float> > {

    const_store<real_t> X ;
    const_multiMap face2node ;
    store<float> nodeval ;
  public:
    face2nodeMax_apply() {
      name_store("face2node",face2node) ;
      name_store("X",X) ;
      name_store("face2nodeMax(X)",nodeval) ;
      input("X") ;
      input("face2node->face2nodeMax(X)") ;
      output("face2node->face2nodeMax(X)") ;
    }
    void calculate(Entity e) {
      double val = realToDouble(X[e]) ;
      for(const Entity *ep = face2node.begin(e);ep!=face2node.end(e);++ep)
        join(nodeval[*ep],val) ;
    }
    void compute(const sequence &seq) {
      do_loop(seq,this) ;
    }
  } ;

  register_rule<face2nodeMax_apply> register_face2nodeMax_apply ;

  class cell2nodeMax : public unit_rule {
    store<float> node_value ;
  public:
    cell2nodeMax() {
      name_store("cell2nodeMax(X)",node_value) ;
      constraint("pos") ;
      output("cell2nodeMax(X)") ;
    }
    void calculate(Entity e) {
      node_value[e] = std::numeric_limits<float>::min() ;
    }
    void compute(const sequence &seq) {
      do_loop(seq,this) ;
    }
  } ;

  register_rule<cell2nodeMax> register_cell2nodeMax ;

  class c2nMax : public apply_rule<store<float>, Loci::Maximum<float> > {
    const_multiMap upper, lower, boundary_map ;
    const_multiMap face2node ;
    const_store<real> X ;

    store<float> cell2nodeMax ;
    vector<int> node_list ;
  public:
    c2nMax() ;
    void calculate(Entity cc) ;
    virtual void compute(const sequence &seq) ;
  } ;

  c2nMax::c2nMax() {
    name_store("cell2nodeMax(X)",cell2nodeMax) ;
    name_store("face2node",face2node) ;
    name_store("upper",upper) ;
    name_store("lower",lower) ;
    name_store("boundary_map",boundary_map) ;
    name_store("X",X) ;

    constraint("geom_cells") ;
    input("X") ;
    input("(upper,lower,boundary_map)->face2node->cell2nodeMax(X)") ;
    output("(upper,lower,boundary_map)->face2node->cell2nodeMax(X)") ;
  }

  void c2nMax::calculate(Entity cc) {

    node_list.clear() ;
    for(const Entity *fi=upper.begin(cc);fi!=upper.end(cc);++fi)
      for(const Entity *ni=face2node.begin(*fi);ni!=face2node.end(*fi);++ni)
        node_list.push_back(*ni) ;
    for(const Entity *fi=lower.begin(cc);fi!=lower.end(cc);++fi) 
      for(const Entity *ni=face2node.begin(*fi);ni!=face2node.end(*fi);++ni)
        node_list.push_back(*ni) ;
    for(const Entity *fi=boundary_map.begin(cc);fi!=boundary_map.end(cc);++fi) 
      for(const Entity *ni=face2node.begin(*fi);ni!=face2node.end(*fi);++ni)
        node_list.push_back(*ni) ;
    sort(node_list.begin(),node_list.end()) ;
    vector<int>::iterator ns = node_list.begin() ;
    vector<int>::iterator ne = unique(node_list.begin(),node_list.end()) ;
    
    
    
    for(vector<int>::iterator vi = ns;vi!=ne;++vi) {
      int nd = *vi ;
      join(cell2nodeMax[nd],realToFloat(X[cc])) ;
    }

  }

  void c2nMax::compute(const sequence &seq) {
    do_loop(seq,this) ;
  }

  register_rule<c2nMax> register_c2nMax ;

  class cell2nodeMaxMag : public unit_rule {
    store<float> node_value ;
  public:
    cell2nodeMaxMag() {
      name_store("cell2nodeMaxMag(X)",node_value) ;
      constraint("pos") ;
      output("cell2nodeMaxMag(X)") ;
    }
    void calculate(Entity e) {
      node_value[e] = 0 ;
    }
    void compute(const sequence &seq) {
      do_loop(seq,this) ;
    }
  } ;

  register_rule<cell2nodeMaxMag> register_cell2nodeMaxMag ;

  struct max_mag_join {
    void operator()(float &f1, const float &f2) {
      if(fabs(f2) > fabs(f1))
        f1 = f2 ;
    }
  } ;
  
  class c2nMaxMag : public apply_rule<store<float>, max_mag_join > {
    const_multiMap upper, lower, boundary_map ;
    const_multiMap face2node ;
    const_store<real> X ;

    store<float> cell2nodeMaxMag ;
    vector<int> node_list ;
  public:
    c2nMaxMag() ;
    void calculate(Entity cc) ;
    virtual void compute(const sequence &seq) ;
  } ;

  c2nMaxMag::c2nMaxMag() {
    name_store("cell2nodeMaxMag(X)",cell2nodeMaxMag) ;
    name_store("face2node",face2node) ;
    name_store("upper",upper) ;
    name_store("lower",lower) ;
    name_store("boundary_map",boundary_map) ;
    name_store("X",X) ;

    constraint("geom_cells") ;
    input("X") ;
    input("(upper,lower,boundary_map)->face2node->cell2nodeMaxMag(X)") ;
    output("(upper,lower,boundary_map)->face2node->cell2nodeMaxMag(X)") ;
  }

  void c2nMaxMag::calculate(Entity cc) {

    node_list.clear() ;
    for(const Entity *fi=upper.begin(cc);fi!=upper.end(cc);++fi)
      for(const Entity *ni=face2node.begin(*fi);ni!=face2node.end(*fi);++ni)
        node_list.push_back(*ni) ;
    for(const Entity *fi=lower.begin(cc);fi!=lower.end(cc);++fi) 
      for(const Entity *ni=face2node.begin(*fi);ni!=face2node.end(*fi);++ni)
        node_list.push_back(*ni) ;
    for(const Entity *fi=boundary_map.begin(cc);fi!=boundary_map.end(cc);++fi) 
      for(const Entity *ni=face2node.begin(*fi);ni!=face2node.end(*fi);++ni)
        node_list.push_back(*ni) ;
    sort(node_list.begin(),node_list.end()) ;
    vector<int>::iterator ns = node_list.begin() ;
    vector<int>::iterator ne = unique(node_list.begin(),node_list.end()) ;
    
    
    
    for(vector<int>::iterator vi = ns;vi!=ne;++vi) {
      int nd = *vi ;
      join(cell2nodeMaxMag[nd],realToFloat(X[cc])) ;
    }

  }

  void c2nMaxMag::compute(const sequence &seq) {
    do_loop(seq,this) ;
  }

  register_rule<c2nMaxMag> register_c2nMaxMag ;

  class cell2nodeMin : public unit_rule {
    store<float> node_value ;
  public:
    cell2nodeMin() {
      name_store("cell2nodeMin(X)",node_value) ;
      constraint("pos") ;
      output("cell2nodeMin(X)") ;
    }
    void calculate(Entity e) {
      node_value[e] = std::numeric_limits<float>::max() ;
    }
    void compute(const sequence &seq) {
      do_loop(seq,this) ;
    }
  } ;

  register_rule<cell2nodeMin> register_cell2nodeMin ;

  class c2nMin : public apply_rule<store<float>, Loci::Minimum<float> > {
    const_multiMap upper, lower, boundary_map ;
    const_multiMap face2node ;
    const_store<real> X ;

    store<float> cell2nodeMin ;
    vector<int> node_list ;
  public:
    c2nMin() ;
    void calculate(Entity cc) ;
    virtual void compute(const sequence &seq) ;
  } ;

  c2nMin::c2nMin() {
    name_store("cell2nodeMin(X)",cell2nodeMin) ;
    name_store("face2node",face2node) ;
    name_store("upper",upper) ;
    name_store("lower",lower) ;
    name_store("boundary_map",boundary_map) ;
    name_store("X",X) ;

    constraint("geom_cells") ;
    input("X") ;
    input("(upper,lower,boundary_map)->face2node->cell2nodeMin(X)") ;
    output("(upper,lower,boundary_map)->face2node->cell2nodeMin(X)") ;
  }

  void c2nMin::calculate(Entity cc) {

    node_list.clear() ;
    for(const Entity *fi=upper.begin(cc);fi!=upper.end(cc);++fi)
      for(const Entity *ni=face2node.begin(*fi);ni!=face2node.end(*fi);++ni)
        node_list.push_back(*ni) ;
    for(const Entity *fi=lower.begin(cc);fi!=lower.end(cc);++fi) 
      for(const Entity *ni=face2node.begin(*fi);ni!=face2node.end(*fi);++ni)
        node_list.push_back(*ni) ;
    for(const Entity *fi=boundary_map.begin(cc);fi!=boundary_map.end(cc);++fi) 
      for(const Entity *ni=face2node.begin(*fi);ni!=face2node.end(*fi);++ni)
        node_list.push_back(*ni) ;
    sort(node_list.begin(),node_list.end()) ;
    vector<int>::iterator ns = node_list.begin() ;
    vector<int>::iterator ne = unique(node_list.begin(),node_list.end()) ;
    
    
    
    for(vector<int>::iterator vi = ns;vi!=ne;++vi) {
      int nd = *vi ;
      join(cell2nodeMin[nd],realToFloat(X[cc])) ;
    }

  }

  void c2nMin::compute(const sequence &seq) {
    do_loop(seq,this) ;
  }

  register_rule<c2nMin> register_c2nMin ;


  class cell2nodeVectorMax : public unit_rule {
    store<vector3d<float> > node_value ;
  public:
    cell2nodeVectorMax() {
      name_store("cell2nodeMaxv3d(X)",node_value) ;
      constraint("pos") ;
      output("cell2nodeMaxv3d(X)") ;
    }
    void calculate(Entity e) {
        node_value[e] = vector3d<float>(0.,0.,0.) ;
    }
    void compute(const sequence &seq) {
      do_loop(seq,this) ;
    }
  } ;

  register_rule<cell2nodeVectorMax> register_cell2nodeVectorMax ;

  struct maxVect3d {
    void operator()(vector3d<float> &r, const vector3d<float> &s) {
        //      if(dot(s,s) > dot(r,r))
        if(s.x*s.x+s.y*s.y+s.z*s.z > r.x*r.x+r.y*r.y+r.z*r.z)
          r = s ;
      }
  } ;


  class c2nVectorMax : public apply_rule<store<vector3d<float> >, maxVect3d > {
    const_multiMap upper, lower, boundary_map ;
    const_multiMap face2node ;
    const_store<vect3d> X ;

    store<vector3d<float> > cell2nodeVectorMax ;
    vector<int> node_list ;
  public:
    c2nVectorMax() ;
    void calculate(Entity cc) ;
    virtual void compute(const sequence &seq) ;
  } ;

  c2nVectorMax::c2nVectorMax() {
    name_store("cell2nodeMaxv3d(X)",cell2nodeVectorMax) ;
    name_store("face2node",face2node) ;
    name_store("upper",upper) ;
    name_store("lower",lower) ;
    name_store("boundary_map",boundary_map) ;
    name_store("X",X) ;

    constraint("geom_cells") ;
    input("X") ;
    input("(upper,lower,boundary_map)->face2node->cell2nodeMaxv3d(X)") ;
    output("(upper,lower,boundary_map)->face2node->cell2nodeMaxv3d(X)") ;
  }

  void c2nVectorMax::calculate(Entity cc) {

    node_list.clear() ;
    for(const Entity *fi=upper.begin(cc);fi!=upper.end(cc);++fi)
      for(const Entity *ni=face2node.begin(*fi);ni!=face2node.end(*fi);++ni)
        node_list.push_back(*ni) ;
    for(const Entity *fi=lower.begin(cc);fi!=lower.end(cc);++fi) 
      for(const Entity *ni=face2node.begin(*fi);ni!=face2node.end(*fi);++ni)
        node_list.push_back(*ni) ;
    for(const Entity *fi=boundary_map.begin(cc);fi!=boundary_map.end(cc);++fi) 
      for(const Entity *ni=face2node.begin(*fi);ni!=face2node.end(*fi);++ni)
        node_list.push_back(*ni) ;
    sort(node_list.begin(),node_list.end()) ;
    vector<int>::iterator ns = node_list.begin() ;
    vector<int>::iterator ne = unique(node_list.begin(),node_list.end()) ;
    
    
    
    for(vector<int>::iterator vi = ns;vi!=ne;++vi) {
      int nd = *vi ;
      vector3d<float> xf = vector3d<float>(realToFloat(X[cc].x),
					   realToFloat(X[cc].y),
					   realToFloat(X[cc].z)) ;
      join(cell2nodeVectorMax[nd],xf) ;
    }

  }

  void c2nVectorMax::compute(const sequence &seq) {
    do_loop(seq,this) ;
  }

  register_rule<c2nVectorMax> register_c2nVectorMax ;

}
