#include <Loci.h>
#include <Tools/tools.h>

namespace Loci {

  typedef vector3d<real_t> vect3d ;
  typedef tensor3d<real_t> tens3d ;
  typedef real_t real ;
  
  
  class gradient_f : public pointwise_rule {
    const_storeVec<vect3d> gradX ;
    const_store<real> vol ;
    const_Map cl, cr ;
    const_store<Area> area ;
    const_store<vect3d> cellcenter ;
    const_storeVec<real> X ;
    storeVec<vect3d> grad_fX ;
    int vs ;
  public:
    gradient_f() ;
    void calculate (Entity fc) {
      const vect3d delta = cellcenter[cr[fc]]-cellcenter[cl[fc]] ;
      const real dist = dot(delta,area[fc].n) ;
      const real rdist = 1./dist ;
      const real vr = vol[cr[fc]] ;
      const real vl = vol[cl[fc]] ;
      const real dvrvl = 1./(vr+vl) ;
      const vect3d n = area[fc].n ;
      for(int i=0;i<vs;++i){
        const vect3d face_grad_cell_avg =
          (gradX[cr[fc]][i]*vl+gradX[cl[fc]][i]*vr)*dvrvl ;
        const vect3d face_grad_normal = n*(X[cr[fc]][i]-X[cl[fc]][i])*rdist ;
        
        grad_fX[fc][i] = face_grad_cell_avg - dot(face_grad_cell_avg,n)*n
          + face_grad_normal ;
      }
    }
    virtual void compute (const sequence &seq) ;
  } ;

  gradient_f::gradient_f() {
    name_store("cl",cl) ;
    name_store("cr",cr) ;
    name_store("X",X) ;
    name_store("area",area) ;
    name_store("cellcenter",cellcenter) ;
    name_store("gradv_f(X)",grad_fX) ;
    name_store("gradv(X)",gradX) ;
    name_store("vol",vol) ;
    input("(cr,cl)->(X,cellcenter,gradv(X),vol)") ;
    input("area") ;
    constraint("(cl,cr)->X") ;
    output("gradv_f(X)") ;
  }
  void gradient_f::compute (const sequence &seq) {
    vs=X.vecSize() ;
    grad_fX.setVecSize(vs) ;
    do_loop(seq,this) ;
  }

  class gradient_f_boundary : public pointwise_rule {
    const_storeVec<vect3d> gradX ;
    const_store<vect3d> facecenter,cellcenter ;
    const_Map cl ;
    const_storeVec<real> X,X_f ;
    const_store<Area> area ;
    storeVec<vect3d> grad_fX ;
    int vs ;
  public:
    gradient_f_boundary() ;
    void calculate (Entity fc) {
      const vect3d dist_v = facecenter[fc]-cellcenter[cl[fc]] ;
      const vect3d n = area[fc].n ;
      const real dist = dot(dist_v,n) ;
      const real rdist = 1./dist ;
      for(int i=0;i<vs;++i){
        const vect3d face_grad_cell_avg = gradX[cl[fc]][i] ;
        const vect3d face_grad_normal = n*(X_f[fc][i]-X[cl[fc]][i])*rdist ;
        grad_fX[fc][i] = face_grad_cell_avg - dot(face_grad_cell_avg,n)*n
          + face_grad_normal ;
      }
    }
    virtual void compute (const sequence &seq) ;
  } ;

  gradient_f_boundary::gradient_f_boundary() {
    name_store("cl",cl) ;
    name_store("cellcenter",cellcenter) ;
    name_store("facecenter",facecenter) ;
    name_store("X",X) ;
    name_store("X_f",X_f) ;
    name_store("gradv_f(X)",grad_fX) ;
    name_store("area",area) ;
    name_store("gradv(X)",gradX) ;
    input("cl->(X,cellcenter,gradv(X))") ;
    input("X_f,facecenter") ;
    input("area") ;
    constraint("ci->X") ;
    output("gradv_f(X)") ;
  }
  void gradient_f_boundary::compute (const sequence &seq) {
    vs=X.vecSize() ;
    grad_fX.setVecSize(vs) ;
    do_loop(seq,this) ;
  }

  class gradients_f : public pointwise_rule {
    const_store<vect3d> gradX ;
    const_Map cl, cr ;
    const_store<real> vol ;
    const_store<Area> area ;
    const_store<vect3d> cellcenter ;
    const_store<real> X ;
    store<vect3d> grad_fX ;
  public:
    gradients_f() ;
    void calculate (Entity fc) {
      const vect3d delta = cellcenter[cr[fc]]-cellcenter[cl[fc]] ;
      const vect3d n = area[fc].n ;
      const real dist = dot(delta,n) ;
      const real rdist = 1./dist ;
      const real vr = vol[cr[fc]] ;
      const real vl = vol[cl[fc]] ;
      const real dvrvl = 1./(vr+vl) ;
      const vect3d face_grad_cell_avg =
        (gradX[cr[fc]]*vl+gradX[cl[fc]]*vr)*dvrvl ;
      const vect3d face_grad_normal = n*(X[cr[fc]]-X[cl[fc]])*rdist ;
        
      grad_fX[fc] = face_grad_cell_avg - dot(face_grad_cell_avg,n)*n
        + face_grad_normal ;
    }
    virtual void compute (const sequence &seq) ;
  } ;

  gradients_f::gradients_f() {
    name_store("cl",cl) ;
    name_store("cr",cr) ;
    name_store("X",X) ;
    name_store("area",area) ;
    name_store("cellcenter",cellcenter) ;
    name_store("vol",vol) ;
    name_store("grads(X)",gradX) ;
    name_store("grads_f(X)",grad_fX) ;
    input("(cr,cl)->(X,cellcenter,grads(X),vol)") ;
    input("area") ;
    constraint("(cl,cr)->X") ;
    output("grads_f(X)") ;
  }
  void gradients_f::compute (const sequence &seq) {
    do_loop(seq,this) ;
  }

  class gradients_f_boundary : public pointwise_rule {
    const_store<vect3d> gradX ;
    const_store<vect3d> facecenter,cellcenter ;
    const_Map cl ;
    const_store<real> X ;
    const_store<real> X_f ;
    const_store<Area> area ;
    store<vect3d> grad_fX ;
  public:
    gradients_f_boundary() ;
    void calculate (Entity fc) {
      const vect3d dist_v = facecenter[fc]-cellcenter[cl[fc]] ;
      const vect3d n = area[fc].n ;
      const real dist = dot(dist_v,n) ;
      const real rdist = 1./dist ;
      const vect3d face_grad_cell_avg = gradX[cl[fc]] ;
      const vect3d face_grad_normal = n*(X_f[fc]-X[cl[fc]])*rdist ;
      grad_fX[fc] = face_grad_cell_avg - dot(face_grad_cell_avg,n)*n
        + face_grad_normal ;
    }
    virtual void compute (const sequence &seq) ;
  } ;


    gradients_f_boundary::gradients_f_boundary() {
    name_store("cl",cl) ;
    name_store("X",X) ;
    name_store("X_f",X_f) ;
    name_store("grads(X)",gradX) ;
    name_store("grads_f(X)",grad_fX) ;
    name_store("facecenter",facecenter) ;
    name_store("cellcenter",cellcenter) ;
    name_store("area",area) ;
    input("cl->(X,cellcenter,grads(X))") ;
    input("X_f,facecenter") ;
    input("area") ;
    constraint("ci->X") ;
    output("grads_f(X)") ;
  }
  void gradients_f_boundary::compute (const sequence &seq) {
    do_loop(seq,this) ;
  }

  class gradientv3d_f : public pointwise_rule {
    const_store<tens3d> gradX ;
    const_Map cl, cr ;
    const_store<real> vol ;
    const_store<Area> area ;
    const_store<vect3d> cellcenter ;
    const_store<vect3d> X ;
    store<tens3d> grad_fX ;
  public:
    gradientv3d_f() ;
    void calculate (Entity fc) {
      const vect3d delta = cellcenter[cr[fc]]-cellcenter[cl[fc]] ;
      const vect3d n = area[fc].n ;
      const real dist = dot(delta,n) ;
      const real rdist = 1./dist ;
      const real vr = vol[cr[fc]] ;
      const real vl = vol[cl[fc]] ;
      const real dvrvl = 1./(vr+vl) ;

      vect3d face_grad_cell_avg =
        (gradX[cr[fc]].x*vl+gradX[cl[fc]].x*vr)*dvrvl ;
      vect3d face_grad_normal = n*(X[cr[fc]].x-X[cl[fc]].x)*rdist ;
      grad_fX[fc].x = face_grad_cell_avg - dot(face_grad_cell_avg,n)*n
        + face_grad_normal ;

      face_grad_cell_avg =
        (gradX[cr[fc]].y*vl+gradX[cl[fc]].y*vr)*dvrvl ;
      face_grad_normal = n*(X[cr[fc]].y-X[cl[fc]].y)*rdist ;
      grad_fX[fc].y = face_grad_cell_avg - dot(face_grad_cell_avg,n)*n
        + face_grad_normal ;

      face_grad_cell_avg =
        (gradX[cr[fc]].z*vl+gradX[cl[fc]].z*vr)*dvrvl ;
      face_grad_normal = n*(X[cr[fc]].z-X[cl[fc]].z)*rdist ;
      grad_fX[fc].z = face_grad_cell_avg - dot(face_grad_cell_avg,n)*n
        + face_grad_normal ;
    }
    virtual void compute (const sequence &seq) ;
  } ;

  gradientv3d_f::gradientv3d_f() {
    name_store("cl",cl) ;
    name_store("cr",cr) ;
    name_store("X",X) ;
    name_store("area",area) ;
    name_store("cellcenter",cellcenter) ;
    name_store("vol",vol) ;
    name_store("gradv3d(X)",gradX) ;
    name_store("gradv3d_f(X)",grad_fX) ;
    input("(cr,cl)->(X,cellcenter,gradv3d(X),vol)") ;
    input("area") ;
    constraint("(cl,cr)->X") ;
    output("gradv3d_f(X)") ;
  }
  void gradientv3d_f::compute (const sequence &seq) {
    do_loop(seq,this) ;
  }

  class gradientv3d_f_boundary : public pointwise_rule {
    const_store<tens3d> gradX ;
    const_store<vect3d> facecenter,cellcenter ;
    const_Map cl ;
    const_store<vect3d> X ;
    const_store<vect3d> X_f ;
    const_store<Area> area ;
    store<tens3d> grad_fX ;
  public:
    gradientv3d_f_boundary() ;
    void calculate (Entity fc) {
      const vect3d dist_v = facecenter[fc]-cellcenter[cl[fc]] ;
      const vect3d n = area[fc].n ;
      const real dist = dot(dist_v,n) ;
      const real rdist = 1./dist ;

      vect3d face_grad_cell_avg = gradX[cl[fc]].x ;
      vect3d face_grad_normal = n*(X_f[fc].x-X[cl[fc]].x)*rdist ;
      grad_fX[fc].x = face_grad_cell_avg - dot(face_grad_cell_avg,n)*n
        + face_grad_normal ;

      face_grad_cell_avg = gradX[cl[fc]].y ;
      face_grad_normal = n*(X_f[fc].y-X[cl[fc]].y)*rdist ;
      grad_fX[fc].y = face_grad_cell_avg - dot(face_grad_cell_avg,n)*n
        + face_grad_normal ;

      face_grad_cell_avg = gradX[cl[fc]].z ;
      face_grad_normal = n*(X_f[fc].z-X[cl[fc]].z)*rdist ;
      grad_fX[fc].z = face_grad_cell_avg - dot(face_grad_cell_avg,n)*n
        + face_grad_normal ;
    }
    virtual void compute (const sequence &seq) ;
  } ;


    gradientv3d_f_boundary::gradientv3d_f_boundary() {
    name_store("cl",cl) ;
    name_store("X",X) ;
    name_store("X_f",X_f) ;
    name_store("gradv3d(X)",gradX) ;
    name_store("gradv3d_f(X)",grad_fX) ;
    name_store("facecenter",facecenter) ;
    name_store("cellcenter",cellcenter) ;
    name_store("area",area) ;
    input("cl->(X,cellcenter,gradv3d(X))") ;
    input("X_f,facecenter") ;
    input("area") ;
    constraint("ci->X") ;
    output("gradv3d_f(X)") ;
  }
  void gradientv3d_f_boundary::compute (const sequence &seq) {
    do_loop(seq,this) ;
  }


  register_rule<gradient_f> register_gradient_f ;
  register_rule<gradient_f_boundary> register_gradient_f_boundary ;

  register_rule<gradients_f> register_gradients_f ;
  register_rule<gradients_f_boundary> register_gradients_f_boundary ;

  register_rule<gradientv3d_f> register_gradientv3d_f ;
  register_rule<gradientv3d_f_boundary> register_gradientv3d_f_boundary ;

}
