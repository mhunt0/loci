//#############################################################################
//#
//# Copyright 2008, Mississippi State University
//#
//# This file is part of the Loci Framework.
//#
//# The Loci Framework is free software: you can redistribute it and/or modify
//# it under the terms of the Lesser GNU General Public License as published by
//# the Free Software Foundation, either version 3 of the License, or
//# (at your option) any later version.
//#
//# The Loci Framework is distributed in the hope that it will be useful,
//# but WITHOUT ANY WARRANTY; without even the implied warranty of
//# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//# Lesser GNU General Public License for more details.
//#
//# You should have received a copy of the Lesser GNU General Public License
//# along with the Loci Framework.  If not, see <http://www.gnu.org/licenses>
//#
//#############################################################################
#include <Loci.h>
#include <Tools/tools.h>

$include "FVM.lh"

namespace Loci {

  $type faceGradStencil param<std::string> ;
  
  $rule default(faceGradStencil),
    comments("Determines how face gradients will be computed.  May be 'positive' or 'limited'") {
    //$faceGradStencil = "positive" ;
    $faceGradStencil = "limited" ;
  }

  $type positiveFaceStencil Constraint ;
  $type limitedFaceStencil Constraint ;

  $rule constraint(positiveFaceStencil,limitedFaceStencil<-faceGradStencil) {
    $positiveFaceStencil = EMPTY ;
    $limitedFaceStencil = EMPTY ;
    if($faceGradStencil == "positive") {
      $positiveFaceStencil = $*faceGradStencil.domain() ;
    } else if($faceGradStencil == "limited") {
      $limitedFaceStencil = $*faceGradStencil.domain() ;
    }
  }
    
  typedef vector3d<real_t> vect3d ;
  typedef tensor3d<real_t> tens3d ;
  typedef real_t real ;

  $type X storeVec<real> ;
  $type X_f storeVec<real> ;
  
  $rule pointwise(gradv_f(X)<-(cr,cl)->(X,cellcenter,gradv(X),vol),area),
    constraint(positiveFaceStencil,(cl,cr)->X), prelude {
    $gradv_f(X).setVecSize($X.vecSize()) ;
  } compute {
    const vect3d delta = $cr->$cellcenter-$cl->$cellcenter ;
    const vect3d n = $area.n ;
    const real rdist = 1./dot(delta,n) ;
    const real vr = $cr->$vol ;
    const real vl = $cl->$vol ;
    const real dvrvl = 1./(vr+vl) ;
    const int vs = $*gradv_f(X).vecSize() ;
    for(int i=0;i<vs;++i) {
      const vect3d gradAvg=($cr->$gradv(X)[i]*vl+$cl->$gradv(X)[i]*vr)*dvrvl ;
      const vect3d gradTan=gradAvg-dot(gradAvg,n)*n ;
      const vect3d gradNorm=n*($cr->$X[i]-$cl->$X[i])*rdist ;
      $gradv_f(X)[i] = gradTan + gradNorm ;
    }
  }
  
  $rule pointwise(gradv_f(X)<-cl->(X,cellcenter,gradv(X)),X_f,facecenter,area),
      constraint(positiveFaceStencil,ci->X),prelude {
    $gradv_f(X).setVecSize($X.vecSize()) ;
  } compute {
    const vect3d delta = $facecenter-$cl->$cellcenter ;
    const vect3d n = $area.n ;
    const real rdist = 1./dot(delta,n) ;
    const int vs = $*gradv_f(X).vecSize() ;
    for(int i=0;i<vs;++i){
      const vect3d gradAvg = $cl->$gradv(X)[i] ;
      const vect3d gradTan=gradAvg-dot(gradAvg,n)*n ;
      const vect3d gradNorm = n*($X_f[i]-$cl->$X[i])*rdist ;
      $gradv_f(X)[i] = gradTan + gradNorm ;
    }
  }

  $type X store<real> ;
  $type X_f store<real> ;

  $rule pointwise(grads_f(X)<-(cr,cl)->(X,cellcenter,grads(X),vol),area),
    constraint(positiveFaceStencil,(cl,cr)->X) {
    const vect3d delta = $cr->$cellcenter-$cl->$cellcenter ;
    const vect3d n = $area.n ;
    const real rdist = 1./dot(delta,n) ;
    const real vr = $cr->$vol ;
    const real vl = $cl->$vol ;
    const real dvrvl = 1./(vr+vl) ;
    const vect3d gradAvg = ($cr->$grads(X)*vl+$cl->$grads(X)*vr)*dvrvl ;
    const vect3d gradTan=gradAvg-dot(gradAvg,n)*n ;
    const vect3d gradNorm = n*($cr->$X-$cl->$X)*rdist ;
      
    $grads_f(X) = gradTan + gradNorm ;
  }

  $rule pointwise(grads_f(X)<-cl->(X,cellcenter,grads(X)),X_f,facecenter,area),
    constraint(positiveFaceStencil,ci->X) {
    const vect3d delta = $facecenter-$cl->$cellcenter ;
    const vect3d n = $area.n ;
    const real rdist = 1./dot(delta,n) ;
    const vect3d gradAvg = $cl->$grads(X) ;
    const vect3d gradTan = gradAvg-dot(gradAvg,n)*n ;
    const vect3d gradNorm = n*($X_f-$cl->$X)*rdist ;

    $grads_f(X) = gradTan + gradNorm ;
  }

  $type X store<vect3d> ;
  $type X_f store<vect3d> ;

  $rule pointwise(gradv3d_f(X)<-(cr,cl)->(X,cellcenter,gradv3d(X),vol),area),
    constraint(positiveFaceStencil,(cl,cr)->X) {
    const vect3d delta = $cr->$cellcenter-$cl->$cellcenter ;
    const vect3d n = $area.n ;
    const real rdist = 1./dot(delta,n) ;
    const real vr = $cr->$vol ;
    const real vl = $cl->$vol ;
    const real dvrvl = 1./(vr+vl) ;

    vect3d gradAvg = ($cr->$gradv3d(X).x*vl+$cl->$gradv3d(X).x*vr)*dvrvl ;
    vect3d gradTan = gradAvg-dot(gradAvg,n)*n ;
    vect3d gradNorm = n*($cr->$X.x-$cl->$X.x)*rdist ;
    $gradv3d_f(X).x = gradTan + gradNorm ;

    gradAvg = ($cr->$gradv3d(X).y*vl+$cl->$gradv3d(X).y*vr)*dvrvl ;
    gradTan = gradAvg-dot(gradAvg,n)*n ;
    gradNorm = n*($cr->$X.y-$cl->$X.y)*rdist ;
    $gradv3d_f(X).y  = gradTan + gradNorm ;

    gradAvg = ($cr->$gradv3d(X).z*vl+$cl->$gradv3d(X).z*vr)*dvrvl ;
    gradTan = gradAvg-dot(gradAvg,n)*n ;
    gradNorm = n*($cr->$X.z-$cl->$X.z)*rdist ;
    $gradv3d_f(X).z  = gradTan + gradNorm ;
  }

  $rule pointwise(gradv3d_f(X)<-cl->(X,cellcenter,gradv3d(X)),X_f,facecenter,area),
    constraint(positiveFaceStencil,ci->X) {
    const vect3d delta = $facecenter-$cl->$cellcenter ;
    const vect3d n = $area.n ;
    const real rdist = 1./dot(delta,n) ;

    vect3d gradAvg = $cl->$gradv3d(X).x ;
    vect3d gradTan = gradAvg-dot(gradAvg,n)*n ;
    vect3d gradNorm = n*($X_f.x-$cl->$X.x)*rdist ;
    $gradv3d_f(X).x = gradTan + gradNorm ;

    gradAvg = $cl->$gradv3d(X).y ;
    gradTan = gradAvg-dot(gradAvg,n)*n ;
    gradNorm = n*($X_f.y-$cl->$X.y)*rdist ;
    $gradv3d_f(X).y = gradTan + gradNorm ;

    gradAvg = $cl->$gradv3d(X).z ;
    gradTan = gradAvg-dot(gradAvg,n)*n ;
    gradNorm = n*($X_f.z-$cl->$X.z)*rdist ;
    $gradv3d_f(X).z = gradTan + gradNorm ;
  }


  // Here we implement a directional derivative approach only limiting the
  // cell averaged gradients to prevent problems with maxima formation
  $type X storeVec<real> ;
  $type X_f storeVec<real> ;
  
  $rule pointwise(gradv_f(X)<-(cr,cl)->(X,cellcenter,gradv(X),vol),area,
                  (cl,cr)->limiterv(X)),
    constraint(limitedFaceStencil,(cl,cr)->X), prelude {
    $gradv_f(X).setVecSize($X.vecSize()) ;
  } compute {
    const vect3d delta = $cr->$cellcenter-$cl->$cellcenter ;
    const vect3d n = $area.n ;
    const real rdist = 1./dot(delta,n) ;
    const real vr = $cr->$vol ;
    const real vl = $cl->$vol ;
    const real dvrvl = 1./(vr+vl) ;
    const int vs = $*gradv_f(X).vecSize() ;
    for(int i=0;i<vs;++i) {
      const vect3d gl = $cl->$gradv(X)[i] ;
      const vect3d gr = $cr->$gradv(X)[i] ;
      const vect3d gradAvg=(gr*vl+gl*vr)*dvrvl ;
      const vect3d gradTan=gradAvg-dot(gradAvg,n)*n ;
      const real L_v = $cl->$limiterv(X)[i]*$cr->$limiterv(X)[i] ;
      const vect3d gradNorm=n*($cr->$X[i]-
                               ($cl->$X[i] + L_v*dot(gradTan,delta)) )*rdist ;
      $gradv_f(X)[i] = gradTan + gradNorm ;
    }
  }
  
  $rule pointwise(gradv_f(X)<-cl->(X,cellcenter,gradv(X)),X_f,facecenter,
                  cl->limiterv(X),area),
      constraint(limitedFaceStencil,ci->X),prelude {
    $gradv_f(X).setVecSize($X.vecSize()) ;
  } compute {
    const vect3d delta = $facecenter-$cl->$cellcenter ;
    const vect3d n = $area.n ;
    const real rdist = 1./dot(delta,n) ;
    const int vs = $*gradv_f(X).vecSize() ;
    for(int i=0;i<vs;++i){
      const real lim = $cl->$limiterv(X)[i] ;
      const vect3d gradAvg = $cl->$gradv(X)[i] ;
      const vect3d gradTan=gradAvg-dot(gradAvg,n)*n ;
      const vect3d gradNorm = n*($X_f[i]-
                                 ($cl->$X[i] + lim*dot(gradTan,delta)))*rdist ;
      $gradv_f(X)[i] = gradTan + gradNorm ;
    }
  }

  $type X store<real> ;
  $type X_f store<real> ;

  $rule pointwise(grads_f(X)<-(cr,cl)->(X,cellcenter,grads(X),vol),area,
                  (cl,cr)->limiters(X)),
    constraint(limitedFaceStencil,(cl,cr)->X) {
    const vect3d delta = $cr->$cellcenter-$cl->$cellcenter ;
    const vect3d n = $area.n ;
    const real rdist = 1./dot(delta,n) ;
    const real vr = $cr->$vol ;
    const real vl = $cl->$vol ;
    const real dvrvl = 1./(vr+vl) ;


    const vect3d gl = $cl->$grads(X) ;
    const vect3d gr = $cr->$grads(X) ;
    const vect3d gradAvg = (gr*vl+gl*vr)*dvrvl ;
    const vect3d gradTan=gradAvg-dot(gradAvg,n)*n ;    
    const real L_v = $cl->$limiters(X)*$cr->$limiters(X) ;
    const vect3d gradNorm = n*($cr->$X-
                               ($cl->$X+L_v*dot(gradTan,delta)))*rdist ;
      
    $grads_f(X) = gradTan + gradNorm ;
  }

  $rule pointwise(grads_f(X)<-cl->(X,cellcenter,grads(X)),X_f,facecenter,
                  cl->limiters(X),area),
    constraint(limitedFaceStencil,ci->X) {
    const vect3d delta = $facecenter-$cl->$cellcenter ;
    const vect3d n = $area.n ;
    const real rdist = 1./dot(delta,n) ;
    const real lim = $cl->$limiters(X) ;
    const vect3d gradAvg = $cl->$grads(X) ;
    const vect3d gradTan = gradAvg-dot(gradAvg,n)*n ;
    const vect3d gradNorm = n*($X_f-($cl->$X+lim*dot(gradTan,delta)))*rdist ;
    $grads_f(X) = gradTan + gradNorm ;
  }

  $type X store<vect3d> ;
  $type X_f store<vect3d> ;

  $rule pointwise(gradv3d_f(X)<-(cr,cl)->(X,cellcenter,gradv3d(X),vol),area,
                  (cl,cr)->limiterv3d(X)),
    constraint(limitedFaceStencil,(cl,cr)->X) {
    const vect3d delta = $cr->$cellcenter-$cl->$cellcenter ;
    const vect3d n = $area.n ;
    const real rdist = 1./dot(delta,n) ;
    const real vr = $cr->$vol ;
    const real vl = $cl->$vol ;
    const real dvrvl = 1./(vr+vl) ;

    vect3d gl = $cl->$gradv3d(X).x ;
    vect3d gr = $cr->$gradv3d(X).x ;
    real L_v = $cl->$limiterv3d(X).x*$cr->$limiterv3d(X).x ;
    vect3d gradAvg = (gr*vl+gl*vr)*dvrvl ;
    vect3d gradTan = gradAvg-dot(gradAvg,n)*n ;
    vect3d gradNorm = n*($cr->$X.x-($cl->$X.x+L_v*dot(gradTan,delta)) )*rdist ;
    $gradv3d_f(X).x = gradTan + gradNorm ;

    gl = $cl->$gradv3d(X).y ;
    gr = $cr->$gradv3d(X).y ;
    L_v = $cl->$limiterv3d(X).y*$cr->$limiterv3d(X).y ;
    gradAvg = (gr*vl+gl*vr)*dvrvl ;
    gradTan = gradAvg-dot(gradAvg,n)*n ;
    gradNorm = n*($cr->$X.y-($cl->$X.y + L_v*dot(gradTan,delta)) )*rdist ;
    $gradv3d_f(X).y  = gradTan + gradNorm ;

    gl = $cl->$gradv3d(X).z ;
    gr = $cr->$gradv3d(X).z ;
    L_v = $cl->$limiterv3d(X).z*$cr->$limiterv3d(X).z ;
    gradAvg = (gr*vl+gl*vr)*dvrvl ;
    gradTan = gradAvg-dot(gradAvg,n)*n ;
    gradNorm = n*($cr->$X.z-($cl->$X.z + L_v*dot(gradTan,delta)) )*rdist ;
    $gradv3d_f(X).z  = gradTan + gradNorm ;
  }

  $rule pointwise(gradv3d_f(X)<-cl->(X,cellcenter,gradv3d(X)),X_f,facecenter,
                  cl->limiterv3d(X),area),
    constraint(limitedFaceStencil,ci->X) {
    const vect3d delta = $facecenter-$cl->$cellcenter ;
    const vect3d n = $area.n ;
    const real rdist = 1./dot(delta,n) ;

    real lim = $cl->$limiterv3d(X).x ;
    vect3d gradAvg = $cl->$gradv3d(X).x ;
    vect3d gradTan = gradAvg-dot(gradAvg,n)*n ;
    vect3d gradNorm = n*( $X_f.x-($cl->$X.x+lim*dot(gradTan,delta)) )*rdist ;
    $gradv3d_f(X).x = gradTan + gradNorm ;

    lim = $cl->$limiterv3d(X).y ;
    gradAvg = $cl->$gradv3d(X).y ;
    gradTan = gradAvg-dot(gradAvg,n)*n ;
    gradNorm = n*( $X_f.y-($cl->$X.y+lim*dot(gradTan,delta)) )*rdist ;
    $gradv3d_f(X).y = gradTan + gradNorm ;

    lim = $cl->$limiterv3d(X).z ;
    gradAvg = $cl->$gradv3d(X).z ;
    gradTan = gradAvg-dot(gradAvg,n)*n ;
    gradNorm = n*( $X_f.z-($cl->$X.z+lim*dot(gradTan,delta)) )*rdist ;
    $gradv3d_f(X).z = gradTan + gradNorm ;
  }

}
