\documentclass{article}

\topmargin  0.0in
\headheight  0.15in
\headsep  0.15in
\footskip  0.2in
\textheight 8.45in

\oddsidemargin 0.56in
\evensidemargin \oddsidemargin
\textwidth 5.8in

\input{epsf}

\pagestyle{myheadings}
\markright{\bf Loci user guide (version 0.1)}

\begin{document}

\title{Loci: The User Guide}

\author{ Edward A. Luke \\
\it lush@erc.msstate.edu}

\maketitle

\section{Introduction}

\section{Using the library}

The library is provided with configuration files that specifies which
compiler and compiler options must be used to compile the Loci code.
Currently Loci is compiled under either the Kuck \& Associates compiler
(KCC)\footnote{KCC is available only on the erc machines {\tt titan}
  and {\tt andy}} and the SGI CC version 7.3.  It is helpful to use
the example makefile listed in figure \ref{makefile}.  The simplest
approach to using the generic Loci facilities is to include {\tt
  "Loci.h"}.

\begin{figure}[htbp]
\begin{verbatim}
# This is the Loci base directory.  The one listed here defines the
# debugging version for the SGI platform
LOCI_BASE = /projects/ds/loci/debug/sgi/

# List the name of your compiled program here
TARGET = prog

# List your object files here
OBJS =  main.o

include $(LOCI_BASE)/sys.conf
include $(LOCI_BASE)/comp.conf


DEFINES = $(MACHINE_SPECIFIC) $(DEBUG)

INCLUDES  = -I$(LOCI_BASE)/include 
LIBS      = -L$(LOCI_BASE)/lib -lLoci -lTools $(BASE_LIBS)

CP  = $(CPP) $(CPPOPT) 
CC  = $(CPP) $(CPPOPT)

JUNK = *~  core ti_files ii_files make.depend make.depend.bak

.SUFFIXES: .o .c .cc

.c.o:    ;  $(CC) $(COPT) $(DEFINES) $(INCLUDES) -c $*.c
.cc.o:   ;  $(CP) $(COPT) $(DEFINES) $(INCLUDES) -c $*.cc


default:
        $(MAKE) $(TARGET)

$(TARGET): $(OBJS) FRC
        $(LD) -o $(TARGET) $(LDFLAGS) $(OBJS) $(LOCAL_LIBS) $(LIBS)


FRC : 

clean:
        rm -fr $(OBJS) $(TARGET) $(JUNK)

\end{verbatim}
 \caption{An Example Loci Makefile}
 \label{makefile}
\end{figure}



\section{Containers}

The most fundamental concept in the Loci library is the concept of an
entity.  Entities are conceptually places where values can be stored.
In Loci, these entities are given integer identifiers and stored in
sets.  Various containers can be used to bind values to entities.  The
basic categorization of containers is illustrated in figure
\ref{constructs}.  These containers provide mappings between entities
and either values or other entities.

\begin{figure}[htbp]
  \centerline{ \epsfxsize=5.5in \epsfbox{figures/constructs.eps}}
 \caption{Four Basic Container Categories}
 \label{constructs}
\end{figure}

\subsection{The entity set}

Entity sets are used in Loci to for control and allocation.  These
sets provide an efficient interface for sets of integer identifiers.
The entity set functionality is provided by the class {\tt entitySet}.
This class provides basic set operations union, intersection, and
complement by overloading the operators {\tt \&}, {\tt |}, and {\tt -}
respectively.  In fact, all of the bitwise operators are overloaded
such that an {\tt entitySet} has the appearance of a large bit string.
In addition, one can iterate over the set of integers stored in an
entitySet by using {\tt entitySet::const\_iterator}.  {\tt entitySet}
has member functions {\tt begin()} and {\tt end()} that mimic the
semantics of STL container types.  For example, see figure
\ref{entityset}.

\begin{figure}[htbp]
\begin{verbatim}
#include <Loci.h>

int main()
{
  entitySet A,B,C,D,E ;

  // Assign set A to the interval [1,10] 
  A = interval(1,10) ;
  A += 2 ; // Add 2 to set A (note it is already in A)
  A += 20 ; // Add 20 to set A
  B = interval(5,20) ;
  C = A & B ;  // C = intersection of A and B
  D = A | B ;  // D = union of A and B
  E = A - C ;  // E = A remove elements in C

  // Write out results
  cout << "A = " << A << " B = " << B << endl ;
  cout << "C = " << C << " D = " << D << endl ;
  cout << "E = " << E << endl ;

  // Loop over set C and print integers in set one by one
  entitySet::const_iterator ei ;
  for(ei=C.begin();ei!=C.end();++ei)
    cout << *ei << " " ;
  cout << endl ;
  return 0 ;
}
\end{verbatim}
 \caption{An example of Loci's entitySet}
 \label{entityset}
\end{figure}

\subsection{The store and variants}

The {\tt store} is a container that allows the association of values
to entities given in an {\tt entitySet}.  One can think of the {\tt
  store} as an array where the bounds are specified by an given
entitySet.  Once the store is constructed, the array is allocated by
use of the {\tt allocate() } method.  A {\tt const\_store} is also
provided when read only access to an array is required.  In addition
to the standard store, there is {\tt storeVec} and {\tt storeMat}
which provide a way of allocating vectors and matrices where the sizes
of these types are specified at runtime through the {\tt setVecSize()}
method.  The elements of a {\tt store} are accessed using the
traditional C array operator.

\subsection{The parameter}

The parameter implemented by the templated class {\tt param} provides
a singleton interface for store.  It binds a single value to a set of
entities.  The value is accessed by using the dereference operator.

\subsection{The Map and variants}



\subsection{The constraint}

\end{document}
