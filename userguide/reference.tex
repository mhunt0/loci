\documentclass[letterpaper,12pt]{article}
\usepackage{epsf}    % used for importing encapsulated postscript figures
\usepackage{amsmath} % used for extended formula formatting tools
\usepackage{amssymb}
\usepackage{theorem}
\usepackage{euscript}
\usepackage{ulem}
\usepackage{picinpar}

\normalem

\topmargin  0.0in
\headheight  0.15in
\headsep  0.35in
\footskip  0.2in
\textheight 8.25in

\oddsidemargin 0.2in
\evensidemargin \oddsidemargin
\textwidth 6.2in
\pagestyle{myheadings}
\markright{\uline{Loci Quick Reference}}

\begin{document}
\title{\bf The Loci Quick Reference} 
\date{ }
%\author{{\bf Edward A. Luke}\\
%NSF Engineering Research Center\\
%Mississippi State University \\
%Box 9627, Mississippi State, MS  39762, USA\\
% {\it lush@erc.msstate.edu}} 
\maketitle

\section{Entity Set}

\section*{Introduction}

The most fundamental concept in the Loci library is the concept of an
{\bf entity}.  Entities are conceptually places where values can be
stored. In Loci, these entities are given integer identifiers. An
entity can be considered to be an interval and an entitySet, a
collection of intervals. The entitySets are used in Loci for control
and allocation. These sets provide an efficient interface for sets of
integer identifiers.

A typical interval is just a pair of integers which denotes the beginning and 
the end of a set of ineger identifiers. 
Example : 
\begin{verbatim}
        A = interval(1 , 10) ; //contains one interval representing
                               // integer identifiersfrom 1 to 10.
\end{verbatim}

One can iterate over the set of integers stored in the {\tt entitySet} by using\\
{\tt entitySet::const\_iterator}.

\begin{verbatim}
Example:  
        for(entitySet::const_iterator ei = A.begin( );ei!=A.end( ); ei++)
                cout << *ei << "    " ;
             cout << endl;
\end{verbatim}
The member functions {\tt begin( )} and {\tt end( )} mimic the
semantics of the STL container types. {\tt A.begin( )} points to the first
element in the interval while {\tt A.end( )} returns a pointer to the
location beyond the last element in the interval. The dereferencing
{\tt operator *( )} can be used to return the value of the corresponding
integer identifier. The above example gives the following output when
{\tt A} is $[1, 10]$:

\begin{verbatim}
1  2  3  4  5  6  7  8  9  10  
\end{verbatim}


\section*{Member Functions}

\subsection{inSet()}
\begin{verbatim}
bool inSet(int_type indx) const 
Example : A.inSet(2)   Returns true if the integer value 2 is present in the 
entitySet A.
\end{verbatim}

\subsection{num\_intervals( )}

int num\_intervals ( ) const

Returns the number of intervals in the entitySet.
\begin{verbatim}
Example : 
        If A = [1, 10] [ 12 , 20]
        A.num_intervals( ) returns the value 2.
\end{verbatim}

\subsection{Equal ( )}
\begin{verbatim}
bool Equal ( const entitySet \&ptn)
Example :
        A.Equal ( B ) ;
\end{verbatim}

Returns true if both A and B point to the same entitySet. 

\subsection{less\_than( )}

\begin{verbatim}
bool less_than(const entitySet &es)
\end{verbatim}

Provides a canonical ordering for {\tt entitySet} objects so that they can be 
used as keys to associative containers such as STL {\tt map<>}.

\subsection{greater\_than( )}
 
\begin{verbatim}
bool greater_than(const entitySet &es)
\end{verbatim}

Provides a canonical ordering for {\tt entitySet} objects so that they can be 
used as keys to associative containers such as STL {\tt map<>}.

\subsection{Min( )}
\begin{verbatim}
int Min( ) const
\end{verbatim}
Example:

{\tt A.Min( )} returns the minimum value of the integer identifiers in the 
{\tt  entitySet A}. 

\subsection{Max( )}
\begin{verbatim}
int Max( ) const 
\end{verbatim}
Example:

{\tt A.Max( )} returns the maximum value of the integer identifiers in the 
{\tt entitySet A}.

\subsection{Union( )}
\begin{verbatim}
void entitySet : : Union ( const interval &ivl)
void entitySet : : Union ( const entitySet &es)

Example :  
        entitySet A = interval(1,10)
        entitySet B = interval(12, 20)
        A.Union( interval(11, 15)) returns A as A = [1, 15]

        A.Union(B) returns A as A = [1, 10] [ 12, 20]


static entitySet : : Union ( const entitySet & set1, const entitySet &set2)
\end{verbatim}

The union of set1 and set2 is returned without modifying either of the sets.

\subsection{Intersection ( )}
Intersection is defined in a similar way to Union. 
\begin{verbatim}
void entitySet : : Union ( const interval &ivl)
void entitySet : : Union ( const entitySet &es)
static entitySet : : Union ( const entitySet & set1, const entitySet & set2)
\end{verbatim}

\subsection{Complement( ) }

{\tt void Complement ( ) }

Example: If {\tt entitySet A} = [6,15] [ 17, 25] {\tt A.Complement( )}
results in {\tt A = [\#, 5] [16, 16] [26, \#]} where the first {\tt
  \#} sign represents the lowest possible integer value for a
particular int\_type and the second {\tt \#} sign represents the maximum
integer value for a particular int\_type.

{\tt static entitySet : : Complement( const entitySet \&set1)}
Returns the complement of the entitySet set1 without modifying the contents of 
the set1.

\section*{Operators}
\begin{verbatim}
inline std : : ostream &operator << (std : : ostream &s, const entitySet &e)
inline std : : isteam &operator >>  (std : : istream &s, entitySet &e)

Example:
\begin{verbatim}
        entitySet A = interval(1, 10);
        A.Union ((interval(12, 20))
        cout  << A << endl ; 
\end{verbatim}

Gives the output {\tt ([1, 10] [ 12, 20])}

The preferred way to use the basic set operations {\tt Union( )}, {\tt
Intersection( )} and  {\tt Complement( )} member function is to use
the operators which have been overloaded. The bitwise operators {\tt
\&}, {\tt | } and {\tt \char94 } are overloaded such that an 
{\tt entitySet} has the appearance of a large bit string. 

\begin{verbatim}
 inline entitySet operator ~ ( const entitySet &e)
\end{verbatim}
{\tt \char126 } operator returns the complement of the set .

Example :  
        If {\tt A} = {\tt [1, 10] [ 12, 20]} then 
        {\tt E = \~A} gives the output {\tt [\#, 0] [11, \#]}
 Similarly the operator {\tt +=} and {\tt \&=} are used to Union two sets. 

The operator {\tt -} is used in a similar way to  both the {\tt +} and
the {\tt \char126 }.
\begin{verbatim}
inline entitySet &operator += (entitySet &e, int_type val)
inline entitySet &operator | = (entitySet &e, const entitySet &es)
inline entitySet &operator &= (entitySet &e, const interval &ivl)
\end{verbatim}

The operator {\tt \char94} is overloaded to perform  the following operation.
\begin{verbatim}
 inline entitySet operator ^ (const entitySet &e, const entitySet &es)
{
  entitySet retp = ((e | es) &~ (e & es)) 
  return retp
}
\end{verbatim}
The {\tt \char94} operator is also defined for the following arguments.

\begin{verbatim}
 inline entitySet operator ^ (const entutySet &e, int_type ival)
 inline entitySet operator ^ (const entitySet &e, const interval &ivl)
\end{verbatim}


\newpage
\section{SEQUENCES}

Defined in class sequence. Sequences are used for control of
entitySets.  Sequences give a particular ordering for the
entitySet. In cases of recursive rules it might be necessary to visit
the entities in a particular order. Another advantage of the sequence
is that it allows duplicates to be present.  The class sequence has a
{\tt const\_iterator} which makes it easy for a user to iterate over
the sequence. The member functions {\tt begin( )}, {\tt end( )}, {\tt size( )},
{\tt num\_intervals( )}, {\tt less\_than( )}, {\tt Equal( )} and {\tt
greater\_than} as well
as the operators {\tt =},{\tt ==},{\tt !=}, {\tt <<}, {\tt >>}, {\tt
<<=}, {\tt >>=} , {\tt +}, {\tt +=}, are similar to
those defined in the class entitySet.

In addition to these, we have two more functions {\tt Append( )} and
{\tt Reverse( )}.

\subsection{Append ( )}
\begin{verbatim}
void Append(const  interval &ivl)
void Append(const sequence &seq)
void Append(const intervalSet &es)
\end{verbatim}

Append works similar to the Union operation defined in class {\tt
entitySet}. Append adds an interval or an {\tt entitySet} or a sequence in
the order in which it is called. i.e it preserves the order in the
sequence.  Example : If {\tt A} is the sequence {\tt [1, 10] [12, 20]} \\

            {\tt  A.Append(interval(5,20))} returns {\tt A} as {\tt [1,10] [12, 20],[5,20]}

\subsection{Reverse ( )}
\begin{verbatim}
sequence &Reverse( )
\end{verbatim}

Returns a sequence. The intervals are in the reverse order. Each of
the pointers to the beginning and the end of all the intervals in the
sequence are swapped with each other.

Example: If {\tt A} is a sequence {\tt [1, 10] [12,20] [5,20]} \\
       {\tt  P = A.Reverse( );} returns {\tt P} as {\tt [20, 5] [ 20, 12] [10, 1]}

The following template functions are also defined .

\begin{verbatim}
template < class Op > inline void do_loop(const entitySet &iset, Op f)
template < class Op > inline void do_loop(const sequence &seq, Op f)
template <class T> inline void do_loop(const sequence &seq, T cp, 
                                                void (T: :*pmf)(Entity))
\end{verbatim}

These template functions are defined to loop over intervals in the
entitySet and calculate a particular function.  Example: Suppose there
is a function called 'calculate' defined over the Entity e, in the
class 'interface\_gradient'.  

\begin{verbatim}
virtual void compute(const sequence &seq){ 
    do_loop(seq, this, &interface_gradient: : calculate) 
}
\end{verbatim}

The above statement calculates the value of the function defined in
calculate for all entities in the sequence seq.



\newpage
\section{STORE}

The store is a container that allows the association of values to
entities given in an entitySet. The store provides an injective
mapping from entities to values.
\begin{verbatim}
Class : Store
template< class T> class store : public store_instance
Example : 
        store<float> X;
        entitySet A = interval(1, 10);
        store<float> Y(A); // Create a store allocated for entitities in A
\end{verbatim}

\section*{Member  Functions}

\subsection{allocate ( ) }

\begin{verbatim}
   void allocate(const entitySet \&ptn)  
\end{verbatim}

After declaring a store the next step is to allocate memory. Member
function {\tt allocate( )} allocates memory for all entities in the
specified {\tt entitySet}.

\begin{verbatim}
Example : 
        entitySet A = interval(1,10) ; // Create an entitySet 
        store<float> X ; // Create a store of floats
        X.allocate(A) ; //allocates an array of floats dimensioned 1..10
\end{verbatim}

\subsection{domain( )}
\begin{verbatim}
entitySet domain( ) const
\end{verbatim}

Returns the domain of the store.  It is nothing but the {\tt
entitySet} over which the store is allocated.  

\begin{verbatim}
Example: 
         entitySet r = X.domain( ) // r = ([1,10]) if X is from above
\end{verbatim}

\section*{ Operators }

\begin{verbatim}
T &operator [ ] (int indx)
\end{verbatim}

The {\tt operator [ ]} is used to access the elements assocoated with
a store. In fact the store can be considered to be an array where the
bounds are specified by a given entitySet.

\begin{verbatim}
Example:
        store <float> X;
        entitySet A = interval (1, 5);
        store<float> Y(X) ;
        for(entitySet: : const_iterator ei = A.begin( ); ei!= A.end ( ); ei++)
          X[*ei] = float(*ei)/10.0;
\end{verbatim}


The {\tt operators <<} , {\tt >>} are used to output and input the
values in a store.

\begin{verbatim}
template<class T> inline std : : ostream &operator <<  (std : : ostream &s, 
                                                        const store<T> &t)

template<class T> inline std : : istream &operator >> (std : : istream &s, 
                                                       const store<T>&t)

Example : 
        cout << X;
\end{verbatim}

This gives the following output.
\begin{verbatim}
{
  ([1, 5] ) 
 0.1
 0.2
 0.3
 0.4
 0.5
}       
\end{verbatim}

The first line gives the domain of the store.

\section*{const\_store}

\begin{verbatim}
template<class T> class const_store : public store_instance
\end{verbatim}


{\tt const\_store} is provided for read-only access to a store.  A {\tt
const\_store} can be declared in a similar way to store. {\tt
const\_store} provides the standard services available to {\tt store}
containers, however it only allows const access to its contents.

\begin{verbatim}
Example : 
        const_store<float> X;
        entitySet A = interval(1, 5);
        const_store<float> Y(A);
        const_store<float> Z(X);
\end{verbatim}



\section{storeVec \& storeMat}

\section*{Member Functions}

{\tt storeVec }provides a way of allocating vectors. The member functions
allocate() and initialize ( ) are similar to those defined for the standard store. The 
sizes for the storeVec is specified at runtime through the method {\tt  setVecSize( )}
\begin{verbatim}
void setVecSize( int size)
Example : 
        storeVec < float > X;
        entitySet A = interval(1, 10);
        X.setVecSize( 5 );
In the above example, X is a storeVec allocated over the entitySet A. The size 
of the vector associated with the entitySet A is assigned by the X.setVecSize 
statement.

In addition to the setVecSize ( ) there is also the method {\tt vecSize( )}, which 
returns the size of the vector assocoated with each entity.

 int vecSize( ) const
\end{verbatim}

\section*{Operators}
\begin{verbatim}
The elements in the storeVec are accessed using the [ ] operator. 
Example:
        for(entitySet: : const_iterator ei = A.begin( ); ei! = A.end( );ei++    
{
        for(int i = 0; i < size; i++)
        X[*ei][i] = float(*ei)/10.0;
        }
The operators << and >> are overloaded in a way similar to that of the standard 
store. 
For the above example the statement:
cout << X;   gives the output 
\end{verbatim}
   \pagebreak[4]     
\begin{verbatim}
{ ([1, 5])
        5   
        0.1     0.1     0.1     0.1     0.1     0.1
        
        0.2     0.2     0.2     0.2     0.2     0.2

        0.3     0.3     0.3     0.3     0.3     0.3

        0.4     0.4     0.4     0.4     0.4     0.4

        0.5     0.5     0.5     0.5     0.5     0.5
}

\end{verbatim}
The first line gives the domain of the storeVec while the second line gives the 
size of the vector associated with the entitySet.
\section{const\_storeVec}

A const\_storeVec is also provided when read\_only access to a store is required. 
This is similar to the standard const\_store.
The operators =, <<, [ ] and also the member functions vecSize( ) and domain( ) 
is defined similar to the storeVec. 

\section*{Operator Overloading for vectors}
\begin{verbatim}
In the class Vect the operators =, +=, *=, -=, /= are overloaded as follows. 
 template <class S> void operator += (const Scalar<s> &s)
Example:
        storeVec H, J;
        int sz;
        entitySet A = interval[1, 10];
        J.setVecSize(sz);
        H.setVecSize(sz);
        for(entitySet: : const_iterator ei = A.begin( ); ei!= A.end( ); ei++){
        for(int i = 0; i <  sz; i++)
        J[*ei][i] = *ei;
        }       
        H = J ; // makes  H and J point to the same storeVec.

To do vector - Scalar operations we need to explicitly call the mk_Scalar( ) 
method. 
Example :
        J[*ei] *= mk_Scalar(2);
But for the operations of vectors with vectors and const_vectors only the 
following operators are overloaded : +=  , -=. +, -. 
Example:
        J[*ei] += H[*ei]  // J[*ei] points to a vector

\end{verbatim}

\section{storeMat}
Provides a way of allocating square matrices. The allocation is similar to those 
of storevec. 
\begin{verbatim}
Example :
        storeMat<float> X;
        storeMat<float> X(A) //A is an entitySet

The methods allocate( ), initialize( ), domain( ), are similar to those of 
storeVec. The size of the matrix is specified at runtime using the setVecSize( ) 
method. 
Example:
        X.setVecSize( 10 ); // Creates a matrix of size 10 x 10
\end{verbatim}

\section*{Operators}
\begin{verbatim}
The [ ] operator is used to reference the objects stored in the matrix. 
Example: 
        for( entitySet: :const_iterator ei = A.begin( ); ei!= A.end( ); ei++)
        for( int i =0; i <  sz; i++)
        for(int j =0; j <  sz; j++)
         X[*ei][i][j] = j;

The operators << and >> are overloaded in a manner similar to those in storeVec.
Example:
        cout << X;
\end{verbatim}
\pagebreak[4]
\begin{verbatim}
The above statement outputs the elements in the storeMat X. 
{ ([1,5])  
4
1 1 1 1 1
2 2 2 2 2 
3 3 3 3 3 
4 4 4 4 4 
}
\end{verbatim}
 The first line gives the domain( ) while the second line gives the square root 
of the size of the matrix. The complete natrix associated with each entity is 
displayed in a single row.

\section{const\_StoreMat}

For providing read\_only access. The member functions vecSize( ) and domain( ) 
are defined in the same way as for the storeMat. 

\section*{Operators }
\begin{verbatim}
 
A number of operators and methods are present in the class Mat_partial. 
The operators overloaded include +=, -=, /=, *= for operations of matrices with 
scalars.
template< class S> void operator /= (const Scalar<s> &s)
Example : 
        X[*ei] /= mk_Scalar(2); 
 // divides the elements in the matrix (corresponding to the entity pointed to by ei) by the scalar 2.

Similarly the operators +=, -= are defined for matrix - matrix operations. 
 template<class S> void operator += (const Mat<S> &t)
 template<class S> void operator +=(const const_Mat<S> &t)

The following functions are defined in the class Mat_partial for solving linear 
system of equations using Gauss Siedel iteration with and without pivoting. 

template<class S> void solve_lu(const S *b, S *x) const
template<class T1, class T2> void solve_lu(const_Vect <T1> *b, T2 *x) const
template<class T1, class T2> void solve_lu(const T1 *b, Vect<T2> x) const
template<class S> void solve_lu_pivot(const S *b, S *x, const pivot_type *pivot) const


template<class Tin, class Tout > void dotprod_accum(const Tin *vin, Tout *vout) 
const
template<class Tin, class Tout > void dotprod_accum(const Vect<Tin> &vin, Tout 
*vout) const
template<class Tin, class Tout > void dotprod_accum(const const_Vect<Tin> &vin, 
Tout *vout) const

The functions for decomposing the matrix into the lower and upper triangular 
matrices is done by the function decompose_lu and decompose_lu_pivot defined in 
the class Mat.

void decompose_lu ( )
void decompose_lu_pivot ( pivot_type *pivot)
\end{verbatim}

\section{Parameter}

The parameter implemented by the templated class param provides a {\tt singleton }
interface for the store. It binds a single value to a set of entities. 
 \begin{verbatim}
template < class T> class param : public store_instance
The declaration is similar to a store. 
Example:
        param<float> f;
        param<float> g(B) //B is an entitySet
        param<float> h(f)
The dereference operator {\tt *} is used to access the value.
Example;

        *f = 2;
        g = 2; // associates the value 2 with all the entities in B

The operators << and >> are overloaded as follows. 
template<class T> inline std: : ostream &operator >> (std : : ostream &s, 
                                                      param<T> &t) 
\end{verbatim}
\pagebreak[4]

\begin{verbatim}
Example: 
        cout << g; gives the following output.

{ [1,5]          // entitySet associated with the param.
2               //value associated  with the entitySet
}

Similar to a const_store there is a const_param. The operators '*'and  <<  are 
similar to those of the regular param but it provides only read_only access.

template<class T> inline std : :ostream &operator << (std : : ostream &s, const t        
                                                      const_param<T> &t)


\end{verbatim}

\section{Maps}

Maps are used to specify relationships between entities. Maps provide a one to 
one relationship( valence of 1). Defined in class Map. 
\begin{verbatim}
Class Map : public store_instance
Example: 
        Map cl, cr; 
        entitySet A = interval(1,5);
        cl.allocate(A);
        Map cl1(A);
        Map cr2(cl);
The member functions allocate( ), initialize( ), and domain( ) are similar to 
those defined for the store. 
Similarly the operators =, << , >> are overloaded as before.
Example:
        cout << cl;
gives the output 
{       ([1,5])                 //domain of the mapping
        1
        2                       // values associated with each entity
        3
        4
        5
}
\end{verbatim}
A {\tt const\_Map} is also defined to provide read\_only access.


\section{multiMap}
Provides for variable valence relationship. The domain for the mapping is an 
entitySet. A store<int> is provided to the allocate member function. The domain 
of the multiMap will correspond to the domain of the store that contains the 
valence number of each correspondence.
\begin{verbatim}
Example:
        multiMap nd2e;
        store<int> count;
        count.allocate(nodes);  // nodes is an entitySet
        nd2e.allocate(count);
In the above example 'count' is a store of integers. It stores the valence 
number of each correspondence from the entitySet 'nodes'.  
\end{verbatim}

\section*{Operators}

The [ ] operator is used to access the elements associated with a
mapping .
\begin{verbatim}
Example:
        for(entitySet: : const_iterator ei = nodes.begin(); 
ei!=nodes.end();ei++){
        cout nd2e[*ei][count[*ei]];
The store end could contain a zero valence which implies that no mapping exists. 

The operator  << is overloaded to output the values.
Example :
        cout << nd2e;
Gives the following output
{       ([1,5])
        1
        2
        5         // these are the values of the count( the valence of the 
                 //  mapping)
        :       
        :
        4
        
        1 
        2 3 
        4 5 7 8 9       //these are the values associated for each 
                       // entity(corresponding to the valence)
        :
}
\end{verbatim}
A {\tt const\_multiMap} is also defined in a similar way to a const\_Map.


\section{MapVec}

MapVec is used to provide a constant valence relationship. Declaration and 
allocation is similar to the regular Map. The structure is similar to a 
multiMap. The only difference is that the valence is fixed.


\end{document}
